##　什么是DOM

> - 通过 JS 改动 HTML 方式就是用 DOM
> - DOM 其实和 HTML 完全相同，总是和页面的 HTML 相同
> - 如果修改 DOM 上任何东西 HTML 就会自动更新，如果添加新的 HTML，DOM也会跟着改变
> - DOM内包含有
>   - 方法
>     - 方法是附属于 document 对象的函数，可以执行像：允许我们选择指定的 HTML 元素，例如：页面的标题
>   - 对象
>     - 通过 document 对象，子对象有更多的对象，例如：选择标题，会给我们 HTML 元素，就是 DOM 上的对象
>     - 子对象也有自己的方法和属性，例如通过 addEventListener 去监听标题单击
>   - 属性
>     - 选择标题，选中后用 .style.color，设置为字符串 red 来改变该标题的颜色
>     - style 是子对象，在其中有所有 css 类型的属性
> - 一个 HTML 文件等同于一个 DOM 或 JS 中的文档对象

## JavaScript

> 
>
> **运行**
>
> 可以使用 node 直接运行，在 cmd 中使用命令 node js文件，这种方式运行的 js 文件中 [console.log](#Console) 输出将在 cmd 控制台中
>
> 

### 声明变量的方式

> **var**
>
> - JS中最原始定义变量方式
> - var是有函数作用域的变量声明，表示定义的变量，在该函数内处处有效
>   - 比如说在for循环内定义的一个 var 变量，实际上其在for循环以外也是可以访问的
> - 因为是函数全局作用域内可用，所以在人为声明前就已存在(*如果在函数第10行定义了个变量，其实在1行就能使用，并不会报错*)
> - var表示是可变变量类型
>   - var定义的变量在作用域内可改动，可以重新赋值，可以改变数据类型
>   - **可以任意改变变量会有潜在危险**
> - 没有使用的必要了，有泄漏的危险
>
> **let**
>
> - 和 var 很相似，但它是块作用域而非函数作用域，表示其只能作用在块中，一旦超出作用域，变量就无法使用了
>   - 比如说在for循环内定义的一个 let 变量，在其外面是不可被访问的
> - let 只能在声明后使用(*如果在函数第10行定义了个变量，只能在第11行之后使用*)
> - let 也是可变变量类型，同样可以改变变量的值，类型等等
> - 建议在循环中使用 let 来声明变量
>
> **const**
>
> - 和 let 类似，是块作用域变量
> - const 只能在声明后使用
> - const 修饰的变量表示为常量，只能在初始时设置一次，不能改变变量的值，类型等
> - 建议尽可能多用 const 变量类型，有助于减少bug的产生

### 字符串拼接

> **通过使用 + 运算符来进行字符串的拼接**
>
> ```javascript
> let str1 = "hello ";
> let str2 = "world!";
> console.log(str1 + str2);
> console.log(str1 + "Big " + str2);
> ```
>
> **数字和字符串的拼接**
>
> ```javascript
> let num1 = 1;
> let num2 = "1";
> // 数字和字符串拼接
> console.log(num1 + num2); // 11
> // 数字之间相加
> console.log(num1 + 1); // 2
> ```

### 模板字符串

> ES6中引入了模板字符串，让我们告别了使用大量'' 和 +来连接字符串了写法
>
> **描述**
>
> - 模板字符串使用反引号 (\` \`) 来代替普通字符串中的用双引号和单引号。
> - 模板字符串可以包含特定语法（ \`${expression}\` ）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来
> - 如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串
> - 该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。
> - 在模版字符串内使用反引号（`）时，需要在它前面加转义符（\）
>
> **使用模板字符串来实现字符串的拼接**
>
> ```javascript
> let str1 = "hello";
> let str2 = "world!";
> console.log(`${str1} ${str2}`);
> console.log(`${str1} Big ${str2}`);
> ```
>
> **使用模板字符串来实现数字和字符串的拼接**
>
> ```javascript
> let num1 = 1;
> let num2 = "1";
> console.log(`${num1}${num2}`);
> ```
>
> **模板字符串中使用表达式**
>
> ```javascript
> let bool1 = true;
> console.log(`1 + 1 is ${1 + 1}`); // 1 + 1 is 2
> console.log(`The opposite of true is ${!bool1}`); // The opposite of true is false
> ```

### 数据类型

> **JS是一门弱类型语言，这意味着相较于其他的编程语言，JS的类型系统并不丰富和健壮**
>
> 在JS中变量以伪动态方式定义，表示类型由赋值决定
>
> JS中只有一种数据类型，浮点型。在JS中整数和浮点数类型没有区别
>
> **JS中有一个特有的类型，NaN(非数 not a number)。JS中检测尝试转换为数字的东西，是否为有效数字，如果不是有效数字，则显示NaN**

#### null和undefined在JS中的区别

> **相同点**
>
> - if 判断语句中，两者都会被转换为false
>
> **不同点**
>
> - Number转换的值不同，Number(null)输出为0, Number(undefined)输出为NaN
> - null表示一个值被定义了，但是这个值是空值
>   - 作为函数的参数，表示函数的参数不是对象
>   - 作为对象原型链的终点 （Object.getPrototypeOf(Object.prototype)）
>   - 定义一个值为null是合理的，但定义为undefined不合理（var name = null）
> - undefined表示缺少值，即此处应该有值，但是还没有定义
>   - 变量被声明了还没有赋值，就为undefined
>   - 调用函数时应该提供的参数还没有提供，该参数就等于undefined
>   - 对象没有赋值的属性，该属性的值就等于undefined
>   - 函数没有返回值，默认返回undefined

#### typeof

> typeof运算符，用来检测一个变量的类型
>
> typeof是一个运算符，有2种使用方式：typeof(表达式)和typeof 变量名，第一种是对表达式做运算，第二种是对变量做运算
>
> typeof运算符的返回类型为字符串，值包括如下几种
>
> - undefined	--未定义的变量或值
> - boolean	--布尔类型的变量或值
> - string	--字符串类型的变量或值
> - number	--数字类型的变量或值
> - object	--对象类型的变量或值，或者null(这个是js历史遗留问题，将null作为object类型处理)
> - function	--函数类型的变量或值
>
> ```javascript
> console.log(typeof a);    //'undefined'
> console.log(typeof(true));  //'boolean'
> console.log(typeof '123');  //'string'
> console.log(typeof NaN);   //'number'
> 
> var obj = new String();
> console.log(typeof(obj));    //'object'
> 
> var  fn = function(){};
> console.log(typeof(fn));  //'function'
> ```

#### instanceof

> 用于确定某些内容是否从特定数据类型的构造函数中创造
>
> instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上
>
> ```javascript
> // 定义构造函数
> function C(){}
> function D(){}
> 
> var o = new C();
> 
> o instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototype
> o instanceof D; // false，因为 D.prototype 不在 o 的原型链上
> ```

#### 对JS中的变量重新赋值

> ```javascript
> let x = 'something';
> x = 1;
> x = 1 + 'hello';
> console.log(x); // '1hello'
> ```

#### \==和===之间的区别

> **在JS中，对于string,number等基础类型，\==和===是有区别的**
>
> - 不同类型间比较，\==之比较“转化成同一类型后的值”看“值”是否相等，===如果类型不同，其结果就是不等
> - 同类型比较，直接进行“值”比较，两者结果一样
>
> **对于Array,Object等高级类型，\==和===是没有区别的**
>
> **基础类型与高级类型，\==和===是有区别的**
>
> - 对于==，将高级转化为基础类型，进行“值”比较
> - 因为类型不同，===结果为false
>
> **==比较值是否相等，不同类型的值会发生隐式强制类型转换**
>
> ```javascript
> // 0 和 ' ' 发生隐式强制类型转换，空字符调用ToNumber转成0，0==0 返回true
> let x = 0 == '';
> ```
>
> **===比较值和类型是否相等，不同类型的值不会发生隐式强制类型转换**
>
> ```javascript
> // 0 和 ' ' 不发生隐式强制类型转换，0=='' 返回false
> let x = 0 === '';
> ```

### 数学运算

> **基础运算**
>
> ```javascript
> let num = 100;
> // 加法
> console.log(num1 + 25);
> // 减法
> console.log(num1 - 100);
> // 乘法
> console.log(num1 * 100);
> // 除法
> console.log(num1 / 1500);
> // 取余
> console.log(num1 % 1500);
> // 自加
> console.log(++num1);
> // 自减
> console.log(--num1);
> ```
>
> **高级运算**
>
> 如果需要使用更多的运算方法，使用 Math 对象
>
> ```javascript
> let num = 100;
> // 圆周率
> console.log(Math.PI);
> // num的平方根
> console.log(Math.sqrt(num1)); // 10
> // 返回 0（含）和 1（不含）之间的随机数
> console.log(Math.random());
> ```

### 数字和字符串类型转换

> **字符串转为数字**
>
> parseInt()
>
> ```javascript
> let num1 = '150';
> console.log(parseInt('100')); // 100
> console.log(parseInt(num1)); // 150
> console.log(parseInt('ABC')); // NaN
> console.log(parseInt('0xF')); // 15
> 
> console.log(parseInt('1 + 1')); // 1
> console.log(parseInt(`${1 + 1}`)); // 2
> ```
>
> parseFloat()
>
> ```javascript
> let flo1 = '1.50';
> console.log(parseInt('1.00')); // 1
> console.log(parseInt(flo1)); // 1.5
> console.log(parseInt('ABC')); // NaN
> ```
>
> **数字转为字符串**
>
> toString()
>
> ```javascript
> let num1 = 150;
> let flo1 = 1.50;
> console.log(num1.toString()); // '150'
> console.log(flo1.toString()); // '1.50'
> console.log((100).toString()); // '100'
> ```
>
> 

### 异常处理

> **概述**
>
> 异常是指代码执行过程中的中断，通常由错误引起
>
> 代码中有错误就会报错(如：使用了错误的语法)，异常就是代码运行中在何时何处出现错误
>
> 抛出异常，会告诉你一条代码哪里出错的信息
>
> JS可以抛出异常，或是开发者自己手动抛出

#### try--catch

> - 格式
>
>   ```javascript
>    try {
>       可能出现异常的代码;
>    } catch(变量名) {
>       异常的处理代码;
>   }
>   ```
>
> - 范例
>
>   ```javascript
>   try {
>       criticalCode();
>   } catch (ex) {
>       console.log("Got an error");
>       console.log(ex.message);
>   }
>   ```
>
> - 执行流程：
>
>   - 程序从try里面的代码开始执行
>   - 出现异常，会自动生成一个异常类对象，该异常对象将被提交给Java运行时系统
>   - 当JS运行时系统接收到异常对象时，会到catch中去找匹配的异常类，找到后进行异常的处理
>   - 执行完毕之后，程序还可以继续往下执行

#### finally

> <span style="color: red;">finally语句块总是会被执行</span>。它主要用于回收在try块里打开的物理资源(如数据库连接、网络连接和磁盘文件)。只有finally块执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止
>
> ```javascript
> try {
>     criticalCode();
> } catch (ex) {
>     console.log("Got an error");
>     console.log(ex.message);
> } finally {
>     console.log("continue");
> }
> ```
>
> **至少有两种情况下finally语句是不会被执行**
>
> - *try语句没有被执行到，如在try语句之前就返回了，这样finally语句就不会执行，这也说明了finally语句被执行的必要而非充分条件是：相应的try语句一定被执行到*
> - *在try块中有System.exit(0);这样的语句，System.exit(0);是终止Java虚拟机JVM的，连JVM都停止了，所有都结束了，当然finally语句也不会被执行到*
>
> **finally语句是在try的return语句执行之后，return返回之前执行**

#### 自定义异常

> **用于开发者手动抛出自定义异常**
>
> - 格式：
>
>   ```javascript
>   throw 抛出异常的内容; 
>   ```
>
> - 范例：
>
>   ```javascript
>   throw "myException";
>   
>   function criticalCode() {
>       throw true;
>   }
>   ```
>
> - 使用：
>
>   ```javascript
>   function criticalCode() {
>       throw "myException";
>   }
>   
>   try {
>       criticalCode();
>   } catch (ex) {
>       console.log(ex.message); // "myException"
>   }
>   ```

### Date对象

> **使用JS处理日期和时间都围绕一个对象，就是Date对象**
>
> 这个Date对象，实际包含日期和时间
>
> JS内部的时间，是存储自1970.01.01以来的毫秒数(*时间戳*)

#### 创建Date对象

> *注意：node输出的UTC时间，浏览器输出的本地时间。如果使用node直接运行js，需要进行时间转换*
>
> **时间格式转换**
>
> ```javascript
> // 为Date原型添加如下的方法
> Date.prototype.format = function (fmt) {
>     const o = {
>         "M+": this.getMonth() + 1, //月份
>         "d+": this.getDate(), //日
>         "h+": this.getHours(), //小时
>         "m+": this.getMinutes(), //分
>         "s+": this.getSeconds(), //秒
>         "q+": Math.floor((this.getMonth() + 3) / 3), //季度
>         S: this.getMilliseconds(), //毫秒
>     };
>     if (/(y+)/.test(fmt)) {
>         fmt = fmt.replace(
>             RegExp.$1,
>             (this.getFullYear() + "").substr(4 - RegExp.$1.length)
>         );
>     }
>     for (const k in o) {
>         if (new RegExp("(" + k + ")").test(fmt)) {
>             fmt = fmt.replace(
>                 RegExp.$1,
>                 RegExp.$1.length == 1
>                     ? o[k]
>                     : ("00" + o[k]).substr(("" + o[k]).length)
>             );
>         }
>     }
>     return fmt;
> };
> // 转换为"年月日 时分秒"格式
> const time1 = new Date().format("yyyy-MM-dd hh:mm:ss");
> console.log(time1);
> // 获取带毫秒的格式
> const now = new Date().format("hh:mm:ss.S");
> console.log(now);
> // 转换成"年月日"的格式
> const time2 = new Date().format("yyyy-MM-dd");
> console.log(time2);
> ```
>
> **获取当前时间**：new Date();
>
> ```javascript
> const now = new Date();
> ```
>
> **设置指定的时间**：new Date(year, month, day, hours, minutes, seconds, milliseconds);
>
> *注意：Date对象中，月份从0开始计算，所以需要+1才是正确的月份。例如，在设置月份时，如果想设置4月，则输入3*
>
> ```javascript
> const randomDate = new Date(2015, 3, 12, 6, 25, 58);
> console.log(randomDate);
> ```
>
> **设置指定的年月日**：new Date(year, month, day);
>
> ```javascript
> const win95Launch = new Date(1995, 7, 24);
> console.log(win95Launch);
> ```
>
> **单独设置日期时间**
>
> ```javascript
> const now = new Date();
> now.setFullYear(2021);
> now.setMonth(9);
> now.setDate(6);
> console.log(now.format("yyyy-MM-dd")); // 2021-10-06
> ```
>
> |     **方法**      | **描述**                                            |
> | :---------------: | --------------------------------------------------- |
> |     setDate()     | 设置 Date 对象中月的某一天                          |
> |   setFullYear()   | 设置日期对象的年份                                  |
> |    setHours()     | 设置日期对象的小时                                  |
> | setMilliseconds() | 设置日期对象的毫秒数                                |
> |   setMinutes()    | 设置日期对象的分钟数                                |
> |    setMonth()     | 设置日期对象的月份                                  |
> |   setSeconds()    | 设置日期对象的秒数                                  |
> |     setTime()     | 将日期设置为 1970 年 1 月 1 日之后/之前的指定毫秒数 |
>
> **获取需要的日期时间**
>
> ```javascript
> const now = new Date();
> now.setFullYear(2021);
> now.setMonth(9);
> now.setDate(6);
> // 获取时间
> console.log(now.getFullYear()); // 2021
> console.log(now.getMonth()); // 9 实际月份要+1
> console.log(now.getDay()); // 3
> console.log(now.getDate()); // 6
> ```
>
> |     **方法**      | **描述**                                           |
> | :---------------: | -------------------------------------------------- |
> |     getDate()     | 返回月中的第几天（从 1 到 31）                     |
> |     getDay()      | 返回星期几（0-6）                                  |
> |   getFullYear()   | 返回年份                                           |
> |    getHours()     | 返回小时（从 0-23）                                |
> | getMilliseconds() | 返回毫秒（0-999）                                  |
> |   getMinutes()    | 返回分钟（从 0-59）                                |
> |    getMonth()     | 返回月份（从 0-11）                                |
> |   getSeconds()    | 返回秒数（从 0-59）                                |
> |     getTime()     | 返回自 1970 年 1 月 1 日午夜以来与指定日期的毫秒数 |

### JS数组

> **概述**
>
> 数组是聚集值的列表
>
> JS中，一个数组可以存储很多不同数据类型的值
>
> 当一个值添加进数组，会分配到一个指定数字index(索引)。这是一个独一无二的数字，可以在任何时候用来引用，和访问数组中的值
>
> 可以通过数组中的 length 属性来获取当前数组的长度
>
> **创建数组的方式**
>
> - 通过[]创建
>
>   ```javascript
>   let arr1 = [];
>   console.log(arr1.length); // 0
>   ```
>
> - 通过数组对象创建
>
>   - 使用数组对象创建必须要设定长度
>
>   ```javascript
>   let arrayLength = 5;
>   let arr2 = Array(arrayLength);
>   console.log(arr2.length); // 5
>   ```
>
> **向数组中添加数据**
>
> - 在创建时向数组中添加数据
>
>   ```javascript
>   let arr1 = ["A", true, 2];
>   console.log(arr1[0]); // "A"
>   console.log(arr1[1]); // true
>   ```
>
> - 在创建后向数组中添加数据
>
>   - 通过数组的索引(index)来进行添加，index始终从0开始
>
>   ```javascript
>   let arrayLength = 2;
>   let arr2 = Array(arrayLength);
>   arr2[0] = "Value at index 0";
>   console.log(arr2[0]); // "Value at index 0"
>   console.log(arr2[1]); // undefined
>   ```
>
> **数组的属性length**
>
> - 通过数组对象创建的数组，length等于创建时设定的长度，即使数组中并没有数据
>
>   ```javascript
>   let arrayLength = 5;
>   let arr = Array(arrayLength);
>   console.log(arr.length); // 5
>   ```
>
> - 通过[]创建的数组，如果创建时没有添加数据，length等于0。直到后面通过索引添加数据，length等于索引的值+1
>
>   ```javascript
>   let arr = []
>   console.log(arr.length); // 0
>   arr[1] = 1;
>   arr[3] = 2;
>   console.log(arr.length); // 4
>   ```
>
> **数组中常用的添加和移除方法**
>
> | **方法**  | **描述**               |
> | :-------: | ---------------------- |
> |  push()   | 在数组末尾中添加新元素 |
> |   pop()   | 移除最后一个数组元素   |
> |  shift()  | 移除第一个数组元素     |
> | unshift() | 在数组起始中添加新元素 |
> | concat()  | 连接两个或多个数组     |
>
> ```javascript
> let arr1 = ["A", true, 2];
> // push pop
> console.log(arr1.push("new value")); // 4
> console.log(arr1); // [ 'A', true, 2, 'new value' ]
> console.log(arr1.pop()); // new value
> console.log(arr1); // [ 'A', true, 2 ]
> // unshift shift
> console.log(arr1.unshift("new value")); // 4
> console.log(arr1); // [ 'new value', 'A', true, 2 ]
> console.log(arr1.shift()); // new value
> console.log(arr1); // [ 'A', true, 2 ]
> ```
>
> *concat*
>
> ```javascript
> let arr1 = ["A", true, 2];
> let arr2 = ["B", false, 3];
> let newArr = arr1.concat(arr2);
> let newArr2 = arr2.concat([1, 2, 3]);
> console.log(newArr); // [ 'A', true, 2, 'B', false, 3 ]
> console.log(newArr2); // [ 'B', false, 3, 1, 2, 3 ]
> ```
>
> **遍历数组**
>
> - 使用for循环遍历数组
>
>   ```javascript
>   let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
>   for (let i = 0; i < arr.length; i++) {
>       console.log(arr[i]);
>   }
>   ```
>
> - 使用for...in循环遍历数组
>
>   ```javascript
>   let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
>   for (let i in arr) {
>       console.log(arr[i]);
>   }
>   ```
>
> **通过[]创建的空数组，之后使用index添加部分值，使用两种方法遍历数组得出的结果不同**
>
> ```javascript
> let arr = [];
> arr[1] = 1;
> arr[3] = 2;
> ```
>
> - 通过for循环遍历
>
>   ```javascript
>   for (let i = 0; i < arr.length; i++) 
>       console.log(arr[i]);
>   /**
>    * 运行结果
>    * undefined
>    * 1
>    * undefined
>    * 2
>    */
>   ```
>
> - 通过for...in循环遍历
>
>   ```javascript
>   for (let i in arr) 
>       console.log(arr[i]);
>   /**
>    * 运行结果
>    * 1
>    * 2
>    */
>   ```

### JS中输出的部分方式

> <span name="Console">**console.log**</span>
>
> console.log() 方法用于在控制台输出信息。
>
> 该方法对于开发过程进行测试很有帮助。
>
> **提示:** 在测试该方法的过程中，控制台需要可见 (浏览器按下 F12 打开控制台)
>
> ```javascript
> console.log("Hello Runoob!");
> ```
>
> **alert**
>
> alert() 方法用于显示带有一条指定消息和一个 OK 按钮的警告框
>
> ```javascript
> alert('message');
> ```
>
> **document.write**
>
> write() 方法可向文档写入 HTML 表达式或 JavaScript 代码。
>
> 可列出多个参数(exp1,exp2,exp3,...) ，它们将按顺序被追加到文档中。
>
> ```javascript
> document.write("Hello World!");
> ```
>
> 

### JS函数

#### 普通函数

> - <span style='color: purple; text-decoration:underline;'>无参数</span>：
>
>   格式：
>
>   ```javascript
>   function 函数名(){
>    	// 函数体
>   }
>   ```
>
>   范例：
>
>   ```javascript
>   function isEvenNumber(){
>   	// 函数体
>   }
>   ```
>
> - <span style='color: purple; text-decoration:underline;'>有参数</span>：
>
>   - 格式：
>
>     ```javascript
>     function 函数名(变量名1, 变量名2, ...){
>      	// 函数体
>     }
>     ```
>
>   - 范例：
>
>     ```javascript
>     function isEvenNumber(num1, num2, ...){
>      	// 函数体
>     }
>     ```
>
>    - 函数定义时，多个参数之间使用逗号(，)分隔
>

#### 匿名函数

> 

#### 箭头函数

> 

### JSON

> 





## TypeScript

> **简介**
>
> TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准。
>
> TypeScript 由微软开发的自由和开源的编程语言。
>
> TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。
>
> **安装**
>
> node安装：**npm install -g typescript**

### TypeScript静态类型

## ES6

### ES6模块化规范中定义：

> -     每个js文件都是一个独立的模块
> -     导入其他模块成员使用<span style="color: red;">import</span>关键字
> -     向外共享模块成员使用<span style="color: red;">export</span>关键字
>

### 在node.js中体验ES6模块化

> node.js中默认仅支持CommonJS模块化规范，若想基于node.js体验ES6的模块化语法，可以按照如下两个步骤进行配置
>
> 1. 确保安装了v14.15.1或更高版本的node.js
> 2. 在package.json的根节点中添加 "type":"module"节点

### ES6模块化的默认导出和导入

> **默认导出**：
>
> 默认导出的语法：<span style="color: red;">export default</span> <span style="color: #329BDC;">默认导出成员</span>
>
> ```javascript
> len n2 = 10 // 定义模块私有成员 n1
> len n2 = 20 // 定义模块私有成员 n2（外界访问不到 n2，因为它没有被共享出去）
> funciton show(){} // 定义模块私有方法 show
> 
> export default { // 使用 export default 默认导出语法，向外共享 n1 和 show 两个成员
>  n1,
>  show
> }
> ```
>
> <span style='color: red;'>默认导出的注意事项：</span>每个模块中，<span style='color: #329BDC; text-decoration:underline;'>只允许使用唯一的一次</span> export default，否则会报错！
>
> **默认导入：**
>
> 默认导入的语法：<span style="color: red;">import</span> <span style="color: #329BDC;">接受名称</span> <span style="color: red;">from</span> '<span style="color: #329BDC;">模块化标识符</span>'
>
> ```javascript
>// 从 01_m1.js 模块中导入 export default 向外共享的成员
> import m1 from './01_m1.js'
> 
> // 打印输出的结果为：
> //{ n1: 10, show: [Function: show] }
> console.log(m1)
> ```
> 
> <span style='color: red;'>默认导入的注意事项：</span>默认导入时的接收名称可以任意名称，<span style="color: #329BDC;">只要是合法的成员名称即可</span>

### ES6模块化的按需导出和导入

> **按需导出：**
>
> 按需导出的语法：<span style="color: red;">export</span> <span style="color: #329BDC;">按需导出的成员</span>
>
> ```javascript
> // 当前模块为03_m2.js
> 
> // 向外按需导出变量 s1
> export let s1 = 'aaa'
> // 向外按需导出变量 s2
> export let s2 = 'ccc'
> // 向外按需导出方法 say
> export function say(){}
> ```
>
> **按需导入：**
>
> 按需导入的语法：<span style="color: red;">import</span> {<span style="color: #329BDC;">s1</span>} <span style="color: red;">from</span>> '模块标识符'
>
> ```javascript
> // 导入模块成员
> import { s1, s2, say } from './03_m2.js'
> 
> console.log(s1) // 打印输出 aaa
> console.log(s2) // 打印输出 ccc
> console.log(sa) // 打印输出 [Function: say]
> ```
>
> <span style='color: red;'>按需导出与按需导入的注意事项：</span>
>
> - 每个模块中可以使用<span style="color: red;">多次</span>按需导出
>
> - 按需<span style="color: red;">导入的成员名称</span>必须和<span style="color: red;">按需导出的名称</span>保持一致
>
> - 按需导入时，可以使用<span style="color: red;"> as 关键字</span>>进行重命名
>
> - ```javascript
>   // 导入模块成员
>   import { s1, s2 as str2, say } from './03_m2.js'
>         
>   console.log(s1) // 打印输出 aaa
>   console.log(str2) // 打印输出 ccc
>   console.log(say) // 打印输出 [Function: say]
>   ```
>
> - 按需导入可以和默认导入一起使用

