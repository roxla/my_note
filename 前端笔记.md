## JavaScript

> 
>
> **运行**
>
> 可以使用 node 直接运行，在 cmd 中使用命令 node js文件，这种方式运行的 js 文件中 [console.log](#Console) 输出将在 cmd 控制台中
>
> 

### 声明变量的方式

> **var**
>
> - JS中最原始定义变量方式
> - var是有函数作用域的变量声明，表示定义的变量，在该函数内处处有效
>   - 比如说在for循环内定义的一个 var 变量，实际上其在for循环以外也是可以访问的
> - 因为是函数全局作用域内可用，所以在人为声明前就已存在(*如果在函数第10行定义了个变量，其实在1行就能使用，并不会报错*)
> - var表示是可变变量类型
>   - var定义的变量在作用域内可改动，可以重新赋值，可以改变数据类型
>   - **可以任意改变变量会有潜在危险**
> - 没有使用的必要了，有泄漏的危险
>
> **let**
>
> - 和 var 很相似，但它是块作用域而非函数作用域，表示其只能作用在块中，一旦超出作用域，变量就无法使用了
>   - 比如说在for循环内定义的一个 let 变量，在其外面是不可被访问的
> - let 只能在声明后使用(*如果在函数第10行定义了个变量，只能在第11行之后使用*)
> - let 也是可变变量类型，同样可以改变变量的值，类型等等
> - 建议在循环中使用 let 来声明变量
>
> **const**
>
> - 和 let 类似，是块作用域变量
> - const 只能在声明后使用
> - const 修饰的变量表示为常量，只能在初始时设置一次，不能改变变量的值，类型等
> - 建议尽可能多用 const 变量类型，有助于减少bug的产生

### 字符串拼接

> **通过使用 + 运算符来进行字符串的拼接**
>
> ```javascript
> let str1 = "hello ";
> let str2 = "world!";
> console.log(str1 + str2);
> console.log(str1 + "Big " + str2);
> ```
>
> **数字和字符串的拼接**
>
> ```javascript
> let num1 = 1;
> let num2 = "1";
> // 数字和字符串拼接
> console.log(num1 + num2); // 11
> // 数字之间相加
> console.log(num1 + 1); // 2
> ```

### 模板字符串

> ES6中引入了模板字符串，让我们告别了使用大量'' 和 +来连接字符串了写法
>
> **描述**
>
> - 模板字符串使用反引号 (\` \`) 来代替普通字符串中的用双引号和单引号。
> - 模板字符串可以包含特定语法（ \`${expression}\` ）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来
> - 如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串
> - 该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。
> - 在模版字符串内使用反引号（`）时，需要在它前面加转义符（\）
>
> **使用模板字符串来实现字符串的拼接**
>
> ```javascript
> let str1 = "hello";
> let str2 = "world!";
> console.log(`${str1} ${str2}`);
> console.log(`${str1} Big ${str2}`);
> ```
>
> **使用模板字符串来实现数字和字符串的拼接**
>
> ```javascript
> let num1 = 1;
> let num2 = "1";
> console.log(`${num1}${num2}`);
> ```
>
> **模板字符串中使用表达式**
>
> ```javascript
> let bool1 = true;
> console.log(`1 + 1 is ${1 + 1}`); // 1 + 1 is 2
> console.log(`The opposite of true is ${!bool1}`); // The opposite of true is false
> ```

### 数据类型

> **JS是一门弱类型语言，这意味着相较于其他的编程语言，JS的类型系统并不丰富和健壮**
>
> 在JS中变量以伪动态方式定义，表示类型由赋值决定
>
> JS中只有一种数据类型，浮点型。在JS中整数和浮点数类型没有区别
>
> **JS中有一个特有的类型，NaN(非数 not a number)。JS中检测尝试转换为数字的东西，是否为有效数字，如果不是有效数字，则显示NaN**

#### null和undefined在JS中的区别

> **相同点**
>
> - if 判断语句中，两者都会被转换为false
>
> **不同点**
>
> - Number转换的值不同，Number(null)输出为0, Number(undefined)输出为NaN
> - null表示一个值被定义了，但是这个值是空值
>   - 作为函数的参数，表示函数的参数不是对象
>   - 作为对象原型链的终点 （Object.getPrototypeOf(Object.prototype)）
>   - 定义一个值为null是合理的，但定义为undefined不合理（var name = null）
> - undefined表示缺少值，即此处应该有值，但是还没有定义
>   - 变量被声明了还没有赋值，就为undefined
>   - 调用函数时应该提供的参数还没有提供，该参数就等于undefined
>   - 对象没有赋值的属性，该属性的值就等于undefined
>   - 函数没有返回值，默认返回undefined

#### typeof

> typeof运算符，用来检测一个变量的类型
>
> typeof是一个运算符，有2种使用方式：typeof(表达式)和typeof 变量名，第一种是对表达式做运算，第二种是对变量做运算
>
> typeof运算符的返回类型为字符串，值包括如下几种
>
> - undefined	--未定义的变量或值
> - boolean	--布尔类型的变量或值
> - string	--字符串类型的变量或值
> - number	--数字类型的变量或值
> - object	--对象类型的变量或值，或者null(这个是js历史遗留问题，将null作为object类型处理)
> - function	--函数类型的变量或值
>
> ```javascript
> console.log(typeof a);    //'undefined'
> console.log(typeof(true));  //'boolean'
> console.log(typeof '123');  //'string'
> console.log(typeof NaN);   //'number'
> 
> var obj = new String();
> console.log(typeof(obj));    //'object'
> 
> var  fn = function(){};
> console.log(typeof(fn));  //'function'
> ```

#### instanceof

> 用于确定某些内容是否从特定数据类型的构造函数中创造
>
> instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上
>
> ```javascript
> // 定义构造函数
> function C(){}
> function D(){}
> 
> var o = new C();
> 
> o instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototype
> o instanceof D; // false，因为 D.prototype 不在 o 的原型链上
> ```

#### 对JS中的变量重新赋值

> ```javascript
> let x = 'something';
> x = 1;
> x = 1 + 'hello';
> console.log(x); // '1hello'
> ```

#### \==和===之间的区别

> **在JS中，对于string,number等基础类型，\==和===是有区别的**
>
> - 不同类型间比较，\==之比较“转化成同一类型后的值”看“值”是否相等，===如果类型不同，其结果就是不等
> - 同类型比较，直接进行“值”比较，两者结果一样
>
> **对于Array,Object等高级类型，\==和===是没有区别的**
>
> **基础类型与高级类型，\==和===是有区别的**
>
> - 对于==，将高级转化为基础类型，进行“值”比较
> - 因为类型不同，===结果为false
>
> **==比较值是否相等，不同类型的值会发生隐式强制类型转换**
>
> ```javascript
> // 0 和 ' ' 发生隐式强制类型转换，空字符调用ToNumber转成0，0==0 返回true
> let x = 0 == '';
> ```
>
> **===比较值和类型是否相等，不同类型的值不会发生隐式强制类型转换**
>
> ```javascript
> // 0 和 ' ' 不发生隐式强制类型转换，0=='' 返回false
> let x = 0 === '';
> ```

### 数学运算

> **基础运算**
>
> ```javascript
> let num = 100;
> // 加法
> console.log(num1 + 25);
> // 减法
> console.log(num1 - 100);
> // 乘法
> console.log(num1 * 100);
> // 除法
> console.log(num1 / 1500);
> // 取余
> console.log(num1 % 1500);
> // 自加
> console.log(++num1);
> // 自减
> console.log(--num1);
> ```
>
> **高级运算**
>
> 如果需要使用更多的运算方法，使用 Math 对象
>
> ```javascript
> let num = 100;
> // 圆周率
> console.log(Math.PI);
> // num的平方根
> console.log(Math.sqrt(num1)); // 10
> // 返回 0（含）和 1（不含）之间的随机数
> console.log(Math.random());
> ```

### 数字和字符串类型转换

> **字符串转为数字**
>
> parseInt()
>
> ```javascript
> let num1 = '150';
> console.log(parseInt('100')); // 100
> console.log(parseInt(num1)); // 150
> console.log(parseInt('ABC')); // NaN
> console.log(parseInt('0xF')); // 15
> 
> console.log(parseInt('1 + 1')); // 1
> console.log(parseInt(`${1 + 1}`)); // 2
> ```
>
> parseFloat()
>
> ```javascript
> let flo1 = '1.50';
> console.log(parseInt('1.00')); // 1
> console.log(parseInt(flo1)); // 1.5
> console.log(parseInt('ABC')); // NaN
> ```
>
> **数字转为字符串**
>
> toString()
>
> ```javascript
> let num1 = 150;
> let flo1 = 1.50;
> console.log(num1.toString()); // '150'
> console.log(flo1.toString()); // '1.50'
> console.log((100).toString()); // '100'
> ```
>
> 

### 异常处理

> **概述**
>
> 异常是指代码执行过程中的中断，通常由错误引起
>
> 代码中有错误就会报错(如：使用了错误的语法)，异常就是代码运行中在何时何处出现错误
>
> 抛出异常，会告诉你一条代码哪里出错的信息
>
> JS可以抛出异常，或是开发者自己手动抛出

#### try--catch

> - 格式
>
>   ```javascript
>    try {
>       可能出现异常的代码;
>    } catch(变量名) {
>       异常的处理代码;
>   }
>   ```
>
> - 范例
>
>   ```javascript
>   try {
>       criticalCode();
>   } catch (ex) {
>       console.log("Got an error");
>       console.log(ex.message);
>   }
>   ```
>
> - 执行流程：
>
>   - 程序从try里面的代码开始执行
>   - 出现异常，会自动生成一个异常类对象，该异常对象将被提交给Java运行时系统
>   - 当JS运行时系统接收到异常对象时，会到catch中去找匹配的异常类，找到后进行异常的处理
>   - 执行完毕之后，程序还可以继续往下执行

#### finally

> <span style="color: red;">finally语句块总是会被执行</span>。它主要用于回收在try块里打开的物理资源(如数据库连接、网络连接和磁盘文件)。只有finally块执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止
>
> ```javascript
> try {
>     criticalCode();
> } catch (ex) {
>     console.log("Got an error");
>     console.log(ex.message);
> } finally {
>     console.log("continue");
> }
> ```
>
> **至少有两种情况下finally语句是不会被执行**
>
> - *try语句没有被执行到，如在try语句之前就返回了，这样finally语句就不会执行，这也说明了finally语句被执行的必要而非充分条件是：相应的try语句一定被执行到*
> - *在try块中有System.exit(0);这样的语句，System.exit(0);是终止Java虚拟机JVM的，连JVM都停止了，所有都结束了，当然finally语句也不会被执行到*
>
> **finally语句是在try的return语句执行之后，return返回之前执行**

#### 自定义异常

> **用于开发者手动抛出自定义异常**
>
> - 格式：
>
>   ```javascript
>   throw 抛出异常的内容; 
>   ```
>
> - 范例：
>
>   ```javascript
>   throw "myException";
>   
>   function criticalCode() {
>       throw true;
>   }
>   ```
>
> - 使用：
>
>   ```javascript
>   function criticalCode() {
>       throw "myException";
>   }
>             
>   try {
>       criticalCode();
>   } catch (ex) {
>       console.log(ex.message); // "myException"
>   }
>   ```

### JS数组

> **概述**
>
> 数组是聚集值的列表
>
> JS中，一个数组可以存储很多不同数据类型的值
>
> 当一个值添加进数组，会分配到一个指定数字index(索引)。这是一个独一无二的数字，可以在任何时候用来引用，和访问数组中的值
>
> 可以通过数组中的 length 属性来获取当前数组的长度
>
> **创建数组的方式**
>
> - 通过[]创建
>
>   ```javascript
>   let arr1 = [];
>   console.log(arr1.length); // 0
>   ```
>
> - 通过数组对象创建
>
>   - 使用数组对象创建必须要设定长度
>
>   ```javascript
>   let arrayLength = 5;
>   let arr2 = Array(arrayLength);
>   console.log(arr2.length); // 5
>   ```
>
> **向数组中添加数据**
>
> - 在创建时向数组中添加数据
>
>   ```javascript
>   let arr1 = ["A", true, 2];
>   console.log(arr1[0]); // "A"
>   console.log(arr1[1]); // true
>   ```
>
> - 在创建后向数组中添加数据
>
>   - 通过数组的索引(index)来进行添加，index始终从0开始
>
>   ```javascript
>   let arrayLength = 2;
>   let arr2 = Array(arrayLength);
>   arr2[0] = "Value at index 0";
>   console.log(arr2[0]); // "Value at index 0"
>   console.log(arr2[1]); // undefined
>   ```
>
> **数组的属性length**
>
> - 通过数组对象创建的数组，length等于创建时设定的长度，即使数组中并没有数据
>
>   ```javascript
>   let arrayLength = 5;
>   let arr = Array(arrayLength);
>   console.log(arr.length); // 5
>   ```
>
> - 通过[]创建的数组，如果创建时没有添加数据，length等于0。直到后面通过索引添加数据，length等于索引的值+1
>
>   ```javascript
>   let arr = []
>   console.log(arr.length); // 0
>   arr[1] = 1;
>   arr[3] = 2;
>   console.log(arr.length); // 4
>   ```
>
> **数组中常用的添加和移除方法**
>
> | **方法**  | **描述**               |
> | :-------: | ---------------------- |
> |  push()   | 在数组末尾中添加新元素 |
> |   pop()   | 移除最后一个数组元素   |
> |  shift()  | 移除第一个数组元素     |
> | unshift() | 在数组起始中添加新元素 |
> | concat()  | 连接两个或多个数组     |
>
> ```javascript
> let arr1 = ["A", true, 2];
> // push pop
> console.log(arr1.push("new value")); // 4
> console.log(arr1); // [ 'A', true, 2, 'new value' ]
> console.log(arr1.pop()); // new value
> console.log(arr1); // [ 'A', true, 2 ]
> // unshift shift
> console.log(arr1.unshift("new value")); // 4
> console.log(arr1); // [ 'new value', 'A', true, 2 ]
> console.log(arr1.shift()); // new value
> console.log(arr1); // [ 'A', true, 2 ]
> ```
>
> *concat*
>
> ```javascript
> let arr1 = ["A", true, 2];
> let arr2 = ["B", false, 3];
> let newArr = arr1.concat(arr2);
> let newArr2 = arr2.concat([1, 2, 3]);
> console.log(newArr); // [ 'A', true, 2, 'B', false, 3 ]
> console.log(newArr2); // [ 'B', false, 3, 1, 2, 3 ]
> ```
>
> **遍历数组**
>
> - 使用for循环遍历数组
>
>   ```javascript
>   let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
>   for (let i = 0; i < arr.length; i++) {
>       console.log(arr[i]);
>   }
>   ```
>
> - 使用for...in循环遍历数组
>
>   ```javascript
>   let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
>   for (let i in arr) {
>       console.log(arr[i]);
>   }
>   ```
>
> **通过[]创建的空数组，之后使用index添加部分值，使用两种方法遍历数组得出的结果不同**
>
> ```javascript
> let arr = [];
> arr[1] = 1;
> arr[3] = 2;
> ```
>
> - 通过for循环遍历
>
>   ```javascript
>   for (let i = 0; i < arr.length; i++) 
>       console.log(arr[i]);
>   /**
>    * 运行结果
>    * undefined
>    * 1
>    * undefined
>    * 2
>    */
>   ```
>
> - 通过for...in循环遍历
>
>   ```javascript
>   for (let i in arr) 
>       console.log(arr[i]);
>   /**
>    * 运行结果
>    * 1
>    * 2
>    */
>   ```

### JS中输出的部分方式

> <span name="Console">**console.log**</span>
>
> console.log() 方法用于在控制台输出信息。
>
> 该方法对于开发过程进行测试很有帮助。
>
> **提示:** 在测试该方法的过程中，控制台需要可见 (浏览器按下 F12 打开控制台)
>
> ```javascript
> console.log("Hello Runoob!");
> ```
>
> **alert**
>
> alert() 方法用于显示带有一条指定消息和一个 OK 按钮的警告框
>
> ```javascript
> alert('message');
> ```
>
> **document.write**
>
> write() 方法可向文档写入 HTML 表达式或 JavaScript 代码。
>
> 可列出多个参数(exp1,exp2,exp3,...) ，它们将按顺序被追加到文档中。
>
> ```javascript
> document.write("Hello World!");
> ```
>
> 

### JS函数

#### 普通函数

> - <span style='color: purple; text-decoration:underline;'>无参数</span>：
>
>   格式：
>
>   ```javascript
>   function 函数名(){
>    	// 函数体
>   }
>   ```
>
>   范例：
>
>   ```javascript
>   function isEvenNumber(){
>   	// 函数体
>   }
>   ```
>
> - <span style='color: purple; text-decoration:underline;'>有参数</span>：
>
>   - 格式：
>
>     ```javascript
>     function 函数名(变量名1, 变量名2, ...){
>      	// 函数体
>     }
>     ```
>
>   - 范例：
>
>     ```javascript
>     function isEvenNumber(num1, num2, ...){
>      	// 函数体
>     }
>     ```
>
>    - 函数定义时，多个参数之间使用逗号(，)分隔

#### this对象

> 

#### 匿名函数

> 

#### 箭头函数

> **概述**
>
> 箭头函数省去了 function 关键字，采用箭头 => 来定义函数。函数的参数放在 => 前面的括号中，函数体跟在 => 后的花括号中
>
> **关于箭头函数的参数**
>
> - 如果箭头函数没有参数，直接写一个空括号即可
> - 如果箭头函数的参数只有一个，也可以省去包裹参数的括号
> - 如果箭头函数有多个参数，将参数依次用逗号(,)分隔，包裹在括号中即可
>
> **箭头函数有个隐式返回语句，在只有单行语句的情况下，不用return就使其发生以及完成那条语句所要执行的操作**
>
> ```javascript
> // 箭头函数实现加法
> const add = (a, b) => a + b;
> console.log(add(1, 2)); // 3
> ```
>
> **箭头函数的多行语句**
>
> - 如果在多行语句的箭头函数中不使用 return ，则返回 undefined。因为不知道函数在哪里结束
>
> ```javascript
> // 箭头函数实现减法
> const  subtract = (a, b) => {
>     const result = a - b;
>     return result;
> };
> console.log(subtract(2, 1)); // 1
> ```
>
> *注意*：
>
> - 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象，箭头函数继承而来的 this 指向永远不变
> - 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误
> - 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 Rest 参数代替
> - 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数

### JSON

> **概述**
>
> JSON(JavaScript Object Notation, JS 对象简谱) 是一种**轻量级的数据交换格式**。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率
>
> **格式**
>
> JSON有两种表示结构，对象和数组
>
> - 对象结构以”{”大括号开始，以”}”大括号结束。中间部分由0或多个以”，”分隔的”key(关键字)/value(值)”对构成，关键字和值之间以”：”分隔，语法结构如代码
>
>   ```json
>   {
>       key1:value1,
>       key2:value2
>   }
>   ```
>
>   - 其中 key 是字符串，而 value 可以是字符串，数值，true，false，null，对象或数组
>
> - 数组结构以”[”开始，”]”结束。中间由0或多个以”，”分隔的值列表组成，语法结构如代码
>
>   ```json
>   [
>       {"key1":"value1","key2":"value2","key3":"value3","key3":"value3"},
>       {"key1":"value1","key2":"value2","key3":"value3","key3":"value3"},
>       {"key1":"value1","key2":"value2","key3":"value3","key3":"value3"}
>   ]
>   ```
>
> **JSON字符串和JSON对象的区别**
>
> JSON字符串：指的是符合 json 格式要求的js字符串。
>
> ```javascript
> let jsonStr = "{StudentID:'100',Name:'tmac',Hometown:'usa'}";
> ```
>
> JSON对象：指符合json格式要求的js对象。
>
> ```javascript
> let jsonObj = { StudentID: "100", Name: "tmac", Hometown: "usa" };
> ```
>
> **JS中使用JSON**
>
> JSON是JS的一个子集，所以可以在JS中轻松地读，写JSON。读和写JSON都有两种方法，分别是利用”.”操作符和“[key]”的方式

### DOM

####　什么是DOM

> - 通过 JS 改动 HTML 方式就是用 DOM
> - DOM 其实和 HTML 完全相同，总是和页面的 HTML 相同
> - 如果修改 DOM 上任何东西 HTML 就会自动更新，如果添加新的 HTML，DOM也会跟着改变
> - DOM内包含有
>   - 方法
>     - 方法是附属于 document 对象的函数，可以执行像：允许我们选择指定的 HTML 元素，例如：页面的标题
>   - 对象
>     - 通过 document 对象，子对象有更多的对象，例如：选择标题，会给我们 HTML 元素，就是 DOM 上的对象
>     - 子对象也有自己的方法和属性，例如通过 addEventListener 去监听标题单击
>   - 属性
>     - 选择标题，选中后用 .style.color，设置为字符串 red 来改变该标题的颜色
>     - style 是子对象，在其中有所有 css 类型的属性
> - 一个 HTML 文件等同于一个 DOM 或 JS 中的文档对象

#### JS操作DOM

> **获取html元素**
>
> |                    方法                    | 说明                                               |
> | :----------------------------------------: | -------------------------------------------------- |
> |        document.getElementById(id)         | 通过id属性的值获取对应的html元素(html元素的id唯一) |
> | document.getElementsByClassName(className) | 通过class属性的值获取对应的html元素数组            |
> |   document.getElementsByTagName(tagName)   | 通过html元素标签获取对应的html元素数组             |
> |      document.getElementsByName(name)      | 通过name属性的值获取对应的html元素数组             |
>
> *可以通过console.log将获取到的html元素打印到控制台，从控制台中查看该元素的全部属性和方法*
>
> **value属性**
>
> **innerHTML属性**
>
> 
>
> **innerText属性**
>
> 

#### setAttribute()

> setAttribute() 方法创建或改变某个新属性。
>
> 如果指定属性已经存在，则只设置该值。
>
> **格式**
>
> ```javascript
> element.setAttribute(attributename, attributevalue);
> ```
>
> - attributename：要添加的属性的名称
> - attributevalue：要添加的属性值
>
> **示例**
>
> ```javascript
> const newNode = createElement("div");
> newNode.setAttribute("class", "city");
> ```

### Date对象

> **使用JS处理日期和时间都围绕一个对象，就是Date对象**
>
> 这个Date对象，实际包含日期和时间
>
> JS内部的时间，是存储自1970.01.01以来的毫秒数(*时间戳*)

#### 创建Date对象

> *注意：node输出的UTC时间，浏览器输出的本地时间。如果使用node直接运行js，需要进行时间转换*
>
> **时间格式转换**
>
> ```javascript
> // 为Date原型添加如下的方法
> Date.prototype.format = function (fmt) {
>     const o = {
>         "M+": this.getMonth() + 1, //月份
>         "d+": this.getDate(), //日
>         "h+": this.getHours(), //小时
>         "m+": this.getMinutes(), //分
>         "s+": this.getSeconds(), //秒
>         "q+": Math.floor((this.getMonth() + 3) / 3), //季度
>         S: this.getMilliseconds(), //毫秒
>     };
>     if (/(y+)/.test(fmt)) {
>         fmt = fmt.replace(
>             RegExp.$1,
>             (this.getFullYear() + "").substr(4 - RegExp.$1.length)
>         );
>     }
>     for (const k in o) {
>         if (new RegExp("(" + k + ")").test(fmt)) {
>             fmt = fmt.replace(
>                 RegExp.$1,
>                 RegExp.$1.length == 1
>                     ? o[k]
>                     : ("00" + o[k]).substr(("" + o[k]).length)
>             );
>         }
>     }
>     return fmt;
> };
> // 转换为"年月日 时分秒"格式
> const time1 = new Date().format("yyyy-MM-dd hh:mm:ss");
> console.log(time1);
> // 获取带毫秒的格式
> const now = new Date().format("hh:mm:ss.S");
> console.log(now);
> // 转换成"年月日"的格式
> const time2 = new Date().format("yyyy-MM-dd");
> console.log(time2);
> ```
>
> **获取当前时间**：new Date();
>
> ```javascript
> const now = new Date();
> ```
>
> **设置指定的时间**：new Date(year, month, day, hours, minutes, seconds, milliseconds);
>
> *注意：Date对象中，月份从0开始计算，所以需要+1才是正确的月份。例如，在设置月份时，如果想设置4月，则输入3*
>
> ```javascript
> const randomDate = new Date(2015, 3, 12, 6, 25, 58);
> console.log(randomDate);
> ```
>
> **设置指定的年月日**：new Date(year, month, day);
>
> ```javascript
> const win95Launch = new Date(1995, 7, 24);
> console.log(win95Launch);
> ```
>
> **单独设置日期时间**
>
> ```javascript
> const now = new Date();
> now.setFullYear(2021);
> now.setMonth(9);
> now.setDate(6);
> console.log(now.format("yyyy-MM-dd")); // 2021-10-06
> ```
>
> |     **方法**      | **描述**                                            |
> | :---------------: | --------------------------------------------------- |
> |     setDate()     | 设置 Date 对象中月的某一天                          |
> |   setFullYear()   | 设置日期对象的年份                                  |
> |    setHours()     | 设置日期对象的小时                                  |
> | setMilliseconds() | 设置日期对象的毫秒数                                |
> |   setMinutes()    | 设置日期对象的分钟数                                |
> |    setMonth()     | 设置日期对象的月份                                  |
> |   setSeconds()    | 设置日期对象的秒数                                  |
> |     setTime()     | 将日期设置为 1970 年 1 月 1 日之后/之前的指定毫秒数 |
>
> **获取需要的日期时间**
>
> ```javascript
> const now = new Date();
> now.setFullYear(2021);
> now.setMonth(9);
> now.setDate(6);
> // 获取时间
> console.log(now.getFullYear()); // 2021
> console.log(now.getMonth()); // 9 实际月份要+1
> console.log(now.getDay()); // 3
> console.log(now.getDate()); // 6
> ```
>
> |     **方法**      | **描述**                                           |
> | :---------------: | -------------------------------------------------- |
> |     getDate()     | 返回月中的第几天（从 1 到 31）                     |
> |     getDay()      | 返回星期几（0-6）                                  |
> |   getFullYear()   | 返回年份                                           |
> |    getHours()     | 返回小时（从 0-23）                                |
> | getMilliseconds() | 返回毫秒（0-999）                                  |
> |   getMinutes()    | 返回分钟（从 0-59）                                |
> |    getMonth()     | 返回月份（从 0-11）                                |
> |   getSeconds()    | 返回秒数（从 0-59）                                |
> |     getTime()     | 返回自 1970 年 1 月 1 日午夜以来与指定日期的毫秒数 |

#### 操作DOM来进行时间每秒更新

> 有两种方法：setTimeout() 和 setInterval()
>
> 推荐使用 setInterval()

##### setTimeout()

> setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式
>
> **格式**
>
> ```javascript
> setTimeout(code,millisec);
> ```
>
> - code：要调用的函数后要执行的 JavaScript 代码串
> - millisec：周期性执行或调用 code 之间的时间间隔，以毫秒计
>
> **示例**
>
> ```javascript
> function show(){
>     //创建日期对象
>     var date = new Date();
>     //获取到年
>     var year = date.getFullYear();
>     //月份从0开始,需要加1
>     var month = date.getMonth()+1;
>     var day = date.getDate();
>     var weeks = new Array("天","一","二","三","四","五","六");
>     //星期
>     var week = date.getDay();
>     var hour = date.getHours();
>     var mi = date.getMinutes();
>     var second = date.getSeconds();
>     document.getElementById("show").innerText = year+"年"+month+"月"+day+"日,星期"+weeks[week]+" "+hour+"时"+mi+"分"+second+"秒";
>     //定时调用,等待指定时间,只调用一次函数
>     setTimeout("show()",999);
> }
> ```
>

##### clearTimeout

> clearTimeout() 方法可取消由 setTimeout() 方法设置的 timeout
>
> **格式**
>
> ```javascript
> clearTimeout(id_of_settimeout)
> ```
>
> - id_of_settimeout：由 setTimeout() 返回的 ID 值。该值标识要取消的延迟执行代码块
>
> **示例**
>
> ```javascript
> let stop = null;
> function show(){
>     //创建日期对象
>     var date = new Date();
>     //获取到年
>     var year = date.getFullYear();
>     //月份从0开始,需要加1
>     var month = date.getMonth()+1;
>     var day = date.getDate();
>     var weeks = new Array("天","一","二","三","四","五","六");
>     //星期
>     var week = date.getDay();
>     var hour = date.getHours();
>     var mi = date.getMinutes();
>     var second = date.getSeconds();
>     document.getElementById("show").innerText = year+"年"+month+"月"+day+"日,星期"+weeks[week]+" "+hour+"时"+mi+"分"+second+"秒";
>     //定时调用,等待指定时间,只调用一次函数
>     stop = setTimeout("show()",999);
> }
> document.getElementById("stop").addEventListener("click", function (){
>     clearTimeout(stop);
> });
> ```

##### setInterval()

> setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。
>
> setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。
>
> **格式**
>
> ```javascript
> setInterval(code, millisec[,"lang"]);
> ```
>
> - code：要调用的函数或要执行的代码串
> - millisec：周期性执行或调用 code 之间的时间间隔，以毫秒计
>
> **示例**
>
> ```javascript
> function show(){
>     //创建日期对象
>     var date = new Date();
>     //获取到年
>     var year = date.getFullYear();
>     //月份从0开始,需要加1
>     var month = date.getMonth()+1;
>     var day = date.getDate();
>     var weeks = new Array("天","一","二","三","四","五","六");
>     //星期
>     var week = date.getDay();
>     var hour = date.getHours();
>     var mi = date.getMinutes();
>     var second = date.getSeconds();
>     document.getElementById("show").innerText = year+"年"+month+"月"+day+"日,星期"+weeks[week]+" "+hour+"时"+mi+"分"+second+"秒";
> }
> setInterval("show()", 999);
> ```
>
> *注意：setInterval() 如果放在方法中,会创建出多个定时调用函数*

##### clearInterval()

> clearInterval() 方法可取消由 setInterval() 设置的 timeout。
>
> clearInterval() 方法的参数必须是由 setInterval() 返回的 ID 值
>
> **格式**
>
> ```javascript
> clearInterval(id_of_setinterval)
> ```
>
> - id_of_setinterval：由 setInterval() 返回的 ID 值
>
> **示例**
>
> ```javascript
> function show(){
>     //创建日期对象
>     var date = new Date();
>     //获取到年
>     var year = date.getFullYear();
>     //月份从0开始,需要加1
>     var month = date.getMonth()+1;
>     var day = date.getDate();
>     var weeks = new Array("天","一","二","三","四","五","六");
>     //星期
>     var week = date.getDay();
>     var hour = date.getHours();
>     var mi = date.getMinutes();
>     var second = date.getSeconds();
>     document.getElementById("show").innerText = year+"年"+month+"月"+day+"日,星期"+weeks[week]+" "+hour+"时"+mi+"分"+second+"秒";
> }
> const stop = setInterval("show()",999);
> document.getElementById("stop").addEventListener("click", function (){
>     clearInterval(stop);
> });
> ```

### 正则表达式

> 

#### 部分常用正则表达式

##### 匹配手机号

> **严格匹配**
>
> ```javascript
> const reg = /^[1](([3][0-9])|([4][5-9])|([5][0-3,5-9])|([6][5,6])|([7][0-8])|([8][0-9])|([9][1,8,9]))[0-9]{8}$/;
> ```
>
> **放宽部分限制**
>
> ```javascript
> const reg = /^[1]([3-9])[0-9]{9}$/;
> ```

##### 匹配密码

> **密码长度大于6位，必须包含数字和字母**
>
> ```javascript
> const reg = /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{6,}$/;
> ```
>
> **密码长度大于8位，可以为纯数字或字母**
>
> ```javascript
> const reg = /^[a-zA-Z\d_]{8,}$/;
> ```
>
> **只匹配各种特殊字符**
>
> ```javascript
> const reg = /[`~!@#$%^&*()_\-+=<>?:"{}|,.\/;'\\[\]·~！@#￥%……&*（）——\-+={}|《》？：“”【】、；‘’，。、]/im;
> ```
>
> **匹配密码长度8~16位，包含数字字母和特殊字符**
>
> ```javascript
> const reg = /^[a-zA-Z\d_`~!@#$%^&*()_\-+=<>?:"{}|,.\/;'\\[\]·~！@#￥%……&*（）——\-+={}|《》？：“”【】、；‘’，。、]{8,16}$/;
> ```

##### 匹配邮箱

> 
>
> ```javascript
> 
> ```
>
> 

## JQuery

> 

### $(document).ready()

> 文档就绪事件
>
> **格式**
>
> ```javascript
> $(document).ready(function(){
>    // 开始写 jQuery 代码...
> });
> ```
>
> 该方法允许我们在文档完全加载完后执行函数
>
> 为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。jQuery 函数应写在 document ready 函数中
>
> 如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子：
>
> - 试图隐藏一个不存在的元素
> - 获得未完全加载的图像的大小
>
> **简洁写法**
>
> ```javascript
> $(function(){
>    // 开始写 jQuery 代码...
> });
> ```
>
> 两种写法效果相同

### JQuery中的选择器

> 

### JQuery添加dom元素的方式

> 可以分为俩类
>
> - **相对于父元素插入位置**
> - **相对于兄弟元素插入位置**

#### 相对于父元素插入位置

> **父元素的第一孩子元素**
>
> ```javascript
> $('parent').prepend('child')   // parent 和 child 分别代表 父元素和要插入子元素
> ```
>
> **父元素的最后一孩子元素**
>
> ```javascript
> $('parent').append('child')   // parent 和 child 分别代表 父元素和要插入子元素
> ```

#### 相对于兄弟元素插入位置

> **插入到兄弟元素前面**
>
> ```javascript
> $('child'). before('brother')   // child 和 brother 分别代表 要插入的子元素和 兄弟元素
> ```
>
> **插入到兄弟元素后面**
>
> ```javascript
> $('child').after('brother')   // child 和 brother 分别代表 要插入的子元素和 兄弟元素
> ```

### JQuery中的事件

> JQuery 是为事件处理特别设计的

#### 鼠标事件

> 

##### click

> 

##### dblclick

> 

##### mouseover

> 

##### mouseout

> 

#### 键盘事件

> 

##### keydown

> 

##### keyup

> 

##### keypress

> 

#### 表单事件

> 

##### submit

> 

##### change

> 

##### focus

> 

##### blur

> 

#### 文档/窗口事件

> 

##### load

> 

##### resize

> 

##### scroll

> 

##### unload

> 

#### 复合事件

> **所谓复合事件，是相对单一事件而言的，就是一组事件的组合**
>
> 例如：下拉菜单，我们就可以采用鼠标移入和鼠标移出2个事件的组合来实现，当鼠标移入时就显示下拉菜单，当移出时就隐藏下拉菜单

##### hover

> hover() 方法规定当鼠标指针悬停在被选元素上时要运行的两个函数。
>
> 方法触发 mouseenter 和 mouseleave 事件。
>
> 注意: 如果只指定一个函数，则 mouseenter 和 mouseleave 都执行它

##### toggle

> 

#### 事件的绑定与解除绑定

> 

### JQuery中this与$(this)的区别

> ```javascript
> $("#textbox").hover(   
>     function() {   
>         this.title = "Test";   
>     },   
>     function() {   
>     	this.title = "OK”;   
>     }   
> ); 
> ```
>
> 这里的this其实是一个html 元素(textbox)，textbox有text属性，所以这样写是完全没有什么问题的。 
> 但是如果将this换成(this)就不是那回事了，报Error了。this与(this)的区别在此。
>
> ```javascript
> // Error Code：   
> $("#textbox").hover(   
>     function() {   
>         $(this).title ＝ "Test";   
>     },   
>     function() {   
>         $(this).title = "OK";   
>     }   
> ); 
> ```
>
> $()这是jQuery的一个函数，也是最核心最基本的函数
>
> 功能一：传入一个选择器字符串，获得这个选择器对应的dom内容，保存在[]中，也就是俗称的jQuery对象。例如
>
> ('#id')(‘.class’) $(‘tag’) 
> 功能二：传入一个匿名函数，例如
>
> $(function(){})//这个匿名函数在网页载入完成后开始执行 
> 功能三：将JavaScript对象包装成为jQuery对象。例如
>
> ```javascript
> $(this)
> $({a:1,b:2,c:3})
> $(document.getElementById('idstr'))
> ```
>
> this是javascript**自身的**语法关键字，它指向一个javascript对象，所以可以使用所指向的目标javascript对象所拥有的方法, 但他自己不是一个普通的变量，所以你无法自己定义一个变量叫this
>
> 所以为了使用jQuery对象的方法，你必须传入jQuery函数$(this), 将javascript 对象包装成为一个jquery对象。
>
> 这里的$(this)是一个JQuery对象，而jQuery对象沒有title 属性，因此这样写是错误的。
>
> JQuery拥有attr()方法可以get/set DOM对象的属性，所以正确的写法应该是这样：
>
> 正确的代码：
>
> ```javascript
> $("#textbox").hover(   
>     function() {   
>         $(this).attr(’title’, ‘Test’);   
>     },   
>     function() {   
>         $(this).attr(’title’, ‘OK’);   
>     }   
> ); 
> ```
>
> 使用jQuery的好处是它包裝了各种浏览器版本对DOM对象的操作，因此统一使用$(this)而不再用this应该是比较不错的选择。

## TypeScript

> **简介**
>
> TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准。
>
> TypeScript 由微软开发的自由和开源的编程语言。
>
> TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。
>
> **安装**
>
> node安装：**npm install -g typescript**
>
> **运行**
>
> ts编译为js：**tsc ts文件名**

### TypeScript静态类型

## ES6

### ES6模块化规范中定义：

> -     每个js文件都是一个独立的模块
> -     导入其他模块成员使用<span style="color: red;">import</span>关键字
> -     向外共享模块成员使用<span style="color: red;">export</span>关键字
>

### 在node.js中体验ES6模块化

> node.js中默认仅支持CommonJS模块化规范，若想基于node.js体验ES6的模块化语法，可以按照如下两个步骤进行配置
>
> 1. 确保安装了v14.15.1或更高版本的node.js
> 2. 在package.json的根节点中添加 "type":"module"节点

### ES6模块化的默认导出和导入

> **默认导出**：
>
> 默认导出的语法：<span style="color: red;">export default</span> <span style="color: #329BDC;">默认导出成员</span>
>
> ```javascript
> len n2 = 10 // 定义模块私有成员 n1
> len n2 = 20 // 定义模块私有成员 n2（外界访问不到 n2，因为它没有被共享出去）
> funciton show(){} // 定义模块私有方法 show
> 
> export default { // 使用 export default 默认导出语法，向外共享 n1 和 show 两个成员
>  n1,
>  show
> }
> ```
>
> <span style='color: red;'>默认导出的注意事项：</span>每个模块中，<span style='color: #329BDC; text-decoration:underline;'>只允许使用唯一的一次</span> export default，否则会报错！
>
> **默认导入：**
>
> 默认导入的语法：<span style="color: red;">import</span> <span style="color: #329BDC;">接受名称</span> <span style="color: red;">from</span> '<span style="color: #329BDC;">模块化标识符</span>'
>
> ```javascript
>// 从 01_m1.js 模块中导入 export default 向外共享的成员
> import m1 from './01_m1.js'
> 
> // 打印输出的结果为：
> //{ n1: 10, show: [Function: show] }
> console.log(m1)
> ```
> 
> <span style='color: red;'>默认导入的注意事项：</span>默认导入时的接收名称可以任意名称，<span style="color: #329BDC;">只要是合法的成员名称即可</span>

### ES6模块化的按需导出和导入

> **按需导出：**
>
> 按需导出的语法：<span style="color: red;">export</span> <span style="color: #329BDC;">按需导出的成员</span>
>
> ```javascript
> // 当前模块为03_m2.js
> 
> // 向外按需导出变量 s1
> export let s1 = 'aaa'
> // 向外按需导出变量 s2
> export let s2 = 'ccc'
> // 向外按需导出方法 say
> export function say(){}
> ```
>
> **按需导入：**
>
> 按需导入的语法：<span style="color: red;">import</span> {<span style="color: #329BDC;">s1</span>} <span style="color: red;">from</span>> '模块标识符'
>
> ```javascript
> // 导入模块成员
> import { s1, s2, say } from './03_m2.js'
> 
> console.log(s1) // 打印输出 aaa
> console.log(s2) // 打印输出 ccc
> console.log(sa) // 打印输出 [Function: say]
> ```
>
> <span style='color: red;'>按需导出与按需导入的注意事项：</span>
>
> - 每个模块中可以使用<span style="color: red;">多次</span>按需导出
>
> - 按需<span style="color: red;">导入的成员名称</span>必须和<span style="color: red;">按需导出的名称</span>保持一致
>
> - 按需导入时，可以使用<span style="color: red;"> as 关键字</span>>进行重命名
>
> - ```javascript
>   // 导入模块成员
>   import { s1, s2 as str2, say } from './03_m2.js'
>                   
>   console.log(s1) // 打印输出 aaa
>   console.log(str2) // 打印输出 ccc
>   console.log(say) // 打印输出 [Function: say]
>   ```
>
> - 按需导入可以和默认导入一起使用

