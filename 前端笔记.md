## CSS(未完成)

> 

### <span id="cssTable">CSS 选择器参考手册</span>

> | 选择器                       | 例子                  | 例子描述                                             |
> | ---------------------------- | --------------------- | ---------------------------------------------------- |
> | **.*class***                 | .intro                | 选择 class="intro" 的所有元素。                      |
> | **.*class1*.*class2***       | .name1.name2          | 选择 class 属性中同时有 name1 和 name2 的所有元素。  |
> | **.*class1* .*class2***      | .name1 .name2         | 选择作为类名 name1 元素后代的所有类名 name2 元素。   |
> | **#*id***                    | #firstname            | 选择 id="firstname" 的元素。                         |
> | *****                        | *                     | 选择所有元素。                                       |
> | ***element* **               | p                     | 选择所有 <p> 元素。                                  |
> | ***element*.*class***        | p.intro               | 选择 class="intro" 的所有 <p> 元素。                 |
> | ***element*,*element***      | div, p                | 选择所有 <div> 元素和所有 <p> 元素。                 |
> | ***element* *element***      | div p                 | 选择 <div> 元素内的所有 <p> 元素。                   |
> | ***element*>*element***      | div > p               | 选择父元素是 <div> 的所有 <p> 元素。                 |
> | ***element*+*element***      | div + p               | 选择紧跟 <div> 元素的首个 <p> 元素。                 |
> | ***element1*~*element2***    | p ~ ul                | 选择前面有 <p> 元素的每个 <ul> 元素。                |
> | **[*attribute*\]**           | [target]              | 选择带有 target 属性的所有元素。                     |
> | **[*attribute*=*value*\]**   | [target=_blank]       | 选择带有 target="_blank" 属性的所有元素。            |
> | **[*attribute*~=*value*\]**  | [title~=flower]       | 选择 title 属性包含单词 "flower" 的所有元素。        |
> | **[*attribute*\|=*value*\]** | [lang\|=en]           | 选择 lang 属性值以 "en" 开头的所有元素。             |
> | **[*attribute*^=*value*\]**  | a[href^="https"]      | 选择其 src 属性值以 "https" 开头的每个 <a> 元素。    |
> | **[*attribute*$=*value*\]**  | a[href$=".pdf"]       | 选择其 src 属性以 ".pdf" 结尾的所有 <a> 元素。       |
> | **[*attribute*\*=*value*]**  | a[href*="w3schools"]  | 选择其 href 属性值中包含 "abc" 子串的每个 <a> 元素。 |
> | **:active**                  | a:active              | 选择活动链接。                                       |
> | **::after**                  | p::after              | 在每个 <p> 的内容之后插入内容。                      |
> | **::before**                 | p::before             | 在每个 <p> 的内容之前插入内容。                      |
> | **:checked**                 | input:checked         | 选择每个被选中的 <input> 元素。                      |
> | **:default**                 | input:default         | 选择默认的 <input> 元素。                            |
> | **:disabled**                | input:disabled        | 选择每个被禁用的 <input> 元素。                      |
> | **:empty**                   | p:empty               | 选择没有子元素的每个 <p> 元素（包括文本节点）。      |
> | **:enabled**                 | input:enabled         | 选择每个启用的 <input> 元素。                        |
> | **:first-child**             | p:first-child         | 选择属于父元素的第一个子元素的每个 <p> 元素。        |
> | **::first-letter**           | p::first-letter       | 选择每个 <p> 元素的首字母。                          |
> | **::first-lin**              | p::first-line         | 选择每个 <p> 元素的首行。                            |
> | **:first-of-type**           | p:first-of-type       | 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。     |
> | **:focu**                    | input:focus           | 选择获得焦点的 input 元素。                          |
> | **:fullscreen**              | :fullscreen           | 选择处于全屏模式的元素。                             |
> | **:hover**                   | a:hover               | 选择鼠标指针位于其上的链接。                         |
> | **:in-range**                | input:in-range        | 选择其值在指定范围内的 input 元素。                  |
> | **:indeterminate**           | input:indeterminate   | 选择处于不确定状态的 input 元素。                    |
> | **:invalid**                 | input:invalid         | 选择具有无效值的所有 input 元素。                    |
> | **:lang(*language*)**        | p:lang(it)            | 选择 lang 属性等于 "it"（意大利）的每个 <p> 元素。   |
> | **:last-child**              | p:last-child          | 选择属于其父元素最后一个子元素每个 <p> 元素。        |
> | **:last-of-type**            | p:last-of-type        | 选择属于其父元素的最后 <p> 元素的每个 <p> 元素。     |
> | **:link**                    | a:link                | 选择所有未访问过的链接。                             |
> | **:not(*selector*)**         | :not(p)               | 选择非 <p> 元素的每个元素。                          |
> | **:nth-child(*n*)**          | p:nth-child(2)        | 选择属于其父元素的第二个子元素的每个 <p> 元素。      |
> | **:nth-last-child(*n*)**     | p:nth-last-child(2)   | 同上，从最后一个子元素开始计数。                     |
> | **:nth-of-type(*n*)**        | p:nth-of-type(2)      | 选择属于其父元素第二个 <p> 元素的每个 <p> 元素。     |
> | **:nth-last-of-type(*n*)**   | p:nth-last-of-type(2) | 同上，但是从最后一个子元素开始计数。                 |
> | **:only-of-type**            | p:only-of-type        | 选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。     |
> | **:only-child**              | p:only-child          | 选择属于其父元素的唯一子元素的每个 <p> 元素。        |
> | **:optional**                | input:optional        | 选择不带 "required" 属性的 input 元素。              |
> | **:out-of-range**            | input:out-of-range    | 选择值超出指定范围的 input 元素。                    |
> | **::placeholder**            | input::placeholder    | 选择已规定 "placeholder" 属性的 input 元素。         |
> | **:read-only**               | input:read-only       | 选择已规定 "readonly" 属性的 input 元素。            |
> | **:read-write**              | input:read-write      | 选择未规定 "readonly" 属性的 input 元素。            |
> | **:required**                | input:required        | 选择已规定 "required" 属性的 input 元素。            |
> | **:root**                    | :root                 | 选择文档的根元素。                                   |
> | **::selection**              | ::selection           | 选择用户已选取的元素部分。                           |
> | **:target**                  | #news:target          | 选择当前活动的 #news 元素。                          |
> | **:valid**                   | input:valid           | 选择带有有效值的所有 input 元素。                    |
> | **:visited**                 | a:visited             | 选择所有已访问的链接。                               |

## JavaScript(未完成)

> 
>
> **运行**
>
> 可以使用 node 直接运行，在 cmd 中使用命令 node js文件，这种方式运行的 js 文件中 [console.log](#Console) 输出将在 cmd 控制台中
>
> 

### 声明变量的方式

> **var**
>
> - JS中最原始定义变量方式
> - var是有函数作用域的变量声明，表示定义的变量，在该函数内处处有效
>   - 比如说在for循环内定义的一个 var 变量，实际上其在for循环以外也是可以访问的
> - 因为是函数全局作用域内可用，所以在人为声明前就已存在(*如果在函数第10行定义了个变量，其实在1行就能使用，并不会报错*)
> - var表示是可变变量类型
>   - var定义的变量在作用域内可改动，可以重新赋值，可以改变数据类型
>   - **可以任意改变变量会有潜在危险**
> - 没有使用的必要了，有泄漏的危险
>
> **let**
>
> - 和 var 很相似，但它是块作用域而非函数作用域，表示其只能作用在块中，一旦超出作用域，变量就无法使用了
>   - 比如说在for循环内定义的一个 let 变量，在其外面是不可被访问的
> - let 只能在声明后使用(*如果在函数第10行定义了个变量，只能在第11行之后使用*)
> - let 也是可变变量类型，同样可以改变变量的值，类型等等
> - 建议在循环中使用 let 来声明变量
>
> **const**
>
> - 和 let 类似，是块作用域变量
> - const 只能在声明后使用
> - const 修饰的变量表示为常量，只能在初始时设置一次，不能改变变量的值，类型等
> - 建议尽可能多用 const 变量类型，有助于减少bug的产生

### 字符串拼接

> **通过使用 + 运算符来进行字符串的拼接**
>
> ```javascript
> let str1 = "hello ";
> let str2 = "world!";
> console.log(str1 + str2);
> console.log(str1 + "Big " + str2);
> ```
>
> **数字和字符串的拼接**
>
> ```javascript
> let num1 = 1;
> let num2 = "1";
> // 数字和字符串拼接
> console.log(num1 + num2); // 11
> // 数字之间相加
> console.log(num1 + 1); // 2
> ```

### 模板字符串

> ES6中引入了模板字符串，让我们告别了使用大量'' 和 +来连接字符串了写法
>
> **描述**
>
> - 模板字符串使用反引号 (\` \`) 来代替普通字符串中的用双引号和单引号。
> - 模板字符串可以包含特定语法（ \`${expression}\` ）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来
> - 如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串
> - 该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。
> - 在模版字符串内使用反引号（`）时，需要在它前面加转义符（\）
>
> **使用模板字符串来实现字符串的拼接**
>
> ```javascript
> let str1 = "hello";
> let str2 = "world!";
> console.log(`${str1} ${str2}`);
> console.log(`${str1} Big ${str2}`);
> ```
>
> **使用模板字符串来实现数字和字符串的拼接**
>
> ```javascript
> let num1 = 1;
> let num2 = "1";
> console.log(`${num1}${num2}`);
> ```
>
> **模板字符串中使用表达式**
>
> ```javascript
> let bool1 = true;
> console.log(`1 + 1 is ${1 + 1}`); // 1 + 1 is 2
> console.log(`The opposite of true is ${!bool1}`); // The opposite of true is false
> ```

### 数据类型

> **JS是一门弱类型语言，这意味着相较于其他的编程语言，JS的类型系统并不丰富和健壮**
>
> 在JS中变量以伪动态方式定义，表示类型由赋值决定
>
> JS中只有一种数据类型，浮点型。在JS中整数和浮点数类型没有区别
>
> **JS中有一个特有的类型，NaN(非数 not a number)。JS中检测尝试转换为数字的东西，是否为有效数字，如果不是有效数字，则显示NaN**

#### null和undefined在JS中的区别

> **相同点**
>
> - if 判断语句中，两者都会被转换为false
>
> **不同点**
>
> - Number转换的值不同，Number(null)输出为0, Number(undefined)输出为NaN
> - null表示一个值被定义了，但是这个值是空值
>   - 作为函数的参数，表示函数的参数不是对象
>   - 作为对象原型链的终点 （Object.getPrototypeOf(Object.prototype)）
>   - 定义一个值为null是合理的，但定义为undefined不合理（var name = null）
> - undefined表示缺少值，即此处应该有值，但是还没有定义
>   - 变量被声明了还没有赋值，就为undefined
>   - 调用函数时应该提供的参数还没有提供，该参数就等于undefined
>   - 对象没有赋值的属性，该属性的值就等于undefined
>   - 函数没有返回值，默认返回undefined

#### typeof

> typeof运算符，用来检测一个变量的类型
>
> typeof是一个运算符，有2种使用方式：typeof(表达式)和typeof 变量名，第一种是对表达式做运算，第二种是对变量做运算
>
> typeof运算符的返回类型为字符串，值包括如下几种
>
> - undefined	--未定义的变量或值
> - boolean	--布尔类型的变量或值
> - string	--字符串类型的变量或值
> - number	--数字类型的变量或值
> - object	--对象类型的变量或值，或者null(这个是js历史遗留问题，将null作为object类型处理)
> - function	--函数类型的变量或值
>
> ```javascript
> console.log(typeof a);    //'undefined'
> console.log(typeof(true));  //'boolean'
> console.log(typeof '123');  //'string'
> console.log(typeof NaN);   //'number'
> 
> var obj = new String();
> console.log(typeof(obj));    //'object'
> 
> var  fn = function(){};
> console.log(typeof(fn));  //'function'
> ```

#### instanceof

> 用于确定某些内容是否从特定数据类型的构造函数中创造
>
> instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上
>
> ```javascript
> // 定义构造函数
> function C(){}
> function D(){}
> 
> var o = new C();
> 
> o instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototype
> o instanceof D; // false，因为 D.prototype 不在 o 的原型链上
> ```

#### 对JS中的变量重新赋值

> ```javascript
> let x = 'something';
> x = 1;
> x = 1 + 'hello';
> console.log(x); // '1hello'
> ```

#### ==和===之间的区别

> **在JS中，对于string,number等基础类型，==和===是有区别的**
>
> - 不同类型间比较，==之比较“转化成同一类型后的值”看“值”是否相等，===如果类型不同，其结果就是不等
> - 同类型比较，直接进行“值”比较，两者结果一样
>
> **对于Array,Object等高级类型，==和===是没有区别的**
>
> **基础类型与高级类型，==和===是有区别的**
>
> - 对于==，将高级转化为基础类型，进行“值”比较
> - 因为类型不同，===结果为false
>
> **==比较值是否相等，不同类型的值会发生隐式强制类型转换**
>
> ```javascript
> // 0 和 ' ' 发生隐式强制类型转换，空字符调用ToNumber转成0，0==0 返回true
> let x = 0 == '';
> ```
>
> **===比较值和类型是否相等，不同类型的值不会发生隐式强制类型转换**
>
> ```javascript
> // 0 和 ' ' 不发生隐式强制类型转换，0=='' 返回false
> let x = 0 === '';
> ```

### 数学运算

> **基础运算**
>
> ```javascript
> let num = 100;
> // 加法
> console.log(num1 + 25);
> // 减法
> console.log(num1 - 100);
> // 乘法
> console.log(num1 * 100);
> // 除法
> console.log(num1 / 1500);
> // 取余
> console.log(num1 % 1500);
> // 自加
> console.log(++num1);
> // 自减
> console.log(--num1);
> ```
>
> **高级运算**
>
> 如果需要使用更多的运算方法，使用 Math 对象
>
> ```javascript
> let num = 100;
> // 圆周率
> console.log(Math.PI);
> // num的平方根
> console.log(Math.sqrt(num1)); // 10
> // 返回 0（含）和 1（不含）之间的随机数
> console.log(Math.random());
> ```

### 数字和字符串类型转换

> **字符串转为数字**
>
> parseInt()
>
> ```javascript
> let num1 = '150';
> console.log(parseInt('100')); // 100
> console.log(parseInt(num1)); // 150
> console.log(parseInt('ABC')); // NaN
> console.log(parseInt('0xF')); // 15
> 
> console.log(parseInt('1 + 1')); // 1
> console.log(parseInt(`${1 + 1}`)); // 2
> ```
>
> parseFloat()
>
> ```javascript
> let flo1 = '1.50';
> console.log(parseInt('1.00')); // 1
> console.log(parseInt(flo1)); // 1.5
> console.log(parseInt('ABC')); // NaN
> ```
>
> **数字转为字符串**
>
> toString()
>
> ```javascript
> let num1 = 150;
> let flo1 = 1.50;
> console.log(num1.toString()); // '150'
> console.log(flo1.toString()); // '1.50'
> console.log((100).toString()); // '100'
> ```
>

### 异常处理

> **概述**
>
> 异常是指代码执行过程中的中断，通常由错误引起
>
> 代码中有错误就会报错(如：使用了错误的语法)，异常就是代码运行中在何时何处出现错误
>
> 抛出异常，会告诉你一条代码哪里出错的信息
>
> JS可以抛出异常，或是开发者自己手动抛出

#### try--catch

> - 格式
>
>   ```javascript
>    try {
>       可能出现异常的代码;
>    } catch(变量名) {
>       异常的处理代码;
>   }
>   ```
>
> - 范例
>
>   ```javascript
>   try {
>       criticalCode();
>   } catch (ex) {
>       console.log("Got an error");
>       console.log(ex.message);
>   }
>   ```
>
> - 执行流程：
>
>   - 程序从try里面的代码开始执行
>   - 出现异常，会自动生成一个异常类对象，该异常对象将被提交给Java运行时系统
>   - 当JS运行时系统接收到异常对象时，会到catch中去找匹配的异常类，找到后进行异常的处理
>   - 执行完毕之后，程序还可以继续往下执行

#### finally

> <span style="color: red;">finally语句块总是会被执行</span>。它主要用于回收在try块里打开的物理资源(如数据库连接、网络连接和磁盘文件)。只有finally块执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止
>
> ```javascript
> try {
>     criticalCode();
> } catch (ex) {
>     console.log("Got an error");
>     console.log(ex.message);
> } finally {
>     console.log("continue");
> }
> ```
>
> **至少有两种情况下finally语句是不会被执行**
>
> - *try语句没有被执行到，如在try语句之前就返回了，这样finally语句就不会执行，这也说明了finally语句被执行的必要而非充分条件是：相应的try语句一定被执行到*
> - *在try块中有System.exit(0);这样的语句，System.exit(0);是终止Java虚拟机JVM的，连JVM都停止了，所有都结束了，当然finally语句也不会被执行到*
>
> **finally语句是在try的return语句执行之后，return返回之前执行**

#### 自定义异常

> **用于开发者手动抛出自定义异常**
>
> - 格式：
>
>   ```javascript
>   throw 抛出异常的内容; 
>   ```
>
> - 范例：
>
>   ```javascript
>   throw "myException";
>   
>   function criticalCode() {
>       throw true;
>   }
>   ```
>
> - 使用：
>
>   ```javascript
>   function criticalCode() {
>       throw "myException";
>   }
>                                                           
>   try {
>       criticalCode();
>   } catch (ex) {
>       console.log(ex.message); // "myException"
>   }
>   ```

### JS数组

> **概述**
>
> 数组是聚集值的列表
>
> JS中，一个数组可以存储很多不同数据类型的值
>
> 当一个值添加进数组，会分配到一个指定数字index(索引)。这是一个独一无二的数字，可以在任何时候用来引用，和访问数组中的值
>
> 可以通过数组中的 length 属性来获取当前数组的长度
>
> **创建数组的方式**
>
> - 通过[]创建
>
>   ```javascript
>   let arr1 = [];
>   console.log(arr1.length); // 0
>   ```
>
> - 通过数组对象创建
>
>   - 使用数组对象创建必须要设定长度
>
>   ```javascript
>   let arrayLength = 5;
>   let arr2 = Array(arrayLength);
>   console.log(arr2.length); // 5
>   ```
>
> **向数组中添加数据**
>
> - 在创建时向数组中添加数据
>
>   ```javascript
>   let arr1 = ["A", true, 2];
>   console.log(arr1[0]); // "A"
>   console.log(arr1[1]); // true
>   ```
>
> - 在创建后向数组中添加数据
>
>   - 通过数组的索引(index)来进行添加，index始终从0开始
>
>   ```javascript
>   let arrayLength = 2;
>   let arr2 = Array(arrayLength);
>   arr2[0] = "Value at index 0";
>   console.log(arr2[0]); // "Value at index 0"
>   console.log(arr2[1]); // undefined
>   ```
>
> **数组的属性length**
>
> - 通过数组对象创建的数组，length等于创建时设定的长度，即使数组中并没有数据
>
>   ```javascript
>   let arrayLength = 5;
>   let arr = Array(arrayLength);
>   console.log(arr.length); // 5
>   ```
>
> - 通过[]创建的数组，如果创建时没有添加数据，length等于0。直到后面通过索引添加数据，length等于索引的值+1
>
>   ```javascript
>   let arr = []
>   console.log(arr.length); // 0
>   arr[1] = 1;
>   arr[3] = 2;
>   console.log(arr.length); // 4
>   ```
>
> **数组中常用的添加和移除方法**
>
> | **方法**  | **描述**               |
> | :-------: | ---------------------- |
> |  push()   | 在数组末尾中添加新元素 |
> |   pop()   | 移除最后一个数组元素   |
> |  shift()  | 移除第一个数组元素     |
> | unshift() | 在数组起始中添加新元素 |
> | concat()  | 连接两个或多个数组     |
>
> ```javascript
> let arr1 = ["A", true, 2];
> // push pop
> console.log(arr1.push("new value")); // 4
> console.log(arr1); // [ 'A', true, 2, 'new value' ]
> console.log(arr1.pop()); // new value
> console.log(arr1); // [ 'A', true, 2 ]
> // unshift shift
> console.log(arr1.unshift("new value")); // 4
> console.log(arr1); // [ 'new value', 'A', true, 2 ]
> console.log(arr1.shift()); // new value
> console.log(arr1); // [ 'A', true, 2 ]
> ```
>
> *concat*
>
> ```javascript
> let arr1 = ["A", true, 2];
> let arr2 = ["B", false, 3];
> let newArr = arr1.concat(arr2);
> let newArr2 = arr2.concat([1, 2, 3]);
> console.log(newArr); // [ 'A', true, 2, 'B', false, 3 ]
> console.log(newArr2); // [ 'B', false, 3, 1, 2, 3 ]
> ```
>
> **遍历数组**
>
> - 使用for循环遍历数组
>
>   ```javascript
>   let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
>   for (let i = 0; i < arr.length; i++) {
>       console.log(arr[i]);
>   }
>   ```
>
> - 使用for...in循环遍历数组
>
>   ```javascript
>   let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
>   for (let i in arr) {
>       console.log(arr[i]);
>   }
>   ```
>
> **通过[]创建的空数组，之后使用index添加部分值，使用两种方法遍历数组得出的结果不同**
>
> ```javascript
> let arr = [];
> arr[1] = 1;
> arr[3] = 2;
> ```
>
> - 通过for循环遍历
>
>   ```javascript
>   for (let i = 0; i < arr.length; i++) 
>       console.log(arr[i]);
>   /**
>    * 运行结果
>    * undefined
>    * 1
>    * undefined
>    * 2
>    */
>   ```
>
> - 通过for...in循环遍历
>
>   ```javascript
>   for (let i in arr) 
>       console.log(arr[i]);
>   /**
>    * 运行结果
>    * 1
>    * 2
>    */
>   ```

### JS中输出的部分方式

> <span name="Console">**console.log**</span>
>
> console.log() 方法用于在控制台输出信息。
>
> 该方法对于开发过程进行测试很有帮助。
>
> **提示:** 在测试该方法的过程中，控制台需要可见 (浏览器按下 F12 打开控制台)
>
> ```javascript
> console.log("Hello Runoob!");
> ```
>
> **alert**
>
> alert() 方法用于显示带有一条指定消息和一个 OK 按钮的警告框
>
> ```javascript
> alert('message');
> ```
>
> **document.write**
>
> write() 方法可向文档写入 HTML 表达式或 JavaScript 代码。
>
> 可列出多个参数(exp1,exp2,exp3,...) ，它们将按顺序被追加到文档中。
>
> ```javascript
> document.write("Hello World!");
> ```
>
> 

### JS函数

#### 普通函数

> - <span style='color: purple; text-decoration:underline;'>无参数</span>：
>
>   格式：
>
>   ```javascript
>   function 函数名(){
>    	// 函数体
>   }
>   ```
>
>   范例：
>
>   ```javascript
>   function isEvenNumber(){
>   	// 函数体
>   }
>   ```
>
> - <span style='color: purple; text-decoration:underline;'>有参数</span>：
>
>   - 格式：
>
>     ```javascript
>     function 函数名(变量名1, 变量名2, ...){
>      	// 函数体
>     }
>     ```
>
>   - 范例：
>
>     ```javascript
>     function isEvenNumber(num1, num2, ...){
>      	// 函数体
>     }
>     ```
>
>    - 函数定义时，多个参数之间使用逗号(，)分隔

#### this对象(未完成)

> 

#### 匿名函数(未完成)

> 

#### 箭头函数

> **概述**
>
> 箭头函数省去了 function 关键字，采用箭头 => 来定义函数。函数的参数放在 => 前面的括号中，函数体跟在 => 后的花括号中
>
> **关于箭头函数的参数**
>
> - 如果箭头函数没有参数，直接写一个空括号即可
> - 如果箭头函数的参数只有一个，也可以省去包裹参数的括号
> - 如果箭头函数有多个参数，将参数依次用逗号(,)分隔，包裹在括号中即可
>
> **箭头函数有个隐式返回语句，在只有单行语句的情况下，不用return就使其发生以及完成那条语句所要执行的操作**
>
> ```javascript
> // 箭头函数实现加法
> const add = (a, b) => a + b;
> console.log(add(1, 2)); // 3
> ```
>
> **箭头函数的多行语句**
>
> - 如果在多行语句的箭头函数中不使用 return ，则返回 undefined。因为不知道函数在哪里结束
>
> ```javascript
> // 箭头函数实现减法
> const  subtract = (a, b) => {
>     const result = a - b;
>     return result;
> };
> console.log(subtract(2, 1)); // 1
> ```
>
> *注意*：
>
> - 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象，箭头函数继承而来的 this 指向永远不变
> - 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误
> - 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 Rest 参数代替
> - 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数

### JSON

> **概述**
>
> JSON(JavaScript Object Notation, JS 对象简谱) 是一种**轻量级的数据交换格式**。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率
>
> **格式**
>
> JSON有两种表示结构，对象和数组
>
> - 对象结构以”{”大括号开始，以”}”大括号结束。中间部分由0或多个以”，”分隔的”key(关键字)/value(值)”对构成，关键字和值之间以”：”分隔，语法结构如代码
>
>   ```json
>   {
>       key1:value1,
>       key2:value2
>   }
>   ```
>
>   - 其中 key 是字符串，而 value 可以是字符串，数值，true，false，null，对象或数组
>
> - 数组结构以”[”开始，”]”结束。中间由0或多个以”，”分隔的值列表组成，语法结构如代码
>
>   ```json
>   [
>       {"key1":"value1","key2":"value2","key3":"value3","key3":"value3"},
>       {"key1":"value1","key2":"value2","key3":"value3","key3":"value3"},
>       {"key1":"value1","key2":"value2","key3":"value3","key3":"value3"}
>   ]
>   ```
>
> **JSON字符串和JSON对象的区别**
>
> JSON字符串：指的是符合 json 格式要求的js字符串。
>
> ```javascript
> let jsonStr = "{StudentID:'100',Name:'tmac',Hometown:'usa'}";
> ```
>
> JSON对象：指符合json格式要求的js对象。
>
> ```javascript
> let jsonObj = { StudentID: "100", Name: "tmac", Hometown: "usa" };
> ```
>
> **JS中使用JSON**
>
> JSON是JS的一个子集，所以可以在JS中轻松地读，写JSON。读和写JSON都有两种方法，分别是利用”.”操作符和“[key]”的方式

### DOM

####　什么是DOM

> - 通过 JS 改动 HTML 方式就是用 DOM
> - DOM 其实和 HTML 完全相同，总是和页面的 HTML 相同
> - 如果修改 DOM 上任何东西 HTML 就会自动更新，如果添加新的 HTML，DOM也会跟着改变
> - DOM内包含有
>   - 方法
>     - 方法是附属于 document 对象的函数，可以执行像：允许我们选择指定的 HTML 元素，例如：页面的标题
>   - 对象
>     - 通过 document 对象，子对象有更多的对象，例如：选择标题，会给我们 HTML 元素，就是 DOM 上的对象
>     - 子对象也有自己的方法和属性，例如通过 addEventListener 去监听标题单击
>   - 属性
>     - 选择标题，选中后用 .style.color，设置为字符串 red 来改变该标题的颜色
>     - style 是子对象，在其中有所有 css 类型的属性
> - 一个 HTML 文件等同于一个 DOM 或 JS 中的文档对象

#### JS操作DOM

> **获取html元素**
>
> |                    方法                    | 说明                                               |
> | :----------------------------------------: | -------------------------------------------------- |
> |        document.getElementById(id)         | 通过id属性的值获取对应的html元素(html元素的id唯一) |
> | document.getElementsByClassName(className) | 通过class属性的值获取对应的html元素数组            |
> |   document.getElementsByTagName(tagName)   | 通过html元素标签获取对应的html元素数组             |
> |      document.getElementsByName(name)      | 通过name属性的值获取对应的html元素数组             |
>
> *可以通过console.log将获取到的html元素打印到控制台，从控制台中查看该元素的全部属性和方法*
>
> **value属性**
>
> **innerHTML属性**
>
> 
>
> **innerText属性**
>
> 

#### setAttribute()

> setAttribute() 方法创建或改变某个新属性。
>
> 如果指定属性已经存在，则只设置该值。
>
> **格式**
>
> ```javascript
> element.setAttribute(attributename, attributevalue);
> ```
>
> - attributename：要添加的属性的名称
> - attributevalue：要添加的属性值
>
> **示例**
>
> ```javascript
> const newNode = createElement("div");
> newNode.setAttribute("class", "city");
> ```

### Date对象

> **使用JS处理日期和时间都围绕一个对象，就是Date对象**
>
> 这个Date对象，实际包含日期和时间
>
> JS内部的时间，是存储自1970.01.01以来的毫秒数(*时间戳*)

#### 创建Date对象

> *注意：node输出的UTC时间，浏览器输出的本地时间。如果使用node直接运行js，需要进行时间转换*
>
> **时间格式转换**
>
> ```javascript
> // 为Date原型添加如下的方法
> Date.prototype.format = function (fmt) {
>     const o = {
>         "M+": this.getMonth() + 1, //月份
>         "d+": this.getDate(), //日
>         "h+": this.getHours(), //小时
>         "m+": this.getMinutes(), //分
>         "s+": this.getSeconds(), //秒
>         "q+": Math.floor((this.getMonth() + 3) / 3), //季度
>         S: this.getMilliseconds(), //毫秒
>     };
>     if (/(y+)/.test(fmt)) {
>         fmt = fmt.replace(
>             RegExp.$1,
>             (this.getFullYear() + "").substr(4 - RegExp.$1.length)
>         );
>     }
>     for (const k in o) {
>         if (new RegExp("(" + k + ")").test(fmt)) {
>             fmt = fmt.replace(
>                 RegExp.$1,
>                 RegExp.$1.length == 1
>                     ? o[k]
>                     : ("00" + o[k]).substr(("" + o[k]).length)
>             );
>         }
>     }
>     return fmt;
> };
> // 转换为"年月日 时分秒"格式
> const time1 = new Date().format("yyyy-MM-dd hh:mm:ss");
> console.log(time1);
> // 获取带毫秒的格式
> const now = new Date().format("hh:mm:ss.S");
> console.log(now);
> // 转换成"年月日"的格式
> const time2 = new Date().format("yyyy-MM-dd");
> console.log(time2);
> ```
>
> **获取当前时间**：new Date();
>
> ```javascript
> const now = new Date();
> ```
>
> **设置指定的时间**：new Date(year, month, day, hours, minutes, seconds, milliseconds);
>
> *注意：Date对象中，月份从0开始计算，所以需要+1才是正确的月份。例如，在设置月份时，如果想设置4月，则输入3*
>
> ```javascript
> const randomDate = new Date(2015, 3, 12, 6, 25, 58);
> console.log(randomDate);
> ```
>
> **设置指定的年月日**：new Date(year, month, day);
>
> ```javascript
> const win95Launch = new Date(1995, 7, 24);
> console.log(win95Launch);
> ```
>
> **单独设置日期时间**
>
> ```javascript
> const now = new Date();
> now.setFullYear(2021);
> now.setMonth(9);
> now.setDate(6);
> console.log(now.format("yyyy-MM-dd")); // 2021-10-06
> ```
>
> |     **方法**      | **描述**                                            |
> | :---------------: | --------------------------------------------------- |
> |     setDate()     | 设置 Date 对象中月的某一天                          |
> |   setFullYear()   | 设置日期对象的年份                                  |
> |    setHours()     | 设置日期对象的小时                                  |
> | setMilliseconds() | 设置日期对象的毫秒数                                |
> |   setMinutes()    | 设置日期对象的分钟数                                |
> |    setMonth()     | 设置日期对象的月份                                  |
> |   setSeconds()    | 设置日期对象的秒数                                  |
> |     setTime()     | 将日期设置为 1970 年 1 月 1 日之后/之前的指定毫秒数 |
>
> **获取需要的日期时间**
>
> ```javascript
> const now = new Date();
> now.setFullYear(2021);
> now.setMonth(9);
> now.setDate(6);
> // 获取时间
> console.log(now.getFullYear()); // 2021
> console.log(now.getMonth()); // 9 实际月份要+1
> console.log(now.getDay()); // 3
> console.log(now.getDate()); // 6
> ```
>
> |     **方法**      | **描述**                                           |
> | :---------------: | -------------------------------------------------- |
> |     getDate()     | 返回月中的第几天（从 1 到 31）                     |
> |     getDay()      | 返回星期几（0-6）                                  |
> |   getFullYear()   | 返回年份                                           |
> |    getHours()     | 返回小时（从 0-23）                                |
> | getMilliseconds() | 返回毫秒（0-999）                                  |
> |   getMinutes()    | 返回分钟（从 0-59）                                |
> |    getMonth()     | 返回月份（从 0-11）                                |
> |   getSeconds()    | 返回秒数（从 0-59）                                |
> |     getTime()     | 返回自 1970 年 1 月 1 日午夜以来与指定日期的毫秒数 |

#### 操作DOM来进行时间每秒更新

> 有两种方法：setTimeout() 和 setInterval()
>
> 推荐使用 setInterval()

##### setTimeout()

> setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式
>
> **格式**
>
> ```javascript
> setTimeout(code,millisec);
> ```
>
> - code：要调用的函数后要执行的 JavaScript 代码串
> - millisec：周期性执行或调用 code 之间的时间间隔，以毫秒计
>
> **示例**
>
> ```javascript
> function show(){
>     //创建日期对象
>     var date = new Date();
>     //获取到年
>     var year = date.getFullYear();
>     //月份从0开始,需要加1
>     var month = date.getMonth()+1;
>     var day = date.getDate();
>     var weeks = new Array("天","一","二","三","四","五","六");
>     //星期
>     var week = date.getDay();
>     var hour = date.getHours();
>     var mi = date.getMinutes();
>     var second = date.getSeconds();
>     document.getElementById("show").innerText = year+"年"+month+"月"+day+"日,星期"+weeks[week]+" "+hour+"时"+mi+"分"+second+"秒";
>     //定时调用,等待指定时间,只调用一次函数
>     setTimeout("show()",999);
> }
> ```
>

##### clearTimeout

> clearTimeout() 方法可取消由 setTimeout() 方法设置的 timeout
>
> **格式**
>
> ```javascript
> clearTimeout(id_of_settimeout)
> ```
>
> - id_of_settimeout：由 setTimeout() 返回的 ID 值。该值标识要取消的延迟执行代码块
>
> **示例**
>
> ```javascript
> let stop = null;
> function show(){
>     //创建日期对象
>     var date = new Date();
>     //获取到年
>     var year = date.getFullYear();
>     //月份从0开始,需要加1
>     var month = date.getMonth()+1;
>     var day = date.getDate();
>     var weeks = new Array("天","一","二","三","四","五","六");
>     //星期
>     var week = date.getDay();
>     var hour = date.getHours();
>     var mi = date.getMinutes();
>     var second = date.getSeconds();
>     document.getElementById("show").innerText = year+"年"+month+"月"+day+"日,星期"+weeks[week]+" "+hour+"时"+mi+"分"+second+"秒";
>     //定时调用,等待指定时间,只调用一次函数
>     stop = setTimeout("show()",999);
> }
> document.getElementById("stop").addEventListener("click", function (){
>     clearTimeout(stop);
> });
> ```

##### setInterval()

> setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。
>
> setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。
>
> **格式**
>
> ```javascript
> setInterval(code, millisec[,"lang"]);
> ```
>
> - code：要调用的函数或要执行的代码串
> - millisec：周期性执行或调用 code 之间的时间间隔，以毫秒计
>
> **示例**
>
> ```javascript
> function show(){
>     //创建日期对象
>     var date = new Date();
>     //获取到年
>     var year = date.getFullYear();
>     //月份从0开始,需要加1
>     var month = date.getMonth()+1;
>     var day = date.getDate();
>     var weeks = new Array("天","一","二","三","四","五","六");
>     //星期
>     var week = date.getDay();
>     var hour = date.getHours();
>     var mi = date.getMinutes();
>     var second = date.getSeconds();
>     document.getElementById("show").innerText = year+"年"+month+"月"+day+"日,星期"+weeks[week]+" "+hour+"时"+mi+"分"+second+"秒";
> }
> setInterval("show()", 999);
> ```
>
> *注意：setInterval() 如果放在方法中,会创建出多个定时调用函数*

##### clearInterval()

> clearInterval() 方法可取消由 setInterval() 设置的 timeout。
>
> clearInterval() 方法的参数必须是由 setInterval() 返回的 ID 值
>
> **格式**
>
> ```javascript
> clearInterval(id_of_setinterval)
> ```
>
> - id_of_setinterval：由 setInterval() 返回的 ID 值
>
> **示例**
>
> ```javascript
> function show(){
>     //创建日期对象
>     var date = new Date();
>     //获取到年
>     var year = date.getFullYear();
>     //月份从0开始,需要加1
>     var month = date.getMonth()+1;
>     var day = date.getDate();
>     var weeks = new Array("天","一","二","三","四","五","六");
>     //星期
>     var week = date.getDay();
>     var hour = date.getHours();
>     var mi = date.getMinutes();
>     var second = date.getSeconds();
>     document.getElementById("show").innerText = year+"年"+month+"月"+day+"日,星期"+weeks[week]+" "+hour+"时"+mi+"分"+second+"秒";
> }
> const stop = setInterval("show()",999);
> document.getElementById("stop").addEventListener("click", function (){
>     clearInterval(stop);
> });
> ```

### 正则表达式(未完成)

> 

#### 部分常用正则表达式

##### 匹配手机号

> **严格匹配**
>
> ```javascript
> const reg = /^[1](([3][0-9])|([4][5-9])|([5][0-3,5-9])|([6][5,6])|([7][0-8])|([8][0-9])|([9][1,8,9]))[0-9]{8}$/;
> ```
>
> **放宽部分限制**
>
> ```javascript
> const reg = /^[1]([3-9])[0-9]{9}$/;
> ```

##### 匹配密码

> **密码长度大于6位，必须包含数字和字母**
>
> ```javascript
> const reg = /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{6,}$/;
> ```
>
> **密码长度大于8位，可以为纯数字或字母**
>
> ```javascript
> const reg = /^[a-zA-Z\d_]{8,}$/;
> ```
>
> **只匹配各种特殊字符**
>
> ```javascript
> const reg = /[`~!@#$%^&*()_\-+=<>?:"{}|,.\/;'\\[\]·~！@#￥%……&*（）——\-+={}|《》？：“”【】、；‘’，。、]/im;
> ```
>
> **匹配密码长度8~16位，包含数字字母和特殊字符**
>
> ```javascript
> const reg = /^[a-zA-Z\d_`~!@#$%^&*()_\-+=<>?:"{}|,.\/;'\\[\]·~！@#￥%……&*（）——\-+={}|《》？：“”【】、；‘’，。、]{8,16}$/;
> ```

##### 匹配邮箱

> **匹配Email地址，必须包含@**
>
> ```javascript
> ^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
> ```
>

## JQuery(未完成)

> 

### $(document).ready()

> 文档就绪事件
>
> **格式**
>
> ```javascript
> $(document).ready(function(){
>    // 开始写 jQuery 代码...
> });
> ```
>
> 该方法允许我们在文档完全加载完后执行函数
>
> 为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。jQuery 函数应写在 document ready 函数中
>
> 如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子：
>
> - 试图隐藏一个不存在的元素
> - 获得未完全加载的图像的大小
>
> **简洁写法**
>
> ```javascript
> $(function(){
>    // 开始写 jQuery 代码...
> });
> ```
>
> 两种写法效果相同

### JQuery中的选择器(未完成)

> [1](#cssTable)

### JQuery获取元素

#### JQuery获取父子元素

> **获得父元素**
>
> parent() 获得当前匹配元素集合中每个元素的父元素，使用选择器进行筛选是可选的
>
> ```javascript
> $("element").parent(selector);
> ```
>
> - selector：字符串值，包含用于匹配元素的选择器表达式
>
> **获得子元素**
>
> ```javascript
> $("element").children(selector);
> ```
>
> *children()的()内可以写字符串值来匹配元素的选择器表达式；也可以不写，表示匹配指定元素下的所有子元素*

#### JQuery获取同级元素

> 在jquery中，获得同级元素的方法一般有七个，分别是siblings()、next()、nextAll()、nextUntil()、prev()、prevAll()、prevUntil()

##### siblings

> **说明**
>
> siblings()方法，主要用于获得指定元素的同级所有元素
>
> *siblings()方法方法获取的元素包含指定元素之前的所有同辈元素*
>
> **格式**
>
> ```javascript
> $("element").siblings();
> ```
>

##### next

> **说明**
>
> next()方法，主要用于获得指定元素的下一个同级元素
>
> **格式**
>
> ```javascript
> $("element").next();
> ```
>

##### nextAll

> **说明**
>
> nextAll()方法，主要用于获得指定元素的下一个同级的所有元素
>
> *nextAll()方法获取的元素不包含指定元素之前的同辈元素*
>
> **格式**
>
> ```javascript
> $("element").nextAll();
> ```
>

##### nextUntil

> **说明**
>
> nextUntil()方法，主要用于获得指定元素的下一个同级元素，这个同级元素必须为指定元素与nextUntil()方法所设置元素之间的元素
>
> **格式**
>
> ```javascript
> $("element1").nextUntil("element2");
> ```
>

##### prev

> **说明**
>
> prev()方法，主要用于获得指定元素的上一级同级元素
>
> **格式**
>
> ```javascript
> $("element1").prev("element2");
> ```
>

##### prevAll

> **说明**
>
> prevAll()方法，主要用于获得指定元素上一级所有的同级元素
>
> **格式**
>
> ```javascript
> $("element1").prevAll();
> ```
>

##### prevUntil

> **说明**
>
> prevUntil()方法，主要用于获得指定元素的上一个同级元素，这个同级元素必须为指定元素与prevUntil()方法所设置元素之间的元素
>
> **格式**
>
> ```javascript
> $("element1").prevUntil("element2");
> ```
>

### JQuery添加dom元素的方式

> 可以分为俩类
>
> - **相对于父元素插入位置**
> - **相对于兄弟元素插入位置**

#### 相对于父元素插入位置

> **父元素的第一孩子元素**
>
> ```javascript
> $('parent').prepend('child')   // parent 和 child 分别代表 父元素和要插入子元素
> ```
>
> **父元素的最后一孩子元素**
>
> ```javascript
> $('parent').append('child')   // parent 和 child 分别代表 父元素和要插入子元素
> ```

#### 相对于兄弟元素插入位置

> **插入到兄弟元素前面**
>
> ```javascript
> $('child'). before('brother')   // child 和 brother 分别代表 要插入的子元素和 兄弟元素
> ```
>
> **插入到兄弟元素后面**
>
> ```javascript
> $('child').after('brother')   // child 和 brother 分别代表 要插入的子元素和 兄弟元素
> ```

### JQuery中的事件

> JQuery 是为事件处理特别设计的
>
> JQuery 事件是对 JavaScript 事件的封装，常用事件分类
>
> - 基础事件
>   - [鼠标事件](#mouse)
>   - [键盘事件](#keybord)
>   - [表单事件](#from)
>   - [文档/窗口事件](#window)
>
> - 复合事件
>   - [hover](#hover)
>   - [toggle](#toggle)

#### <span id="mouse">鼠标事件</span>

##### click

> 当单击元素时，发生 click 事件
>
> click() 方法触发 click 事件，或规定当发生 click 事件时运行的函数
>
> **格式**
>
> 触发被选元素的 click 事件
>
> ```javascript
> $(selector).click()
> ```
>
> 添加函数到 click 事件
>
> ```javascript
> $(selector).click(function)
> ```

##### dblclick

> 当双击元素时，触发 dblclick 事件
>
> dblclick() 方法触发 dblclick 事件，或规定当发生 dblclick 事件时运行的函数。
>
> *注意：dblclick 事件也会产生 click 事件。如果这两个事件都被应用于同一个元素，则会产生问题。*
>
> **格式**
>
> 触发被选元素的 dblclick 事件
>
> ```javascript
> $(selector).dblclick();
> ```
>
> 添加函数到 dblclick 事件
>
> ```javascript
> $(selector).dblclick(function);
> ```

##### mouseover

> 当鼠标指针位于元素上方时，会发生 mouseover 事件
>
> mouseover() 方法触发 mouseover 事件，或添加当发生 mouseover 事件时运行的函数
>
> **格式**
>
> 触发被选元素的 mouseover 事件
>
> ```javascript
> $(selector).mouseover();
> ```
>
> 添加函数到 mouseover 事件
>
> ```javascript
> $(selector).mouseover(function);
> ```

##### mouseout

> 当鼠标指针离开被选元素时，会发生 mouseout 事件
>
> mouseout() 方法触发 mouseout 事件，或添加当发生 mouseout 事件时运行的函数
>
> **格式**
>
> 触发被选元素的 mouseout 事件
>
> ```javascript
> $(selector).mouseout();
> ```
>
> 添加函数到 mouseout 事件
>
> ```javascript
> $(selector).mouseout(function);
> ```

#### <span id="keybord">键盘事件</span>

> **键盘事件发生的顺序**
>
> 1. keydown - 键按下的过程
> 2. keypress - 键被按下
> 3. keyup - 键被松开

##### keydown

> 当键盘键被按下时发生 keydown 事件
>
> keydown() 方法触发 keydown 事件，或规定当发生 keydown 事件时运行的函数
>
> **格式**
>
> 触发被选元素的 keydown 事件
>
> ```javascript
> $(selector).keydown()
> ```
>
> 添加函数到 keydown 事件
>
> ```javascript
> $(selector).keydown(function)
> ```

##### keyup

> 当键盘键被松开时发生 keyup 事件。
>
> keyup() 方法触发 keyup 事件，或规定当发生 keyup 事件时运行的函数
>
> **格式**
>
> 触发被选元素的 keyup 事件
>
> ```javascript
> $(selector).keyup()
> ```
>
> 添加函数到 keyup 事件
>
> ```javascript
> $(selector).keyup(function)
> ```

##### keypress

> keypress() 方法触发 keypress 事件，或规定当发生 keypress 事件时运行的函数。
>
> keypress 事件与 keydown 事件类似。当按钮被按下时发生该事件。
>
> 然而，keypress 事件不会触发所有的键（比如 ALT、CTRL、SHIFT、ESC）。请使用 keydown() 方法来检查这些键。
>
> **格式**
>
> 触发被选元素的 keypress 事件
>
> ```javascript
> $(selector).keypress();
> ```
>
> 添加函数到 keypress 事件
>
> ```javascript
> $(selector).keypress(function);
> ```

#### <span id="from">表单事件</span>

##### submit

> 当提交表单时，会发生 submit 事件。
>
> 该事件只适用于 <form> 元素。
>
> submit() 方法触发 submit 事件，或规定当发生 submit 事件时运行的函数
>
> **格式**
>
> 触发被选元素的 submit 事件
>
> ```javascript
> $(selector).submit()
> ```
>
> 添加函数到 submit 事件
>
> ```javascript
> $(selector).submit(function)
> ```
>
> **示例**
>
> ```javascript
>  $("#myform").submit(function () {
>      const name = $("[name=username]").val();
>      if (!/^[A-Z]\w{0,29}$/.test(name)) {
>          alert("用户名首字母大写,只能是字符");
>          $("[name=username]").focus();
>          //直接阻断表单提交,只有return true时,表单提交
>          return false;
>      }
>      $("#myform").submit();
>  });
> ```

##### change

> 当元素的值改变时发生 change 事件（仅适用于表单字段）
>
> change() 方法触发 change 事件，或规定当发生 change 事件时运行的函数
>
> *注意：当用于 select 元素时，change 事件会在选择某个选项时发生。当用于 text field 或 text area 时，change 事件会在元素失去焦点时发生*
>
> **格式**
>
> 触发被选元素的 change 事件
>
> ```javascript
> $(selector).change();
> ```
>
> 添加函数到 change 事件
>
> ```javascript
> $(selector).change(function);
> ```

##### focus

> 当元素获得焦点时（当通过鼠标点击选中元素或通过 tab 键定位到元素时），发生 focus 事件
>
> focus() 方法触发 focus 事件，或规定当发生 focus 事件时运行的函数
>
> **格式**
>
> 触发被选元素的 focus 事件
>
> ```javascript
> $(selector).focus()
> ```
>
> 添加函数到 focus 事件
>
> ```javascript
> $(selector).focus(function)
> ```

##### blur

> 当元素失去焦点时发生 blur 事件
>
> blur() 方法触发 blur 事件，或规定当发生 blur 事件时运行的函数
>
> **格式**
>
> 为被选元素触发 blur 事件
>
> ```javascript
> $(selector).blur()
> ```
>
> 添加函数到 blur 事件
>
> ```javascript
> $(selector).blur(function)
> ```

#### <span id="window">文档/窗口事件</span>

##### load

> **load() 方法在 jQuery 版本 1.8 中已废弃**
>
> load() 方法添加事件处理程序到 load 事件。
>
> 当指定的元素已加载时，会发生 load 事件。
>
> 该事件适用于任何带有 URL 的元素（比如图像、脚本、框架、内联框架）以及 window 对象。
>
> 根据不同的浏览器（Firefox 和 IE），如果图像已被缓存，则也许不会触发 load 事件。
>
> **注意：**还存在一个名为 load() 的 jQuery AJAX 方法。根据不同的参数决定调用哪个方法
>
> **格式**
>
> ```javascript
> $(selector).load(function)
> ```
>

##### resize

> 当调整浏览器窗口大小时，发生 resize 事件
>
> resize() 方法触发 resize 事件，或规定当发生 resize 事件时运行的函数
>
> **格式**
>
> 触发被选元素的 resize 事件
>
> ```javascript
> $(selector).resize()
> ```
>
> 添加函数到 resize 事件
>
> ```javascript
> $(selector).resize(function) 
> ```
>

##### scroll

> 当用户滚动指定的元素时，会发生 scroll 事件
>
> scroll 事件适用于所有可滚动的元素和 window 对象（浏览器窗口）
>
> scroll() 方法触发 scroll 事件，或规定当发生 scroll 事件时运行的函数
>
> **格式**
>
> 触发被选元素的 scroll 事件
>
> ```javascript
> $(selector).scroll()
> ```
>
> 添加函数到 scroll 事件
>
> ```javascript
> $(selector).scroll(function)
> ```
>

##### unload

> **unload() 方法在 jQuery 版本 1.8 中被废弃，在 3.0 版本被移除**
>
> **Firefox 与 Chrome 会阻止弹窗，所以没办法看到效果**
>
> 当用户离开页面时，会发生 unload 事件
>
> 当发生以下情况下，会触发 unload 事件：
>
> - 点击某个离开页面的链接
> - 在地址栏中键入了新的 URL
> - 使用前进或后退按钮
> - 关闭浏览器窗口
> - 重新加载页面
>
> unload() 方法规定当 unload 事件发生时会发生什么
>
> unload() 方法只应用于 window 对象
>
> **注意：**unload 事件在不同浏览器中效果不一样，请确保使用前在所有浏览器测试该方法
>
> **格式**
>
> ```javascript
> $(selector).unload(function)
> ```
>

#### 复合事件

> **所谓复合事件，是相对单一事件而言的，就是一组事件的组合**
>
> 例如：下拉菜单，我们就可以采用鼠标移入和鼠标移出2个事件的组合来实现，当鼠标移入时就显示下拉菜单，当移出时就隐藏下拉菜单

##### <span id="hover">hover</span>

> hover() 方法规定当鼠标指针悬停在被选元素上时要运行的两个函数。
>
> 方法触发 mouseenter 和 mouseleave 事件。
>
> 注意: 如果只指定一个函数，则 mouseenter 和 mouseleave 都执行它
>
> **语法**
>
> ```javascript
> $(selector).hover(inFunction,outFunction);
> ```
>
> **示例**
>
> ```javascript
> $(".nav-ul a").hover(function(){
>     $(this).css("background-color","#f01e28");
> },function(){
>     $(this).css("background-color","#ff2832");
> });
> ```

##### <span id="toggle">toggle</span>

> toggle() 方法添加两个或多个函数，以响应被选元素的 click 事件之间的切换。
>
> 当在元素上点击时调用第一个指定函数，当再次点击时调用第二个函数，以此类推
>
> *toggle() 方法在 jQuery 版本 1.8 中被废弃，在版本 1.9 中被移除*
>
> **语法**
>
> ```javascript
> $(selector).toggle(function)
> ```
>
> - function：每当被选元素被点击时要运行的函数
>
> **示例1**
>
> ```javascript
> $("#change").toggle(
>     function() {
>         $("#img1").attr("src", "img/list1.jpg");
>     },
>     function() {
>         $("#img1").attr("src", "img/list2.jpg");
>     },
>     function() {
>         $("#img1").attr("src", "img/list3.jpg");
>     },
>     function() {
>         $("#img1").attr("src", "img/list0.jpg");
>     }
> );
> ```
>
> **示例2**
>
> ```javascript
> $("#change").click(function() {
>     $("#img2").toggle();
> })
> ```

#### 事件的绑定与解除绑定

> **bind**
>
> bind() 方法为被选元素添加一个或多个事件处理程序，并规定事件发生时运行的函数
>
> *格式*
>
> ```javascript
> $(selector).bind(event,data,function);
> ```
>
> - event：必需。规定添加到元素的一个或多个事件
>   - 由空格分隔多个事件。必须是有效的事件
> - data：可选。规定传递到函数的额外数据
> - function：必需。规定当事件发生时运行的函数
>
> *示例*
>
> ```javascript
> $("#nav li:first").bind("click",content=function(){
>     $("#dayTask").show();
>     $("#growTask").hide();
> });
> ```
>
> **unbind**
>
> unbind() 方法移除被选元素的事件处理程序。
>
> 该方法能够移除所有的或被选的事件处理程序，或者当事件发生时终止指定函数的运行。
>
> ubind() 适用于任何通过 jQuery 附加的事件处理程序。
>
> *格式*
>
> ```javascript
> $(selector).unbind(event,function);
> ```
>
> - event：可选。规定删除元素的一个或多个事件
>   - 由空格分隔多个事件值。
>   - 如果只规定了该参数，则会删除绑定到指定事件的所有函数。
> - function：可选。规定从元素的指定事件取消绑定的函数名。
>
> *示例*
>
> ```javascript
> $("#del").click(function(){
> 	$("#nav li:first").unbind("click",content);
> }
> ```

### JQuery中this与$(this)的区别

> ```javascript
> $("#textbox").hover(   
>  function() {   
>      this.title = "Test";   
>  },   
>  function() {   
>  	this.title = "OK”;   
>  }   
> ); 
> ```
>
> 这里的 this 其实是一个`html`元素`textbox`，`textbox`有`text`属性，所以这样写是完全没有什么问题的。 
> 但是如果将 this 换成 $(this) 就不是那回事了，报Error了。this 与 \$(this) 的区别在此。
>
> ```javascript
> // Error Code：   
> $("#textbox").hover(   
>  function() {   
>      $(this).title ＝ "Test";   
>  },   
>  function() {   
>      $(this).title = "OK";   
>  }   
> ); 
> ```
>
> $()这是jQuery的一个函数，也是最核心最基本的函数
>
> 功能一：传入一个选择器字符串，获得这个选择器对应的dom内容，保存在[]中，也就是俗称的jQuery对象。例如
>
> ('#id')(‘.class’) $(‘tag’) 
> 功能二：传入一个匿名函数，例如
>
> $(function(){})//这个匿名函数在网页载入完成后开始执行 
> 功能三：将JavaScript对象包装成为jQuery对象。例如
>
> ```javascript
> $(this)
> $({a:1,b:2,c:3})
> $(document.getElementById('idstr'))
> ```
>
> this 是 javascript**自身的**语法关键字，它指向一个 javascript 对象，所以可以使用所指向的目标 javascript 对象所拥有的方法, 但他自己不是一个普通的变量，所以你无法自己定义一个变量叫 this
>
> 所以为了使用 jQuery 对象的方法，你必须传入 jQuery 函数 $(this) ，将 javascript 对象包装成为一个 jquery 对象。
>
> 这里的 $(this) 是一个 JQuery 对象，而 JQuery 对象沒有 title 属性，因此这样写是错误的。
>
> JQuery 拥有 attr() 方法可以 get/set DOM对象的属性，所以正确的写法应该是这样：
>
> 正确的代码：
>
> ```javascript
> $("#textbox").hover(   
>  function() {   
>      $(this).attr(’title’, ‘Test’);   
>  },   
>  function() {   
>      $(this).attr(’title’, ‘OK’);   
>  }   
> ); 
> ```
>
> 使用 JQuery 的好处是它包裝了各种浏览器版本对 DOM 对象的操作，因此统一使用 $(this) 而不再用 this 应该是比较不错的选择。
>
> 

#### Jquery 里 $(this).val(); 与 this.value 的区别

> **$(this).val(); **
>
> 有四个重载版本
>
> - val() 获得第一个匹配元素的当前值。
>
> - val(array) check,select,radio等都能使用为之赋值
>
> - val(function(index, value)) 设置每一个匹配元素的值。
>
> - val(val) 设置每一个匹配元素的值。
>
> **this.value**
>
> 获取 dom对象的值 如 text radio checkbox select 等 

### JQuery实现表单的验证和提交

> **HTML**
>
> ```html
> <html>
>     <head>
>         <meta charset="utf-8" />
>         <title>二级联动</title>
>         <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js"></script>
>         <script src="./index.js" type="text/javascript"></script>
>     </head>
>     <body>
>         <div id="first">
>             <form action="淘宝.html" id="myform" method="post">
>                 <table>
>                     <caption>
>                         <tr>
>                             <td colspan="2">
>                                 <h3>用户注册</h3>
>                             </td>
>                         </tr>
>                     </caption>
>                     <tr>
>                         <td align="right"></td>
>                         <td></td>
>                     </tr>
>                     <tr>
>                         <td align="right">用户名:</td>
>                         <td>
>                             <input
>                                 type="text"
>                                 name="username"
>                                 placeholder="请输入文本内容"
>                             />
>                         </td>
>                     </tr>
>                     <tr>
>                         <td align="right">密码:</td>
>                         <td>
>                             <input
>                                 type="password"
>                                 name="pwd"
>                                 id="pwd"
>                                 placeholder="请输入密码"
>                             />
>                         </td>
>                     </tr>
>                     <tr>
>                         <td align="right">确认密码:</td>
>                         <td><input type="password" name="pwd1" id="pwd1" /></td>
>                     </tr>
>                     <tr>
>                         <td align="right">头像:</td>
>                         <td><input type="file" name="file" /></td>
>                     </tr>
>                     <tr>
>                         <td align="right">性别:</td>
>                         <td>
>                             <input
>                                 type="radio"
>                                 name="sex"
>                                 value="男"
>                                 checked
>                             />男&nbsp;
>                             <input type="radio" name="sex" value="女" />女
>                         </td>
>                     </tr>
>                     <tr>
>                         <td align="right">爱好:</td>
>                         <td>
>                             <input
>                                 type="checkbox"
>                                 name="hobby"
>                                 checked
>                                 value="篮球"
>                             />篮球
>                             <input
>                                 type="checkbox"
>                                 name="hobby"
>                                 value="排球"
>                             />排球
>                             <input
>                                 type="checkbox"
>                                 name="hobby"
>                                 value="乒乓球"
>                             />乒乓球
>                         </td>
>                     </tr>
>                     <tr>
>                         <td align="right">出生日期:</td>
>                         <td><input type="date" name="birth" /></td>
>                     </tr>
>                     <tr>
>                         <td align="right">联系电话:</td>
>                         <td><input type="tel" name="phone" id="phone" /></td>
>                     </tr>
>                     <tr>
>                         <td align="right">电子邮箱:</td>
>                         <td><input type="email" name="mail" id="mail" /></td>
>                     </tr>
>                     <tr>
>                         <td align="right">出生地址:</td>
>                         <!--this.options.selectedIndex 表示为下拉框选中项的下标  -->
>                         <td>
>                             <select
>                                 name="pre"
>                                 size="1"
>                                 id="c1"
>                                 onchange="changeCity(this.options.selectedIndex)"
>                             >
>                                 <!-- value值是以后提交表单传入到服务器的数据,
> 							一般value值是显示值的主键id -->
>                                 <option value="0">请选择</option>
>                                 <option value="1">广东</option>
>                                 <option value="2">广西</option>
>                                 <option value="3">湖南</option>
>                                 <option value="4">湖北</option></select
>                             >省&nbsp;&nbsp;<select name="city" id="c2">
>                                 <option value="0">请选择</option></select
>                             >市
>                         </td>
>                     </tr>
>                     <tr>
>                         <td align="right">阅读协议:</td>
>                         <td>
>                             <textarea
>                                 rows="5"
>                                 cols="20"
>                                 readonly="readonly"
>                                 id="txte"
>                                 style="display: none"
>                             >
> 						撒娇福利卡飞机的洒的发生的垃圾分类卡三等奖疯狂老爹萨科技吉林省大姐夫离开大水井坊接待来访撒酒疯了快递撒酒疯几率大设计费拉萨的空间
> 					</textarea
>                             ><a href="javascript:" id="read">阅读协议</a
>                             ><input type="checkbox" name="ok" id="ok" />同意
>                         </td>
>                     </tr>
>                     <tr>
>                         <td colspan="2">
>                             <input
>                                 type="submit"
>                                 id="subbtn"
>                                 disabled="disabled"
>                             />&nbsp;&nbsp;<input type="reset" />
>                         </td>
>                     </tr>
>                 </table>
>             </form>
>         </div>
>     </body>
> </html>
> ```
>
> **JS**
>
> ```javascript
> //初始化数据
> const city = [
>     ["广州", "深圳", "珠海", "东莞", "佛山", "惠州", "江门"],
>     ["南宁", "桂林", "玉林", "贺州"],
>     ["长沙", "衡阳", "株洲", "常德"],
>     ["武汉", "仙桃", "黄冈", "恩施", "襄阳"],
> ];
> 
> function changeCity(index) {
>     //获取二级联动对象
>     const c2 = document.getElementById("c2");
>     //重新初始化二级菜单的长度
>     c2.length = 1;
>     //判断获取到省的下标不得为0
>     if (index != 0) {
>         //循环遍历省对应的二维数组
>         for (let i = 0; i < city[index - 1].length; i++) {
>             //获取到对应的市,并放入到二级联动的option中
>             //下拉框中的项是options
>             c2.options[i + 1] = new Option(city[index - 1][i]);
>         }
>     } else {
>         c2.options[0].selected = true;
>     }
> }
> $(function () {
>     $("#pwd").blur(function () {
>         const pwd = this.value;
>         const reg = /^\d{6,20}$/;
>         if (!reg.test(pwd)) {
>             alert("密码在6-20位,且只能是数字");
>         } else {
>             alert("密码可以使用");
>         }
>     });
>     $("#pwd1").blur(function () {
>         const pwd = $("#pwd").val();
>         const pwd1 = this.value;
>         if (pwd != pwd1) {
>             alert("两次输入的密码不一致");
>         }
>     });
>     $("#read").click(function () {
>         $("#txte").toggle();
>     });
>     $("#ok").click(function () {
>         if (this.checked) {
>             //jquery中没有disabled的处理方法,需要转换为js处理
>             $("#subbtn")[0].disabled = false;
>         } else {
>             $("#subbtn")[0].disabled = "disabled";
>         }
>     });
>     //认证表单,验证数据是否完全符合要求
>     $("#myform").submit(function () {
>         const name = $("[name=username]").val();
>         if (!/^[A-Z]\w{0,29}$/.test(name)) {
>             alert("用户名首字母大写,只能是字符");
>             $("[name=username]").focus();
>             //直接阻断表单提交,只有return true时,表单提交
>             return false;
>         }
>         $("#myform").submit();
>     });
> 
> function checkPhone() {
>  const phone = document.getElementById("phone").value;
>     const reg = /^0\d{2,3}-\d{8}$/;
>     if (!reg.test(phone)) {
>         alert("电话号码不正确,区号加号码");
>     }
>    }
> 
> function checkEmail() {
>  const email = document.getElementById("mail").value;
>     const reg = /^\w+@[a-zA-Z0-9]{2,6}(\.[a-zA-Z]+)+$/;
>     if (reg.test(email)) alert("邮箱可以使用");
>     else alert("邮箱名有问题");
>    }
> 
> function che() {
>  const ok = document.getElementById("ok");
>     if (ok.checked) {
>         document.getElementById("subbtn").disabled = false;
>     } else {
>         document.getElementById("subbtn").disabled = "disabled";
>     }
>    }
> ```

## AJAX(未完成)

> **概述**
>
> Ajax 即 Asynchronous Javascript And XML（异步JavaScript和XML）
>
> 在 2005年被Jesse James Garrett提出的新术语，用来描述一种使用现有技术集合的 '新' 方法，包括: HTML 或 XHTML, CSS, JavaScript, DOM, XML, XSLT, 以及最重要的XMLHttpRequest
>
> 使用Ajax技术网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面，这使得程序能够更快地回应用户的操作
>
> **工作原理**
>
> Ajax 的工作原理相当于在用户和服务器之间加了—个中间层( AJAX 引擎)，使用户操作与服务器响应异步化
>
> 并不是所有的用户请求都提交给服务器。像—些数据验证和数据处理等都交给 Ajax 引擎自己来做,，只有确定需要从服务器读取新数据时再由 Ajax 引擎代为向服务器提交请求
>
> **请求和响应**
>
> *ajax 提交的请求的响应数据由ajax的回调函数接收*
>
> *form 表单提交的请求的响应数据直接打印在页面上*

### AJAX和JSP的区别

> **ajax的优点**
>
> - 开发过程中前端与后端脱离，交互通过JSON传输来实现
> - 跨平台能力更强，依托于浏览器的支持
> - 使后台数据接口能够得到复用
>
> **ajax的缺点**
>
> - 开发难度大，考虑浏览器的兼容性
> - 页面请求过多
> - 属于后加载，无法被爬虫爬到
> - 接口代码需要新增很多
> - 无法直接显示 java 实体类对象，需要转换为 json 格式
>
> **jsp的优点**
>
> - 可被爬虫爬到
> - 减少请求次数
> - 不用考虑浏览器的兼容性
>
> **jsp的缺点**
>
> - 增大了服务器的压力
> - 前端与后端未脱离，拖慢开发进度
> - 过于依赖java运行环境
> - 复用较低

### AJAX发送请求到后端

> **JS实现**
>
> ```javascript
> // 创建 ajax 对象
> const ajax = new XMLHttpRequest();
> // 设置 ajax 的响应动作
> ajax.onreadystatechange = function () {
>     if(ajax.status===200&&ajax.readyState===4){
>         console.log(ajax);
>     }
> }
> function send() {
>     // 设置 ajax 的提交方式，提交的接口
>     ajax.open('post', 'timeservlet');
>     // 如果有值 从send发送
>     // ajax.send(data);
>     // 木有值 直接发送即可
>     ajax.send();
> }
> ```
>
> **JQuery实现**
>
> ```javascript
> 
> ```
>
> 

## Json

> **概述**
>
> JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率
>
> **格式**
>
> - json字符串都要有双引号，数字不需要双引号；key都要用双引号
> - json不认单引号，只认双引号
> - key:value结构要用**{}**,能清晰表达对象的含义
> - json最终要求是一个整体(最外层必须要是**[]**或是**{}**)
> - json—定是要求key-value的(如果有多个**json**对象，最外层要么使用**[]**；要么给每个**json**对象添加上**key**后，再使用**{}**)
> - 
>
> **示例**
>
> 最外层是**[]**
>
> ```json
> [{
>     "id": 1,
>     "name": "张三",
>     "age": 23,
>     "score": 88
> },{
>     "id": 2,
>     "name": "王五",
>     "age": 23,
>     "score": 88
> }]
> ```
>
> 最外层是**{}**
>
> ```json
> {
>     "stu1":{
>         "id": 1,
>         "name": "张三",
>         "age": 23,
>         "score": 88
>     },
>     "stu2":{
>         "id": 2,
>         "name": "王五",
>         "age": 23,
>         "score": 88
>     }
> }
> ```

## TypeScript

> **简介**
>
> TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准
>
> TypeScript 由微软开发的自由和开源的编程语言
>
> TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上
>
> **安装**
>
> node安装：**npm install -g typescript**
>
> **运行**
>
> ts编译为js：**tsc ts文件名**，生成对应文件名的 js 文件
>
> 在命令行上，通过 Node.js 运行这段代码：
>
> **node ts文件名.js**

### 基本类型

#### 布尔值

> **boolean**
>
> ```typescript
> let bool: boolean
> bool = true;
> bool = 123; // error,不能将123类型分配给‘boolean’
> ```

#### 数值

> **number**
>
> ```typescript
> let num: number = 123;
> num = '123' // error,不能将'123'类型分配给’number‘
> num = 0xff; // 十六进制
> num = 0o77; // 八进制
> num = 0b11; // 二进制

#### 字符串

> **string**
>
> ```typescript
> const bool: boolean = true;
> const num: number = 123;
> let str: string;
> str = 'abc';
> // bsStr = true; //不能将类型“boolean”分配给类型“string”。
> str = `the num is ${num}, the bool is ${bool}`;

#### 数组

> **array**
>
> *写法一*
>
> ```typescript
> let arr: number[];
> arr = [1, 2, 3];
> ```
>
> *写法二*
>
> ```typescript
> let arr: Array<number>
> arr = [1, 2, 3];
> ```

#### 联合类型和交叉类型

##### 联合类型 |

> **概述**
>
> 指多个类型的合并类型
>
> **基础类型联合**
>
> ```typescript
> let a: string | number;
> a = 1; //ok 
> a= "a"//ok
> 
> // 数组使用联合类型
> let arr1: (number | string)[];
> let arr2: Array<number | string>;
> arr1 = arr2 = ['1', 2, '3'];
> ```
>
> **对象类型联合**
>  对象联合类型只能访问联合中所有共同成员
>
> ```typescript
> interface Women{
>   age: number,
>   sex: string,
>   cry(): void
> }
> 
> interface Man{
>   age: number,
>   sex: string,
> }
> 
> declare function People(): Women | Man;
> let people = People();
> people.age = 18; //ok
> people.cry();//error 非共同成员
> ```

##### 交叉类型 &

> **概述**
>
> 多种类型的集合，联合对象将具有所联合类型的所有成员
>
> **示例**
>
> ```typescript
> interface People {
>   age: number,
>   height： number
> }
> 
> interface Man{
>   sex: string
> }
> 
> const lilei = (man: People & Man) => {
>   console.log(man.age)
>   console.log(man.height)
>   console.log(man.sex)
> }
> 
> lilei({age: 18,height: 180,sex: 'male'});
> ```

#### 元组

> **tuple**
>
> 数组合并相同类型的对象，而元祖（Tuple）合并了不同类型的对象
> 元组可以属于理解成一个任意类型并且长度有限的数组
>
> ```typescript
> let tuple: [string, number, string, Array<string>];
> tuple = ['1', 2, '3', ['4', '5']]
> ```
>
> - 元祖类型赋值数组的长度必须和定义的长度相同
>   - 实例中定义了长度为 4 的元祖数组，那么赋值时也必须要赋值 4 个值，且每个值的类型要与定义的一一对应

#### 枚举值

> **enum**
>
> 自增序列号 默认从0开始自增
>
> 只指定某一个的话，之前的还按照从0自增，之后按照定义值自增
>
> ```typescript
> enum BsRoles {
>     SUPER_ADMIN, // 序列号: 0
>     ADMIN = 3, // 序列号: 3
>     USER // 序列号: 4
> }

##### ts 枚举(enum) 中的类型操作技巧

> **枚举值样例**
>
> ```typescript
> enum Status {
>   SUCCESS = 'success',
>   DANGER = 'danger',
>   WARNING = 'warning',
> }
> ```

###### 获取枚举的 key 类型

> ```typescript
> type StatusKey = keyof typeof Status; 
> // 'SUCCESS' | 'DANGER' | 'WARNING'
> 
> const keyArr: StatusKey[] = ['SUCCESS', 'DANGER']; // passed
> ```

###### 获取枚举的 value 类型

> ```typescript
> type StatusVal = `${Status}`;
> // 'success' | 'danger' | 'warning'
> 
> const valArr: StatusVal[] = ['success', 'danger', 'warning'];  // passed
> ```

###### 合并枚举类型

> ```typescript
> enum Wait {
>   WAITING = 'waiting',
> }
> 
> const merge = { ...Status, ...Wait };
> type MergeStatus = typeof merge;
> 
> const s1 = MergeStatus.WAITING; // warning
> const s2 = MergeStatus.SUCCESS; // success
> const s3 = MergeStatus.DANGER; // danger
> const s4 = MergeStatus.WARNING; // warning
> ```

###### 使用 Exclude 剔除枚举中的值

> ```typescript
> type ErrStatus = Exclude<Status, Status.SUCCESS>;
> 
> let a: ErrStatus = Status.DANGER; // passed
> a = Status.WARNING;  // passed
> a = Status.SUCCESS;  // error
> ```

#### any

> **any(任意类型)**
>
> ```typescript
> let bsValue: any;
> bsValue = 'abc';
> bsValue = 123;
> bsValue = [1, '2', { a: '3', b: true }]
> ```

#### void

> **void(无类型)**
>
> ```typescript
> const bsTest1 = (text: string): void => {
>     console.log(text);
> }
> let bsV: void;
> bsV = undefined;
> // 开启严格检查将会报错  "strict": true
> bsV = null;

#### null和undefined

> **undefined**
>
> ```typescript
> let bsU: undefined = undefined;
> ```
>
> **null**
>
> ```typescript
> let bsN: null = null;
> ```

#### never

> **never**
>
> ```typescript
> const errorFunc = (msg: string): never => {
>  throw new Error(msg);
> }
> 
> const infiniteFunc = (): never => {
>  const _num: number = 1;
>  while (true) {
>      console.log(_num)
>  }
> }
> ```
>
> **never类型表示值的类型从不出现。具体而言，never是永不返回函数的返回类型，也是变量在类型保护中永不为true的类型**
>
> *never类型具有以下特征*
>
> - never是所有类型的子类型并且可以赋值给所有类型
> - 没有类型是never的子类型或能赋值给never（never类型本身除外）
> - 在有明确never返回类型注解的函数中，所有return语句（如果有的话）必须有never类型的表达式并且函数的终点必须是不可执行的
>
> ```typescript
> interface Foo {
>   type: 'foo'
> }
> interface Bar {
>   type: 'bar'
> }
> type All = Foo | Bar
> // 在 switch 当中判断 type，TS 是可以收窄类型的
> function handleValue(val: All) {
>   switch (val.type) {
>     case 'foo':
>       // 这里 val 被收窄为 Foo
>       break
>     case 'bar':
>       // val 在这里是 Bar
>       break
>     default:
>       // val 在这里是 never
>       const exhaustiveCheck: never = val
>       break
>   }
> }
> ```
>
> *注意：在 default 里面我们把被收窄为 never 的 val 赋值给一个显式声明为 never 的变量。如果一切逻辑正确，那么这里应该能够编译通过*
>
> 但是假如后来有一天你的同事改了 All 的类型：
>
> ```typescript
> type All = Foo | Bar | Baz
> ```
>
> 然而他忘记了在 handleValue 里面加上针对 Baz 的处理逻辑，这个时候在 default branch 里面 val  会被收窄为 Baz，导致无法赋值给 never，产生一个编译错误。所以通过这个办法，你可以确保 handleValue 总是穷尽  (exhaust) 了所有 All 的可能类型。

#### object

> **object**
>
> ```typescript
> let obj1 = {
>     name: 'gayhub'
> };
> let obj2 = obj1;
> obj2.name = 'Gayhub';
> 
> function bsGetObject(obj: object): void {
>     console.log(obj);
> }

#### 类型断言

> **类型断言与类型强转**
>
> ```typescript
> const bsGetLength = (target: string | number): number => {
>     if ((target as string).length || (target as string).length == 0) {
>         return (target as string).length;
>     } else {
>         return target.toString().length;
>     }
> }

### 方法

> 

#### 函数类型

> **为函数定义类型**
>
> ```typescript
> function add(arg1: number, arg2: number): number {
>     return arg1 + arg2
> }
> 
> const add2 = (arg1: number, arg2: number): number => arg1 + arg2;
> ```
>
> **完整的函数类型**
>
> ```typescript
> // 定义函数类型
> let add3: (x: number, y: number) => number;
> // 实际函数体
> add3 = (arg1, arg2) => arg1 + arg2;
> ```
>
> **使用接口定义函数类型**
>
> ```typescript
> interface Add {(x: number, y: number):number}
> ```
>
> **使用类型别名**
>
> ```typescript
> type Add = (x: number, y: number) => number
> ```
>

### 接口

> 

#### interface和type的区别

##### type(类型别名)

> **类型别名用来给一个类型起个新名字，使用 type 创建类型别名，类型别名不仅可以用来表示基本类型，还可以用来表示对象类型、联合类型、元组和交集**
>
> *例子*
>
> ```typescript
> // 基本类型
> type userName = string;
> 
> // 联合类型
> type userId = string | number; 
> type arr = number[];
> 
> // 对象类型
> type Person = {    
>     id: userId; // 可以使用定义类型
>     name: userName;    
>     age: number;    
>     gender: string;    
>     isWebDev: boolean;
> };
> 
> // 范型
> type Tree<T> = { value: T };
> ```
>
> *使用*
>
> ```typescript
> // 对象类型使用
> const user: Person = {    
>     id: "001",
>     name: "mybj",
>     age: 4,
>     gender: "男",
>     isWebDev: false,
> };
> 
> // 联合类型使用
> const numbers: arr = [1, 8, 9];
> ```

##### interface(接口)

> **接口是命名数据结构（例如对象）的另一种方式；与type 不同，interface仅限于描述对象类型**
>
> 接口的声明语法也不同于类型别名的声明语法。让我们将上面的类型别名 Person 重写为接口声明
>
> *例子*
>
> ```typescript
> interface Person {
>     id: userId;
>     name: userName;
>     age: number;
>     gender: string;
>     isWebDev: boolean;
> }
> ```

##### interface和type的相似之处

###### 都可以描述 Object 和 Function

> **两者都可以用来描述对象或函数，但语法不同**
>
> `Type`
>
> ```typescript
> type Point = {
>   x: number;
>   y: number;
> };
> ```
>
> `Interface`
>
> ```typescript
> interface Point {
>   x: number;
>   y: number;
> }
> interface SetPoint {
>   (x: number, y: number): void;
> }
> ```

###### 二者都可以被继承

> **interface 和 type 都可以继承**
> *另一个值得注意的是，接口和类型别名并不互斥。类型别名可以继承接口，反之亦然。只是在实现形式上，稍微有些差别*
>
> `interface 继承 interface`
>
> ```typescript
> interface Person{
>     name:string
> }
> interface Student extends Person { stuNo: number }
> ```
>
> `interface 继承 type`
>
> ```typescript
> type Person{
> 	name:string
> }
> interface Student extends Person { stuNo: number }
> ```
>
> `type 继承 type`
>
> ```typescript
> type Person{
>     name:string
> }
> type Student = Person & { stuNo: number }
> ```
>
> `type 继承 interface`
>
> ```typescript
> interface Person{
>     name:string
> }
> type Student = Person & { stuNo: number }
> ```
>
> **实现 implements**
>
> *类可以实现 interface 以及 type (除联合类型外)*
>
> `interface`
>
> ```typescript
> interface ICat{
>     setName(name:string): void;
> }
> class Cat implements ICat{
>     setName(name:string):void{
>         // todo
>     }
> }
> ```
>
> `type`
>
> ```typescript
> type ICat = {
>     setName(name:string): void;
> }
> class Cat implements ICat{
>     setName(name:string):void{
>         // todo
>     }
> }
> ```
>
> *上面提到了特殊情况，类无法实现联合类型, 是什么意思呢？*
>
> ```typescript
> type Person = { name: string; } | { setName(name:string): void };
> // 无法对联合类型Person进行实现
> // error: A class can only implement an object type or intersection of object types with statically known members.
> class Student implements Person {
>     name= "张三";
>     setName(name:string):void{   
>         // todo
>     }
> }
> ```

##### interface和type的区别

###### 定义基本类型别名

> **type 可以定义基本类型别名， 但是 interface 无法定义**，如：
>
> ```typescript
> type userName = string
> type stuNo = number
> ...
> ```

###### 声明联合类型

> **type可以声明联合类型**，例如：
>
> ```typescript
> type Student = {stuNo: number} | {classId: number}
> ```

###### 声明元组

> **type可以声明`元组类型`**
>
> ```typescript
> type Data = [number, string];
> ```
>
> *以上都是 type能做到， 而interface做不到的， 接下来聊聊type做不到的*

###### 声明合并

> **如果你多次声明一个同名的接口，TypeScript 会将它们合并到一个声明中，并将它们视为一个接口。这称为声明合并**
>
> *例如*
>
> ```typescript
> interface Person { name: string }
> interface Person { age: number }
> let user: Person = {
>     name: "Tolu",
>     age: 0,
> };
> ```

###### 索引签名问题

> 如果你经常使用TypeScript, 一定遇到过相似的错误
>
> `Type 'xxx' is not assignable to type 'yyy'`
>
> `Index signature is missing in type 'xxx'`
>
> 看个例子来理解问题
>
> ```typescript
> interface propType{
>     [key: string] : string
> }
> let props: propType
> type dataType = {
>     title: string
> }
> interface dataType1 {
>     title: string
> }
> const data: dataType = {title: "订单页面"}
> const data1: dataType1 = {title: "订单页面"}
> props = data
> // Error:类型“dataType1”不可分配给类型“propType”; 类型“dataType1”中缺少索引签名
> props = data1
> ```
>
> **我们发现 dataType 和 dataType1 对应的类型一样，但是 interface 定义的就赋值失败，是什么原因呢？刚开始百思不解，最后我在 stack overflow上找到了一个相似的问题**
>
> `interface定义的就赋值失败`
>
> **有效的答案**
>
> `Record<string,string> 与 {[key:string]：string} 相同。只有当该类型的所有属性都已知并且可以对照该索引签名进行检查时，才允许将子集分配给该索引签名类型。`
>
> `在您的例子中，从 exampleType 到 Record<string,string> 的所有内容都是可分配的。这只能针对对象字面量类型进行检查，因为一旦声明了对象字面量类型，就无法更改它们。因此，索引签名是已知的。`
>
> `相反，在你使用 interface 去声明变量时，它们在那一刻类型并不是最终的类型。由于 interfac 可以进行声明合并，所以总有可能将新成员添加到同一个 interface 定义的类型上。`
>
> 再结合👆第4点`声明合并`的讲解, 这样就很好理解了。就是说**interface定义的类型是不确定的**， 后面再来一个：
>
> ```typescript
> interface propType{
>     title: number
> }
> ```
>
> 这样 propType 类型就被改变了

##### 总结

> 官方推荐用 interface，其他无法满足需求的情况下用 type
> 但其实，因为`联合类型 `和`交叉类型`是很常用的，所以避免不了大量使用 type 的场景，一些复杂类型也需要通过组装后形成类型别名来使用
>
> 所以，如果想保持代码统一，还是可选择使用 type。通过上面的对比，类型别名 其实可涵盖 interface 的大部分场景
>
> **对于 React 组件中 props 及 state，使用 type ，这样能够保证使用组件的地方不能随意在上面添加属性。如果有自定义需求，可通过 HOC二次封装**
>
> **编写三方库时使用interface，其更加灵活自动的类型合并可应对未知的复杂使用场景**

### 类

> 

### 泛型

> **概述**
>
> 在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定具体类型的一种特性
>
> *TS泛型主要用于约束变量或函数的类型*

#### 泛型的使用

##### 简单使用

> **原函数**
>
> ```typescript
> const getArray = (value: any, times: number = 5): any[] => {
>     return new Array(times).fill(value);
> }
> ```
>
> - `fill`方法：使用指定的元素填充数组，其实就是用默认内容初始化数组
>
>   - ```typescript
>     arr.fill(value, start, end);
>     ```
>
>     - value：填充值
>     - start：填充起始位置，可以省略
>     - end：填充结束位置，可以省略，实际结束位置是end-1
>
> - 返回值类型为`value`类型构成的数组`any[]`；返回一个长度为`times`，内容为`value`的数组
>
> **泛型函数**
>
> ```typescript
> const getArray = <T>(value: T, times: number = 5): T[] => {
>     return new Array(times).fill(value);
> }
> ```
>
> - 在原函数的定义前面加上 `<T>`
> - 指定形参`value`的类型为`T`
> - 返回值类型为`value`类型构成的数组`T[]`
>
> **泛型函数调用**
>
> ```typescript
> console.log(getArray<number>(123, 4).map((item) => item.toFixed()));
> ```
>
> - 返回结果：`["123", "123", "123", "123"]`

##### 高阶使用

> **泛型函数**
>
> ```typescript
> // Array<[T, U]> 元祖类型泛型，固定类型，固定个数
> const getArray = <T, U>(param1: T, param2: U, tems: number): Array<[T, U]> => {
>     return new Array(times).fill([param1, param2]);
> }
> ```
>
> **泛型函数调用**
>
> ```typescript
> console.log(getArray(1, 'a', 3));
> ```
>
> - 返回结果：`[[1, "a"], [1, "a"], [1, "a"]]`
>
> ```typescript
> getArray(1, 'a', 3).forEach(item => {
>     console.log(...item)
>     // item[0].length // ERROR
>     // item[1].toFixed() // ERROR
> })
> ```
>
> - `...`：展开语法(Spread syntax), 可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。( 字面量一般指 [1, 2, 3] 或者 {name: "mdn"} 这种简洁的构造方式)
> - `item[0]`的值是`1`，没有`length`属性
> - `item[1]`的值是`'a'`，没有`toFixed()`方法

#### 泛型类型

> **使用泛型定义函数**
>
> ```typescript
> // 定义函数类型
> let getArray: <T>(arg: T, times: number) => T[];
> // 实际函数体
> getArray = (arg: any, times: number) => {
>  return new Array(times).fill(arg)
> }
> ```
>
> **类型别名定义函数**
>
> ```typescript
> // 定义函数类型
> type GetArray: <T>(arg: T, times: number) => T[];
> // 实际函数体
> const getArray: GetArray = (arg: any, times: number) => {
>  return new Array(times).fill(arg)
> }
> ```
>
> **使用接口定义函数**
>
> ```typescript
> // 定义函数类型
> interface GetArray<T> {
>     (arg: T, times: number): T[];
>     array?: T[];
> }
> // 实际函数体
> const getArray: GetArray<any> = (arg: any, times: number) => {
>     return new Array(times).fill(arg);
> };
> ```
>
> - 泛型提升至接口名后面，接口内所有对象都可以使用
> - 接口内可以同时定义函数类型和变量类型

#### 泛型约束

> **作用**
>
> - 确保属性存在
> - 检查对象上的键是否存在
>
> **使用泛型约束限制传入的参数类型**
>
> ```typescript
> // 定义接口类型
> interfase ValueWithLength {
>  length: number
> }
> // 泛型继承接口，传入的变量要有length属性
> const getArray = <T extends ValueWithLength>(arg: T, times): T[] => {
>  return new Array(times).fill(arg)
> }
> // 使用
> getArray([1, 2], 3); // OK，arg的实参有length属性
> getArray(123, 3); // error，arg的实参没有length属性
> getArray('123', 3); // OK
> getArray({length: 2}, 3); // OK
> ```
>
> - 通过继承类型来让泛型拥有一些类型的特性，从而达到泛型约束的目的
> - 泛型`T`继承接口`ValueWithLength`，获得其属性，使其传入的实际变量必须要拥有继承的接口的属性，否则报错

##### 泛型约束中使用类型参数

> **用于检查对象上的键是否存在**
>
> ```typescript
> const getProps = <T, K extends keyof T>(object: T, propName: K) => {
>  return object[propName]
> };
> const objs = {
>  a: 'a',
>  b: 'b',
> }
> getProps(objs, 'a'); // ok，对象objs上有属性a
> getProps(objs, 'c'); // error，对象objs上没有属性c
> ```
>
> - `keyof T`：返回一个对象上所有的属性名构成的一个数组
>
> *使用 K extends keyof T，令 K 继承从泛型  T 中传入的实际数据的所有属性，从而达到约束传入参数的目的*

### keyof操作符

> **概述**
>
> keyof 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型
>
> **示例**
>
> ```typescript
> interface Person {
>   name: string;
>   age: number;
>   location: string;
> }
> 
> type K1 = keyof Person; // "name" | "age" | "location"
> type K2 = keyof Person[];  // number | "length" | "push" | "concat" | ...
> type K3 = keyof { [x: string]: Person };  // string | number
> ```

### TS部分算法

#### TS扁平数据结构转Tree

#### TS查找树结构中指定的数据

> **param**
>
> - tree：树结构数据
> - key：查找的key
> - keyValue：查找key的值
> - children：子节点key
>
> **return**
>
> - keyValue对应的节点对象
> - 空对象

##### 深度优先遍历

> **原则**
>
> - 从顶点开始
>
> - 如果当前节点有子节点，则遍历当前节点的所有子节点
>
> **递归**
>
> ```ty
> 
> ```
>
> **非递归**
>
> ```typescript
> function deepTreeQuery(tree: any, key: string, keyValue: any, children: string) {
>   let stark = [];
>   stark = stark.concat(tree);
>     
>   while (stark.length) {
>     const temp: Record<string, any> = stark.shift() ?? {};
>     if (temp[children]) {
>       stark = temp[children].concat(stark);
>     }
>     if (keyValue === temp[key]) {
>       return temp;
>     }
>   }
>   return {} as Record<string, any>;
> }
> ```

##### 广度优先遍历

> **原则**
>
> - 从根节点开始
>
> - 遍历所有子节点
> -  从第一个子节点开始再执行广度优先遍历
>
> **非递归**
>
> ```typescript
> function deepTreeQuery(tree: any, key: string, keyValue: any, children: string) {
>     let stark = [];
>     stark = stark.concat(tree);
> 
>     while(stark.length) {
>         const temp: Record<string, any> = stark.shift() ?? {};
>         if(temp[children]) {
>             stark = stark.concat(temp[children]);
>         }
>         if(temp[key] === keyValue) {
>             return temp;
>         }
>     }
>     return {} as Record<string, any>;
> }
> ```

## ES6

### Symbol

> **简介**
>
> symbol 是一种基本数据类型（primitive data type）。
>
> Symbol() 函数会返回 symbol 类型的值，该类型具有静态属性和静态方法。
>
> 它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的 symbol 注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法："new Symbol()"。
>
> 每个从 Symbol() 返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符；这是该数据类型仅有的目的
>
> **语法**
>
> ````js
> const s = Symbol(description);
> ````
>
> **参数**
>
> - description：可选的，字符串类型。对 symbol 的描述，可用于调试但不是访问 symbol 本身

### Promise 对象

> **概述**
>
> Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了`Promise`对象。
>
> **含义**
>
> 所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理

#### Promise 状态

> **promise对象的特点**
>
> - 对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变
> - 一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的
>
> `Promise`也有一些缺点。首先，无法取消`Promise`，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。第三，当处于`pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）
>
> *如果某些事件不断地反复发生，一般来说，使用 [Stream](https://nodejs.org/api/stream.html) 模式是比部署`Promise`更好的选择*

#### 基本用法

> ES6 规定，`Promise`对象是一个构造函数，用来生成`Promise`实例
>
> 下面代码创造了一个`Promise`实例
>
> ```javascript
> const promise = new Promise(function(resolve, reject) {
>   // ... some code
> 
>   if (/* 异步操作成功 */){
>     resolve(value);
>   } else {
>     reject(error);
>   }
> });
> ```
>
> `Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。
>
> `resolve`函数的作用是，将`Promise`对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；`reject`函数的作用是，将`Promise`对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
>
> `Promise`实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数。

### ES6模块化规范中定义：

> -     每个js文件都是一个独立的模块
> -     导入其他模块成员使用<span style="color: red;">import</span>关键字
> -     向外共享模块成员使用<span style="color: red;">export</span>关键字
>

### 在node.js中体验ES6模块化

> node.js中默认仅支持CommonJS模块化规范，若想基于node.js体验ES6的模块化语法，可以按照如下两个步骤进行配置
>
> 1. 确保安装了v14.15.1或更高版本的node.js
> 2. 在package.json的根节点中添加 "type":"module"节点

### ES6模块化的默认导出和导入

> **默认导出**：
>
> 默认导出的语法：<span style="color: red;">export default</span> <span style="color: #329BDC;">默认导出成员</span>
>
> ```javascript
> len n2 = 10 // 定义模块私有成员 n1
> len n2 = 20 // 定义模块私有成员 n2（外界访问不到 n2，因为它没有被共享出去）
> funciton show(){} // 定义模块私有方法 show
> 
> export default { // 使用 export default 默认导出语法，向外共享 n1 和 show 两个成员
>  n1,
>  show
> }
> ```
>
> <span style='color: red;'>默认导出的注意事项：</span>每个模块中，<span style='color: #329BDC; text-decoration:underline;'>只允许使用唯一的一次</span> export default，否则会报错！
>
> **默认导入：**
>
> 默认导入的语法：<span style="color: red;">import</span> <span style="color: #329BDC;">接受名称</span> <span style="color: red;">from</span> '<span style="color: #329BDC;">模块化标识符</span>'
>
> ```javascript
>// 从 01_m1.js 模块中导入 export default 向外共享的成员
> import m1 from './01_m1.js'
> 
> // 打印输出的结果为：
> //{ n1: 10, show: [Function: show] }
> console.log(m1)
> ```
> 
> <span style='color: red;'>默认导入的注意事项：</span>默认导入时的接收名称可以任意名称，<span style="color: #329BDC;">只要是合法的成员名称即可</span>

### ES6模块化的按需导出和导入

> **按需导出：**
>
> 按需导出的语法：<span style="color: red;">export</span> <span style="color: #329BDC;">按需导出的成员</span>
>
> ```javascript
> // 当前模块为03_m2.js
> 
> // 向外按需导出变量 s1
> export let s1 = 'aaa'
> // 向外按需导出变量 s2
> export let s2 = 'ccc'
> // 向外按需导出方法 say
> export function say(){}
> ```
>
> **按需导入：**
>
> 按需导入的语法：<span style="color: red;">import</span> {<span style="color: #329BDC;">s1</span>} <span style="color: red;">from</span>> '模块标识符'
>
> ```javascript
> // 导入模块成员
> import { s1, s2, say } from './03_m2.js'
> 
> console.log(s1) // 打印输出 aaa
> console.log(s2) // 打印输出 ccc
> console.log(sa) // 打印输出 [Function: say]
> ```
>
> <span style='color: red;'>按需导出与按需导入的注意事项：</span>
>
> - 每个模块中可以使用<span style="color: red;">多次</span>按需导出
>
> - 按需<span style="color: red;">导入的成员名称</span>必须和<span style="color: red;">按需导出的名称</span>保持一致
>
> - 按需导入时，可以使用<span style="color: red;"> as 关键字</span>>进行重命名
>
> - ```javascript
>   // 导入模块成员
>   import { s1, s2 as str2, say } from './03_m2.js'
>                                                                 
>   console.log(s1) // 打印输出 aaa
>   console.log(str2) // 打印输出 ccc
>   console.log(say) // 打印输出 [Function: say]
>   ```
>
> - 按需导入可以和默认导入一起使用

## Vue3

> 

### 组件化

> 

#### 为组件的 props 标注类型

> **使用`<script setup>`**
>
> 

##### props 类型说明

> **props 的 type 的类型只支持如下几种**
>
> - `String`
> - `Number`
> - `Boolean`
> - `Array`
> - `Object`
> - `Date`
> - `Function`
> - `Symbol`
>
> 使用`vue3.0` 对 `props` 进行复杂类型验证的时候，可以直接用 `PropType` 进行强制转换
>
> ```typescript
> const props = {
>     timelineApi: { type: Function as PropType<PromiseFn> },
>     mode: { type: String as PropType<'' | 'alternate' | 'left' | 'right'> },
>     pending: { type: [Boolean, String], default: false },
>     pendingDot: { type: String },
>     reverse: { type: Boolean, default: false },
>     titleStyle: { type: Object as PropType<CSSProperties>, default: () => ({}) },
>     descStyle: { type: Object as PropType<CSSProperties>, default: () => ({}) },
> };
> ```
>
> `PropType` 使`props`获得了更准确的类型推论，让我们在使用属性的时候获取更丰富的类型提示

### 组合式 API

> 

#### setup

> 新的option, 所有的组合API函数都在此使用, 只在初始化时执行一次
>
> 函数如果返回对象, 对象中的属性或方法, 模板中可以直接使用

#### Ref全家桶

> **ref、isRef、shallowRef、triggerRef、customRef**

##### ref

> **概述**
>
> 接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象仅有一个 `.value` property，指向该内部值
>
> **语法**
>
> ```typescript
> const xxx = ref(initValue)
> ```
>
> - 创建一个包含响应式数据的引用(reference)对象
> - js中操作数据： xxx.value
> - 模板中操作数据：不需要.value
>
> *一般用来定义一个基本类型的响应式数据*
>
> **案例**
>
> 我们这样操作是无法改变message 的值 应为message 不是响应式的无法被vue 跟踪要改成ref
>
> ```typescript
> <template>
>   <div>
>     <button @click="changeMsg">change</button>
>     <div>{{ message }}</div>
>   </div>
> </template>
> <script setup lang="ts">
> let message: string = "我是message"
> 
> const changeMsg = () => {
>    message = "change msg"
> }
> </script>
> ```
>
> *改为 ref*
>
> Ref TS对应的接口
>
> ```typescript
> // T 为包装的值的类型
> interface Ref<T> {
>     value: T
> }
> ```
>
> `注意被 ref 包装之后需要.value 来进行赋值`
>
> 方式一
>
> ```typescript
> <template>
>   <div>
>     <button @click="changeMsg">change</button>
>     <div>{{ message }}</div>
>   </div>
> </template>
> <script setup lang="ts">
> import {ref, Ref} from 'vue'
> let message:Ref<string> = ref("我是message")
> 
> const changeMsg = () => {
>    message.value = "change msg"
> }
> </script>
> ```
>
> 方式二
>
> ```typescript
> <template>
>   <div>
>     <button @click="changeMsg">change</button>
>     <div>{{ message }}</div>
>   </div>
> </template>
> <script setup lang="ts">
> import { ref } from 'vue'
> let message = ref<string | number>("我是message")
> 
> const changeMsg = () => {
>   message.value = "change msg"
> }
> </script>
> ```

###### ref源码

> **ref方法**
>
> ```typescript
> export function ref(value?: unknown) {
>     return createRef(value, false)
> }
> ```
>
> `ref`方法内部调用`createRef`方法来构建
>
> **createRef**
>
> ```typescript
> function createRef(rawValue: unknown, shallow: boolean) {
>     if (isRef(rawValue)) {
>         return rawValue;
>     }
>     return new RefImpl(rawValue, shallow);
> }
> ```
>
> 在该方法中，先判断传进来的值`rawValue`是否为`ref对象`。是的话直接返回该对象，不是的话使用`new RefImpl`来构建对象
>
> **RefImpl类**
>
> ```typescript
> class RefImpl<T> {
>       private _value: T
>       private _rawValue:T
>     
>       public dep?: Dep = undefined
>       public readonly __v_isRef = true
>     
>       constructor(value: T, public readonly __v_isShallow: boolean) {
>         this._rawValue = __v_isShallow ? value : toRaw(value)
>         this._value = __v_isShallow ? value : toReactive(value)
>       }
>     
>       get value() {
>         trackRefValue(this)
>         return this._value
>       }
>     
>       set value(newVal) {
>         newVal = this.__v_isShallow ? newVal: toRaw(newVal)
>         if (hasChanged(toRaw(newVal), this._rawValue)) {
>           this._rawValue = newVal
>           this._value = this._shallow ? newVal : convert(newVal)
>           trigger(toRaw(this), TriggerOpTypes.SET, 'value', newVal)
>         }
>       }
> }
> ```
>
> 可以看见`RefImpl class`传递了一个泛型类型T，做了如下操作
>
> - 申明一个私有属性` _value`内容为泛型T，申明了一个公开只读属性`__v_isRef`值为 true
> - 有一个构造函数`constructor`，用于构造对象。构造函数接受两个参数：
>   - 第一个参数 `_rawValue`，要求是`T`类型
>   - 第二个参数 `__v_isShallow`，要求是`boolean`类型
> - 提供了两个方法，get value(){} 和 set value(){}，分别对应私有属性的读写操作，用于供外界操作`value`
>
> 当通过它构建对象时，会给对象的 `_value` 属性赋值为 `_rawValue` 或者 `toReactive(value)`
>
> **toReactive**
>
> ```typescript
> export const toReactive = <T extends unknown>(value: T): T => isObject(value) ? reactive(value) : value
> ```
>
> 最终Vue会根据传入的数据是不是对象isObject(val)，如果是对象调用的是reactive方法，否则返回原始数据

##### isRef

> **作用**
>
> 判断是不是一个ref对象
>
> **示例**
>
> ```typescript
> import { ref, Ref,isRef } from 'vue'
> let message: Ref<string | number> = ref("我是message")
> let notRef:number = 123
> const changeMsg = () => {
>       message.value = "change msg"
>       console.log(isRef(message)); //true
>       console.log(isRef(notRef)); //false
>   }
> ```

##### unref

> **作用**
>
> 如果参数是一个 ref 则返回它的 value，否则返回参数本身
>
> *unref()：是 val = isRef(val) ? val.value : val 的语法糖*
>
> **示例**
>
> ```typescript
> const valueRef = ref('');
> const value = unref(valueRef);
> if (!value) {
>        console.warning('请输入要拷贝的内容！');
>        return;
> }
> ```

##### shallowRef

> **作用**
>
> 创建一个跟踪自身 `.value` 变化的 ref，但不会使其值也变成响应式的
>
> **示例**
>
> 修改其属性是非响应式的这样是不会改变的
>
> ```typescript
> <template>
>   <div>
>     <button @click="changeMsg">change</button>
>     <div>{{ message }}</div>
>   </div>
> </template>
> <script setup lang="ts">
> import { Ref, shallowRef } from 'vue'
> type Obj = {
>   name: string
> }
> // 只监控 message 自身的 value 的修改
> let message: Ref<Obj> = shallowRef({
>   name: "小满"
> })
> // value 内的属性的值的更改不会被跟踪
> const changeMsg = () => {
>   message.value.name = '大满'
> }
> </script>
> 
> ```
>
> 这样是可以被监听到的修改value
>
> ```typescript
> import { Ref, shallowRef } from 'vue'
> type Obj = {
>     name: string
> }
> let message: Ref<Obj> = shallowRef({
>     name: "小满"
> })
> // 修改 value 的值，会被监听
> const changeMsg = () => {
>     message.value = { name: "大满" }
> }
> ```

##### triggerRef

> **作用**
>
> 强制更新页面DOM
>
> **示例**
>
> 这样也是可以改变值的
>
> ```typescript
> <template>
>     <div>
>         <button @click="changeMsg">change</button>
>         <div>{{ message }}</div>
>     </div>
> </template>
> <script setup lang="ts">
>     import { Ref, shallowRef,triggerRef } from 'vue'
>     type Obj = {
>         name: string
>     }
>     let message: Ref<Obj> = shallowRef({
>         name: "小满"
>     })
> 
>     const changeMsg = () => {
>         message.value.name = '大满'
>         triggerRef(message)
>     }
> </script> 
> ```

##### customRef

> **作用**
>
> 自定义ref
>
> **示例**
>
> customRef 是个工厂函数要求我们返回一个对象 并且实现 get 和 set
>
> ```typescript
> <script setup lang="ts">
> import { Ref, shallowRef, triggerRef, customRef } from 'vue'
>  
> function Myref<T>(value: T) {
>   return customRef((track, trigger) => {
>     return {
>       get() {
>         track()
>         return value
>       },
>       set(newVal: T) {
>         console.log('set');
>         value = newVal
>         trigger()
>       }
>     }
>   })
> }
>  
> let message = Myref('小满')
> const changeMsg = () => {
>   message.value = '大满'
>   // triggerRef(message)
> }
> </script> 
> ```
>
> - `customRef`的两个参数：
>   - track：追踪当前数据
>   - trigger：触发响应，即更新界面
> - 通过`customRef`返回的`ref`对象，和正常`ref`对象一样,通过`x.value`修改或读取值
>
> **类型声明**
>
> ```typescript
> function customRef<T>(factory: CustomRefFactory<T>): Ref<T>
> type CustomRefFactory<T> = (track: () => void, trigger: () => void) => {
>     get: () => T
>     set: (value: T) => void
> }
> ```
>
> **自定义防抖的ref**
>
> ```typescript
> function useDebouncedRef(value, delay = 200) {
>   let timeout
>   return customRef((track, trigger) => {
>     return {
>       get() {
>         track()
>         return value
>       },
>       set(newValue) {
>         clearTimeout(timeout)
>         timeout = setTimeout(() => {
>           value = newValue
>           trigger()
>         }, delay)
>       }
>     }
>   })
> }
> 
> export default {
>   setup() {
>     return {
>       text: useDebouncedRef('hello')
>     }
>   }
> }
> 
> <input v-model="text" />
> ```

#### to系列全家桶

##### toRef

> 

##### toRefs

> 

##### toRaw

> 

### Hooks

> 

### 声明文件

> **概述**
>
> **声明文件就是给js代码补充类型标注**。这样在ts编译环境下就不会提示js文件"缺少类型"
>
> 声明变量使用关键字`declare`来表示声明其后面的**全局**变量的类型, 比如：
>
> ```typescript
> // packages/global.d.ts
> declare var __DEV__: boolean
> declare var __TEST__: boolean
> declare var __BROWSER__: boolean
> declare var __RUNTIME_COMPILE__: boolean
> declare var __COMMIT__: string
> declare var __VERSION__: string
> ```
>
> 看过vue3源码的同学一定知道这些是vue中的变量, 上面代码表示`__DEV__`等变量是全局, 并且标注了他们的类型. 这样无论在项目中的哪个ts文件中使用`__DEV__`, 变量ts编译器都会知道他是`boolean`类型.

### Vue Route

> 

### Vite

> 

## NVM

> https://www.jianshu.com/p/48185ef12fbf
