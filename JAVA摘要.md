JDK、JRE、JVM之间的关系

> <span style="color: green;">JDK：</span>
> java开发工具包，包含jre和开发环境，开发人员使用的工具(date，类型...，Scanner)
> <span style="color: green;">JRE：</span>
> java运行环境，包含jvm和运行所需的核心类
> <span style="color: green;">JVM：</span>
> java运行虚拟机

### Java 中 String 使用 equals() 和 == 的区别

> 在 String 中 == 比较引用地址是否相同，equals() 比较字符串的内容是否相同
>
> 在 int 中 == 和 equals() 相同
>
> ```java
> String s1 = "Hello";              // String 直接创建
> String s2 = "Hello";              // String 直接创建
> String s3 = s1;                   // 相同引用
> String s4 = new String("Hello");  // String 对象创建
> String s5 = new String("Hello");  // String 对象创建
> 
> s1 == s1;         // true, 相同引用
> s1 == s2;         // true, s1 和 s2 都在公共池中，引用相同
> s1 == s3;         // true, s3 与 s1 引用相同
> s1 == s4;         // false, 不同引用地址
> s4 == s5;         // false, 堆中不同引用地址
> 
> s1.equals(s3);    // true, 相同内容
> s1.equals(s4);    // true, 相同内容
> s4.equals(s5);    // true, 相同内容
> ```

### 类和对象之间的关系

> <span style="color: red;">**对象是类的实例，类是对象的模板**</span>

### Java面向对象编程的特性

> - **封装**
>   - *通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。*
> - **继承**
>   - *继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。*
> - **多态**
>   - *多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A 系统访问B 系统提供的服务时，B系统有多种提供服务的方式， 但一切对A 系统来说都是透明的。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。*
> - **抽象**
>   - *抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。*

### if与switch结构之间的区别

> if常用于区间型判断，进行大量数据的判断，减少代码的编写
>
> switch常用于精确型判断，进行少量数据的精确判断，性能略高

### Java中的数组排序

> **冒泡排序：**
>
> ```java
> public static void sort(int[] array) {
> 	for(int i = 0; i < array.length - 1; i++) {
> 		for(int j = 0; j < array.length - i - 1; j++) {
>              // array[j] < array[j+1]：从大到小排序；array[j] > array[j+1]：从小到大排序
>              if(array[j] < array[j+1]) {
>              	int temp = array[j];
>              	array[j] = array[j+1];
>              	array[j+1] = temp;
>              }
>           }
>    	}
> }
> ```
>
> 

### 复制对象和复制引用的区别

> 

### 深拷贝和浅拷贝

> 

### 重载和重写的区别

> ~~方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）~~
>
> *重载发生在一个类中，同名的方法如果有不同的参数列表则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型。*
>
> <span style="color: #329BDC;">在同一个类中，方法名相同，参数列表不同，重载；在子类和父类之间，方法名相同，参数列表相同，返回值相同，子类权限修饰符不严于父类，重写</span>

### final 在 Java 中有什么作用

> - 修饰方法：表明该方法是最终方法，<span style="color: red;">不能被重写</span>
>
> - 修饰变量：表明该变量是常量，<span style="color: red;">不能再次被赋值</span>
> - 修饰类：表明该类是最终类，<span style="color: red;">不能被继承</span>

### final、finally、finalize 有什么区别

> - **final**：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。
> - **finally**：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。
> - **finalize**： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。

### Integer的值范围-128~127

> java中数据类型可以分为两类，一种的基本数据类型，一种是引用数据类型。
>
> 基本数据类型的数据不是对象，所以对于要将数据类型作为对象来使用的情况，java提供了相对应的包装类。
>
> int是基本数据类型，integer是引用数据类型，是int的包装类。
>
> 自动装箱的过程：引用了valueOf()的方法
>
> ```java
> public static Integer valueOf(int i) {
>        assert IntegerCache.high >= 127;
>        if (i >= IntegerCache.low && i <= IntegerCache.high)
>            return IntegerCache.cache[i + (-IntegerCache.low)];
>        return new Integer(i);
> }
> ```
>
> assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，系统将给出警告并且退出。一般来说，assertion用于保证程序最基本、关键的正确性。
>
> *java内部为了节省内存，IntegerCache类中有一个数组缓存了值从-128到127的Integer对象。当我们调用Integer.valueOf（int i）的时候，如果i的值时结余-128到127之间的，会直接从这个缓存中返回一个对象，否则就new一个新的Integer对象。*
>
> <span style="color: red;">总结：当我们给一个Integer赋予一个int类型的值的时候它会调用Integer的静态方法ValueOf()方法。一旦程序调用valueOf 方法，如果i的值是在-128 到 127 之间就直接在cache缓存数组中去取Integer对象。而不在此范围内的数值则要new到堆中了</span>

### Java 中的 Math. round(-1. 5) 等于多少

> 等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃

### Java 中操作字符串都有哪些类？它们之间有什么区别？

> 操作字符串的类有：<span style="color: red;">String、StringBuffer、StringBuilder</span>。
>
> **String**：
>
> String 是只读字符串，也就意味着String 引用的字符串内容是不能被改变的。str 仅仅是一个引用对象，它指向一个字符串对象“abc”。第
> 二行代码的含义是让str 重新指向了一个新的字符串“bcd”对象，而“abc”对象并没有任何改变，只不过该对象已
> 经成为一个不可及对象罢了。
>
> **StringBuffer**：
>
> StringBuffer/StringBuilder 表示的字符串对象可以直接进行修改
>
> **StringBuilder**：
>
> StringBuilder 是Java5 中引入的，它和StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方法都没有被synchronized 修饰，因此它的效率理论上也比StringBuffer 要高

### Java异常

> java中，异常可以分为三大类: Error，运行时异常，非运行时异常。抛出自定义异常用 throw 语句，在方法中抛出异常采用 throws 语句。

### error和exception的区别

> **error：**
>
> 表示系统级错误，由 java 虚拟机( jvm )抛出的，是 java 运行环境内部错误或者硬件问题，不能指望程序来处理这样的问题，除了退出运行外别无选择
>
> **exception：**
>
> 表示程序需要捕捉、需要处理的异常。是由于程序设计的不完善而出现的问题，程序必须处理的问题

### throw 和throws 的区别

> **throw**：
>
> 1. throw 语句用在方法体内，表示抛出异常，由方法体内的语句处理。
> 2. throw 是具体向外抛出异常的动作，所以它抛出的是一个异常实例，执行throw 一定是抛出了某种异常。
>
> **throws**：
>
> 1. throws 语句是用在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理。
> 2. throws 主要是声明这个方法会抛出某种类型的异常，让它的使用者要知道需要捕获的异常的类型。
> 3. throws 表示出现异常的一种可能性，并不一定会发生这种异常

### spring mvc 和 struts 的区别是什么

> 

### 如何避免 SQL 注入

> **什么是SQL注入**
>
> SQL注入是在程序运行过程中，通过特殊的手段，为SQL注入特殊的语句，达到任意查询
>
> ```java
> Class.forName("com.mysql.jdbc.Driver");
> String url = "jdbc:mysql://localhost:3306/test?characterEncoding=utf-8";
> Connection conn = DriverManager.getConnection(url, "root", "root");
> // 登录操作，注入密码sql
> String name="admin";
> String pwd = "123456 or 1=1";
> // sql注入 在sql中注入 or 1=1，在拼接时，不是将该语句认为是一个值，而是拼接成了语句。1=1 表示条件恒成立
> // 注入 or 1=1，会将表内所有的数据查询出来(select * from users where 1=1 相当于 select * from users)
> String sql = "select * from users where name='"+ name +"' and password=" + pwd;
> Statement st = conn.createStatement();
> ResultSet rs = st.executeQuery(sql);
> while(rs.next()){
>  System.out.println("登录成功!用户ID:"+rs.getInt(1)+", 用户名为:"+rs.getString("name")+", 密码为:"+rs.getString(3));
> }
> ```
>
> **如何避免**
>
> MySQL 中使用 PreparedStatement 接口
>
> - 是 Statement 接口的子接口，解决在 sql 拼接时造成的 sql 注入问题，这时候设置的值不会呈现结构的方式
> - PreparedStatement 接口以预编译 sql 的方式解决拼接的问题，每一个参数的地方使用 ？作为占位符
> - 再使用setXXX()方法设置对应类型对应位置的值，下标位置从1开始
>
> ```java
> // 加载驱动
> Class.forName("com.mysql.jdbc.Driver");
> // 获取连接字符串对象
> String url = "jdbc:mysql://localhost:3306/test?characterEncoding=utf-8";
> Connection conn = DriverManager.getConnection(url, "root", "root");
> // 准备SQL
> String name = "admin";
> String pwd = "123456 or 1=1";
> String sql = "select * from users where name=? and password=?";
> // 通过conn获取到执行对象，并预编译sql语句
> PreparedStatement pst = conn.prepareStatement(sql);
> // 为占位符赋值，有占位符就赋值，没有就不需要赋值
> pst.setString(1, name);
> pst.setString(2, pwd);
> // 执行sql，并得到结果
> rs = pst.executeQuery();
> // 循环遍历结果集，如果明确知道最多只有一个结果，可以使用判断
> if(rs.next()){
>      System.out.println("登录成功!用户ID:"+rs.getInt(1)+", 用户名为:"+rs.getString("name")+", 密码为:"+rs.getString(3));
> }else{
>     System.out.println("登录失败");
> }
> ```

### 接口声明中有\_\_\_\_\_\_和\_\_\_\_\_\_

> 接口声明中有**变量**和**抽象方法**

### jdbc提供的主要接口有哪几个

> **Statement接口、Connection接口、ResultSet接口、PreparedStatement接口**

### Java_如果去掉main方法的static修饰符会怎样

> ```java
> public class Test {
>     public void main(String[] args) {
>         System.out.println("test");
>     }
> }
> ```
>
> 结果：<span style="color: red;">错误: main 方法不是类 com.roxla.demo1.test.SupermarketDemo 中的static, 请将 main 方法定义为:
>    public static void main(String[] args)</span>
>
> **正常编译，运行报错**

### 什么是对象序列化

> 序列化就是将对象转化为字节序列的过程
>
> 反序列化是将字节序列转化为对象的过程
>
> 用于网络传输或者本地存储

### 抽象类和接口的区别

> - 抽象类可以有默认的方法实现，接口没有
> -  抽象类继承如果子类不是抽象类就是要全部实现父类中的抽象方法，接口一定要全部实现
> -  抽象类可以有构造器，接口不能有
> - 抽象类可以用public，protected，default修饰，接口只能用public

### 编译时多态、运行时多态

> 根据何时确定执行多态方法中的哪一个，多态分为两种情况：编译时多态和运行时多态。
>
> 如果在编译时能够确定执行多态方法中的哪一个，称为编译时多态，否则称为运行时多态
>
> **编译时多态**
>
> 
>
> **运行时多态**
>
> 

### sleep与wait的异同

> **相同**
>
> - 都是用于线程等待
>
> **不同**
>
> - sleep来自于线程类；wait来自于Object类
> - sleep睡眠时放弃资源但是没有放弃锁；wait放弃资源和锁
> - sleep在指定时间后自动唤醒；wait等待后需要notify或notifyAll唤醒
> - sleep可以在任意地方使用；wait，notify，notifyAll只能在同步方法或同步代码块使用

### 面试题背书

> Spring Bean的生命周期
>  Spring 不再自己去 new 对象了，而是由 IoC 容器去帮助我们实例化对象并且管理它，我们需要哪个对象，去问 IoC 容器要即可。IoC 其实就是解决对象之间的耦合问题，Spring Bean 的生命周期完全由容器控制。
> Spring bean的作用域有: 
> 	singleton :-单例;
> 	prototype : 每次新的;
> 	request-web的请求作用域;
>         session-web的会话作用域。
> 我们一般讨论singleton单例作用域的生命周期bean 定义：在配置文件里面用<bean></bean>来进行定义。
>
> bean 初始化：有两种方式初始化:
>
> 1.在配置文件中通过指定 init-method 属性来完成
>
> 2.实现 .springframwork.beans.factory.InitializingBean 接口
>
> bean 调用：有三种方式可以得到 bean 实例，并进行调用
>
> bean 销毁：销毁有两种方式
>
> 1.使用配置文件指定的 destroy-method 属性
>
> 2.实现 .springframwork.bean.factory.DisposeableBean 接口
>
> hashMap工作原理
> hashmap是数组＋链表构成的，－开始容量为0，一旦插入元素后，数组初始化为8，后面按2倍地址
> 当元素插入时，元素的hash值取余算出数组下标，就追加该数组下标的链表中，JDK8将取余数的算法优化为二进制运算更快
> JDK8后，链表长度大于8，转换成红黑树，提高搜索效率，链表长度小于6，转换回链表节约空间，因为红黑树节点更占空间
> JDK1.7的时候
> 在多线程的时候，hashMap在扩容的时候可能出现死循环，因为在扩容的时候，需要对元素重新排列，由于重排算法的关系，两个线程同时操作，可能会出现B.next=a a.next=b的情况导致死循环，jdk8之后解决了这个问题
>
> 支付宝支付
>
> 计划任务 corn表达式
>
> GET和POST的区别
> GET一般用于查询/POST一般用于增删改
> GET参数是url上带的,信息量有限制，而且不太安全,幂等(一个网址只对应一个页面，刷新多少次都行)
> POST参数在请求头上,信息比较安全，带的数据量比较大，上传文件流一定要用post，不幂等（一旦刷新网页就变GET了，网页就变了）
>
> springboot引入自动配置的概念，集成了大量常用的第三方库配置，只需要非常少量的配置代码就能达到开箱即用的效果，开发者能够更加专注于业务逻辑。如果是WEB项目，那么工作流程其实和SpringMVC的是完全一样的，因为它倾向于用代码来完成配置细节。新一代基于Spring框架的应用程序。而且内置web容器，非常适合于开发SpringCloud的微服务架构 
> @SpringBootApplication 它其实由3个核心注解组成@SpringBootConfiguration @ComponentScan @EnableAutoConfiguration 
>
> 消息队列MQ，快进慢出，web程序要求运行快，发送email,短信,账务处理这些模块比较慢，我们把慢的模块分离出去，通过消息队列进行解耦合，满足高并发速度的要求，我们常用的MQ有RabbitMQ/ActiveMQ/RocketMQ/Kafuka,RabbitMQ用enlang语言,效率高，支持多种语言，可以跨平台整合程序，它常用有3种交换机(直连交换机/扇形交换机(广播)/Topic交换机(通配符灵活控制)，它的使用方式可以使用原生的api，SpringBoot使用注解操作，非常简单
>
> redis是内存中的数据库，它读写非常快，可以满足高并发的需求，它存储的实际上是字典结构，有5种的数据类型String/list/hash/set/zset，存储的方式可以是JDK序列化和JSON
> 在高并发的环境下，数据库承受很大的压力，我们把数据缓存在redis高速缓存中,可以大大减少数据库的查询
> 但是在代码处理的时候也要注意处理redis被穿透/击穿/雪崩的情况
> redis使用过程中也可以使用注解的方式非常方便，编码的方式会更加灵活
>
> 索引就是通过排序提高查询速度，对增删改是不利的，可能会产生多张索引表，比较占空间的,不是所有的列都应该建立索引，数据量小/变化不多的表不要建索引,
> 频繁查询的列，经常排序的列都应该建索引
> 谨慎使用联合索引，查询要按索引的顺序才有效
> 避免使用or  like 避免运算后比较，避免用不等于 避免用is null
>
> spring Cloud 基于分布式系统设计微服务框架，它由五大组件构成
> 服务发现，注册中心Eureka
> 通讯组件feign，包含负载均衡ribbon
> 融断器组件hystrix，避免雪崩效应故障漫延
> 服务网关Gateway，对请求进行统一隔离控制
> 分布式配置Config，统一管理配置信息
>
> 微服务开发和单体开发有很大区别，
> 微服务是按功能进行垂直切分，每个微服务都是独立运行模块，非常适合扩展和在集群中布署，配合负载均衡，灵活调整节点数量，有效的应对高并发
> 开发设计上每个微服务功能单一，互相耦合度低，甚至拥有独立支撑的数据库，很适合分工和未来功能的扩展
> 微服务之间是通过网络调用对方，互相交换Json或二进制数据，面临的问题也主要是网络通讯和集群带来的种种问题，例如重试机制，融断保护，降级处理，分布式事务，共享session,负载均衡，互相发现定位的机制，以及配置及时更新等一系列问题，需要我们细心处理
>
> VUE的特点前端编程实现组件化，利用绑定和虚拟DOM机制，局步刷新更快，可以利用流行的组件库，例如EIementUi,iview等快速构建工程
> vue通过Node平台和ES6语法实现组件化的编程，通过Babel编译成Es5语法实现浏览器的兼容，它是MvvM摸型，通过绑定机制，我们只要控制数据就能影响界面的呈现，从而实现表现和数据相分离，避免像JQ那样直接控制Dom模型，它提供了多个钩子函数供我们在生命周期的不同阶段插入代码，我们还可以通过计算属性加工数据，还可以通过侦听器联动行为
> Ⅴue是一般单页面系统；
> 通过路由组件router切换页面；
> 通过axios获取远程数据；
> 通过vuex进行组件之间信息共享和绑定
> 可以在路由和axios上增加拦截器实现切面处理，例如登陆拦截，增加token请求头信息,响应异常处理等
> vuex可以代替繁锁的事件机制达到组件间的协作通讯，但Ⅴuex也经不起页面刷新，要配合本地存储进行持久化
>
> nginx是反向代理服务器
> 它的作用体现在多台机器的协作中，它主要有三个作用:反向代理/负载均衡/动静分离
> 反向代理是指可以对客户输入的网址按规则进行切换成其他的网址，访问不同的服务器
> 负载均衡是指把高并发的请求，合理的分配给多台服务器工作，里面有多种分配算法:轮询/百分比/ip hash/响应速度等
> 动静分离是指nginx本身是个高性能的web服务器，我们把工程中的静态资源例如html/css/js/img等放在nginx里面，性能更高
>
> 共享session
> 多台web服务器水平部署的时候，多台机器session之间互相独立，导致我们的会话失效，我们一般会用四种方式解决
> 1.将nginx的负载均衡策略调整为ip hash,这样每个客户端始终访问特定的服务器，保持访问同一个session
> 2.设置tomcat之间的session互相复制
> 3.使用Spring Session框架，将所有的session数据集中存储在同一个redis中
> 4.使用JWT技术，把凭证放在客户端存储，服务器端不需要使用session
>
> 数据库的事务(ACID)
> 事物的四大特征原子性，一致性，隔离性，持久性
> 原子性是多个步骤，要不同时成功，要不同时失败
> 一致性是事务执行前后都要保持数据的平衡，完整性不被破坏
> 隔离性是指多个事务同时运行，互相要有一定的隔离不会导致混乱
> 持久性是指事务结束后，结果被永久保持下来不受故障影响
>
> 数据库事务的隔离级别有4种
> 事务同时运行存在安全问题，表现在：
> 脏读/不可重复读／幻读
> 数据库通过共享锁和排他锁实现4种隔离性，读未提交／读已提交／可重复读／串行化
> 事务的传播性是指多个事物碰撞在一起的时候如何处理的问题
> 传播性required是多个事务融合成一个事务，工程中90％都使用它，其他的还有required_new never等其他策略
>
> 常用的ORM框架有
> Mybatis和Hibernate
> Mybatis是半自动框架，需要自己写sql语句，运行效率高，但开发效率低，而且不跨数据库平台
> hibernate是全自动框架，sql是自动生成不同数据库的sql语句，开发效率高，但运行效率低，要求数据库设计比较的成熟
> JPA是hibernate的升级版，更加简单好用
> MybatisPlus是mybatis的升级版，它的生成器可以自动生成代码，可以兼顾开发效率，需要表连接时，也可以通过扩充sql语句满足灵活的调整
>
> shiro是安全框架，可以精细的解决权限控制的问题，它包含认证模块和授权模块，认证是指用户是否成功登陆，授权是指登陆后能做什么，适应各种程序，我们需要提供一个子类，来验证用户名和查询角色权限，再写一个子类比对密码，配置文件要配好缓存等等细节，搭建好之后，通过4种方式使用 url／注解／jsp标签／代码控制
> url进行前置的拦截，通过注解灵活控制方法权限，Jsp标签控制页面显示，代码可以解决复杂的逻辑
> 它包含自己的session机制，所以获取当前用户和各种操作,需要使用它提供的api
> 一般支持权限方面的表有5张，用户／角色／权限以及2张多对多的表
>
> 面向对象是模拟人的思维编程，所以叫做面向真实世界编程，人的思考方式是把事物进行归类和封装，并且进行宏观和微观的控制，所以我们面向对象有封装继承和多态三种特征
> 封装是把事物的特征和行为打包在一起，隐藏内部细节，公开必要的方法，是实现高内聚的一种方式
> 继承和多态是相辅相成，父类可以重用代码，子类重写父类的方法实现行为的多样性，实现松耦合，最终达到宏观和微观控制效果
>
> Spring的两大特征主要有IOC和AOP
> IOC叫控制反转或依赖注入DI
> AOP叫面向切面编程
> IOC是指对象交给spring容器进行组装，这样可以灵活处理对象之间的依赖关系，重要的是在组装对象的过程可以默默织入切面代码，IOC的组装方式有3种，xml配置文件，注解，纯代码，为了实现IOC，spring内部使用了三级缓存来实现
> 第三级缓存负责切面代理对象,处理复杂的循环依赖关系，第二级缓存负责存储初始化完成的对象，第一级缓存存储装配好的对象，我们一般是从一级缓存获取对象
> Aop是面向切面编程，就指是在不修改原代码的基础上，自动增强功能，spring默认对有接口的类使用JDK动态代理，没有接口的类使用cglib动态代理，我们也可以明确指定使用cglib代理，Jdk动态代理是通过创建兄弟类来实现代码织入，就像让中介公司帮忙卖房子，让中介完成房产各种手续，cglib代理通过字节码技术创建子类来完成代码织入，象通过儿子去卖房，让他完成各种手续
> 过滤器，拦截器和切面类都是实现AOP的不同形式
>
> java的集合分开Collection和Map
> Collection 分为有序的List和无序的Set
> List分为数组结构的ArrayList和链表结构的LinkedList，数组结构查询比较快，链表结构增删比较快
> Set分为Hashset和排序的TreeSet
> Map分为线程不安全的HashMap和线程安全的HashTable,hashTable已经过时,建议使用ConcurrentHashMap，它采用分段加锁的方式效率更高
>
>
> IO流分为两种,一个是字节流，一个是字符流，字符流是对字节流的封装对文字编码进行处理,流都分为输入流InputStream和输出流OutputStream两个方向
> 字节流分为多种功能的流在不同的场合中使用
> 最基础的就是文件流FileInputStream
> 缓冲流BufferedInputStream提供缓冲区提高读写效率
> 另外还有数据流DateInputStream,它采用存储二进制数据，体积小，保密性好
> 内存流ByteArrayInputStream，主要是在内存中处理流的结构，
> 对象流ObjectInputStream把对象转换成流，为对象的存储和远程传输提供方便
>
> 操作系统把程序分为进程和线程
> 进程相当于公司,每个公司是独立经营,互不影响，一家倒闭了，其他公司不受影响，这是避免故障扩散的一种方案，
> 线程相当于公司里多名员工同时工作,他们可以共享同一个公司的资源，但是也带来了线程安全等一系列并发引起的问题
> 线程实际上是由cpu分片调度处理的，所以线程多并不一定效率高，要合理使用
> 线程有几种状态:新建/就绪/运行/阻塞/结束 
> 其中阻塞有几种形式:sleep是睡眠等待，join是等待其他线程，wait是等待其他线程notify通知唤醒,
> 它们的区别是sleep睡眠时候会抱着同步锁睡觉，其他线程都被卡住，而wait会自动让出锁，让其他线程先跑
> sleep会在一段时间后自动苏醒，而wait必须由其他线程唤醒，控制不好会造成死锁
> 多个线程操作同一个变量会造成数据的不安全，导致混乱，我们可以加同步锁来实现线程安全，但是也会降低效率
> 线程的创建可以使用几种方式:继承Thread类，实现Runable接口，实现有返回值的Callable接口
> 线程的创建成本比较高，还推荐使用线程池来获取线程，java的线程池有四种
> 1
> 可缓存线程池，可灵活回收空闲线程，不限制线程的数量。
> 定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
> 支持定时及周期性任务执行的线程池。
> 单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。
>
> 垃圾回收器GC
> 在c＋＋的语言中，分配在堆里的对象，是需要手动释放的，由于很难界定对象何时不再需要，所收回收内存比较困难，容易造成内存泄漏且很难调试
> Java语言在虚拟机中使用垃圾回收器处里对象回收的问题，扫描分析出哪些对象是不再使用并回收，但扫描的工作量巨大，所以出现了各种算法进行优化性能，把对象分为新生代，老年代和永久代，这样可以减少扫描范围，定制不同的扫描频次，提高回收效率，大量需回收的对象一般存在于刚刚创建的对象，所以新生代中扫描频次高一点，而多次扫描仍在使用的对象被转移到老年代，这些对象不需要频繁扫描，因为大概率仍在使用，当老年代扫描多次仍没被回收的对象被转移到永久代，在内存不足时才去考虑回收永久代的对象
> 虚拟机负责GC的运行，我们可以使用System.gc（）；建议它运行，但作用不大，我们更应该做的是帮助它回收，使用完的集合及时clear清空它，不用的对象主动设为null，及时清除对象间的关联，帮助Gc回收
>
>
> 主流的工作流框架是JBPM和Activiti
> 在OA系统中，充满对各种流程控制需求，例如请假，报销，投诉，租车，报修，退货等等，这些流程控制有一定的复杂性，而且还会面临流程的频繁变更，工作流框架将这些流程的复杂性分离出来，将流程的设计图形化，它内置24张数据库表的设计，数据库层和业务层已实现好，我们把它们合并到主工程，通过业务id把它们关联起来，通过它提供好的7个业务层api是对流程图24张表进行操作，首先我们会通过spring的配置文件配置好activiti的参数和数据源和bean，它会自动创建24张表，手动用sql脚本建也行，我们使用插件绘制流程图和添加表达式和监听器与Java代码交互来动态获取审批人或触发动作，生成Bpmn2.0规范的xmI文件来表达流程，通过api上传到数据表里，然后在主工程中操作工作流的Api，完成启动流程，注入变量，查询个人任务，认领组任务，审批通过，填写批注，查询下一个任务，查看流程图，还会查询线条名称动态生成按扭等，通过变量控制流程图的走向，同时，我们会通过与之关联的业务ID同步的操作到我们自己主工程业务表来达到整合
> activiti提供的api比较底层，一般我们会对它进行再次封装成常用的Api，当我们发现有些功能不能实现，一般就会查文档研发好，再封装好方法供组员使用
>
> web的几大组件servlet filter listener Jsp
> listener在web容器初始化完动作一次，一次性的初始化动作一般放在监听器完成，并将动作结果放在全局作用域共享
> filter过滤器在每个请求的通道上工作，有利于自动切入代码，分离共享重复的代码，是切面的一种形式
> servlet是响应请求的处理器，它一般是单例，每个servlet只创建一个实例，它的生命周期有4个步骤，创建，初始化，服务，释放，其中服务方法是多线程的方法，需要注意线程安全的问题，不要共享修改字段，在mvc结构中servlet更适合承担控制器的角色
>
> Jsp则承担视图的作用，它其实也是一个Servlet,它拥有写好的9大内置对象方便编写逻辑，4个作用域2个输出对象，config,exception,pageContext
> servlet和Jsp的传递数据，和servlet之间传递数据通过4大作用域中进行存取，page,request,session,application，其中session的占用内存情况最严重，要谨慎使用
>
> 页面跳转有重定向和转发两种形式
> 转发客户端只进行了一次请求，转发在服务器内部进行，可以传递Java对象参数，但网址是不变的，更适合用于多个servlet分工合作完成一个动作。
> 重定向是服务器发出302指令，要求浏览器重新发起新的网址的请求，客户端发起了两次请求，网址会变化，但参数只能是字符串，重定向适合两个主题页面的切换
>
> web服务器本身是无状态的，要记住之前的请求，需要利用session机制来支持，session机制是依赖于cookie来保存session id这个key值的，如果禁用了cookies，就只能靠url重写来把session id记录在网址参数上
> session是服务器端存储，它为每个用户在服务器开薛了一个存储空间，可以存储Java对象，
> 而cookie是客户端存储，它在浏览器端存储，只能存字符串，可以指定过期时间，和自动回传的网址，但它也有安全问题，所以不要在cookie中存储敏感信息
>
> spring mvc的工作原理
> 客户的请求首先进入核心控制器，
> 核心控制器先找HandlerMapping映射器查询是应该由谁来处理这个请求，映射器将查询结果反馈给核心控制器,查询结果包括处理器的名称和它所需要经过的拦截器
> 核心控制器再根据这些信息，要求控制器的适配器HandlerAdapter落实动作，适配器让请求经过相关拦截器和数据转换器到达Controller
> Controller实际处理客户请求并将结果反馈给核心控制器，包括视图名称和Model数据
> 核心控制器向视图解析器询问如何处理这种视图，视图解折器返回响应的解析对象
> 核心控制器将模型交给解析器对象完成渲染返还客户端
>
> ****
>
> 基本类型的大小，影响内存占用，和数据溢出的问题(boolean理论上1bit，实际上可能是1或4个字节)
>
> byte b=1;
> b++,b+=1没有错
> b=b+1有错（返回结果是int）
>
> &和|运算符是位运算符，是二进制的运算结果
> 包装类比较大小是有坑的,最好转成值类型再比较
> 值类型和引用类型
>
> springcloud /dubbo（阿里）
> 前端三大框架 angular和react和vue
> JVM内存结构(方法区/栈/堆)
>
> ArrayList/LinkedList结构，hash表的结构
>
> 包装类
> 当我们的系统类只接受引用类型，int等值类型，使用包装类来代替使用
> 包装类是值类型的代言人
> 数据库是null值，int类型是不能等于null的，使用包装类

### HashMap多线程下的无限循环问题

> https://baijiahao.baidu.com/s?id=1722255125227536994&wfr=spider&for=pc

### 线程，线程安全的集合

#### map

##### hashmap扩容机制

hashMap工作原理
hashmap是数组＋链表构成的，－开始容量为0，一旦插入元素后，数组初始化为8，后面按2倍地址
当元素插入时，元素的hash值取余算出数组下标，就追加该数组下标的链表中，JDK8将取余数的算法优化为二进制运算更快
JDK8后，链表长度大于8，转换成红黑树，提高搜索效率，链表长度小于6，转换回链表节约空间，因为红黑树节点更占空间
JDK1.7的时候
在多线程的时候，hashMap在扩容的时候可能出现死循环，因为在扩容的时候，需要对元素重新排列，由于重排算法的关系，两个线程同时操作，可能会出现B.next=a a.next=b的情况导致死循环，jdk8之后解决了这个问题

#### 线程安全的list

Vector(已淘汰)

CopyOnWriteArrayList

### 数据库索引，优化，事务

#### 索引

怎么知道有没有使用索引

![img](file:///E:\QQDATA\3320171744\Image\Group2\7I\83\7I83$9Y6RH61QJ@[%8@K}AK.png)

最左原则

最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配

#### 优化

https://wenku.baidu.com/view/0ce999251a2e453610661ed9ad51f01dc2815784.html

优化数据库的8种方式

#### 事务

数据库的事务(ACID)
事物的四大特征原子性，一致性，隔离性，持久性
原子性是多个步骤，要不同时成功，要不同时失败
一致性是事务执行前后都要保持数据的平衡，完整性不被破坏
隔离性是指多个事务同时运行，互相要有一定的隔离不会导致混乱
持久性是指事务结束后，结果被永久保持下来不受故障影响

数据库事务的隔离级别有4种
事务同时运行存在安全问题，表现在：
脏读/不可重复读／幻读
数据库通过共享锁和排他锁实现4种隔离性，读未提交／读已提交／可重复读／串行化
事务的传播性是指多个事物碰撞在一起的时候如何处理的问题
传播性required是多个事务融合成一个事务，工程中90％都使用它，其他的还有required_new never等其他策略

### 字符流字节流

### JVM的内存模型

![image-20220218172410793](C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20220218172410793.png)



### Ioc和Aop切面



### get和post区别

Ajax Get和Post的区别

  1.使用Get请求时,参数在URL中显示,而使用Post方式,则不会显示出来

  2.使用Get请求发送数据量小,Post请求发送数据量大
1.get请求需注意缓存问题,post请求不需担心这个问题

2.post请求必须设置Content-Type值为application/x-form-www-urlencoded

3.发送请求时,因为get请求的参数都在url里,所以send函数发送的参数为null,而post请求在使用send方法时,却需赋予其参数

### Ajax

#### Ajax怎么使用get和post请求

ajax指定get和post请求

$.get

$.post

****

servlet后端用什么通信的；tomcat容器socket http协议

jsp的了解；JSP就是Servlet，更适合写页面，在MVC模式中JSP是视图V，servlet承担是控制器的任务

List是线程安全的吗？为什么？List中ArrayList是线程不安全的，Vector是线程安全的但是被淘汰了，现在用CopyOnWriteArrayList 用于线程安全情况

你有没有深入了解事务；

什么是jquery；jQuery是基于JS的框架，可以大量减少我们操作DOM的代码，并且可以跨浏览器，它的链式语法非常好用

### Spring事务的实现方式和实现原理(必会)

Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。 

spring事务实现主要有两种方法

1、编程式，beginTransaction()、commit()、rollback()等事务管理相关的方法

2、声明式，利用注解Transactional 或者aop配置











