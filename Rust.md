## Hello World!

> rust程序文件后缀名：rs
>
> **`::` 的含义**
>
> 双冒号 `::` 是 Rust 中的路径分隔符，用于访问模块、结构体、枚举、关联函数、常量等
>
> **常见用途**
>
> *访问模块或结构体的内容*
>
> ```rust
> mod my_module {
>     pub fn say_hello() {
>         println!("Hello from my_module!");
>     }
> }
> 
> fn main() {
>     my_module::say_hello(); // 使用 :: 调用模块中的函数
> }
> ```
>
> *调用关联函数（如 `new` 或 `from`）*
>
> ```rust
> let s = String::new(); // 调用 String 的关联函数 new()
> ```
>
> *访问枚举的变体*
>
> ```rust
> enum Direction {
>     Up,
>     Down,
> }
> 
> let d = Direction::Up; // 使用 :: 访问枚举变体
> ```
>
> *访问静态常量或类型关联项*
>
> ```rust
> struct MyStruct;
> 
> impl MyStruct {
>     const CONSTANT: u32 = 42;
> }
> 
> let value = MyStruct::CONSTANT; // 使用 :: 访问常量
> ```

### 直接创建 Rust 文件

> **创建一个工程目录**
>
> ```bash
> $ mkdir hello_world
> $ cd hello_world
> ```
>
> **创建一个 rs 文件**
>
> ```bash
> $ touch main.rs
> ```
>
> **编译 rs 文件**
>
> ```bash
> $ rustc main.rs
> ```
>
> **运行**
>
> ```bash
> $ ./main
> ```

### 通过 Cargo 创建项目

>**简介**
>
>Cargo 是 Rust 的构建系统和包管理工具
>
>- 构建代码、下载依赖的库、构建这些库。。。
>
>安装Rust的时候会安装 Cargo
>
>- 判断 Cargo 是否正确安装：在终端中运行`cargo --version `命令
>
>**使用 Cargo  创建项目**
>
>```bash
>$ cargo new hello_cargo
>```
>
>- 项目名称也是 hello_cargo
>- 会创建一个新的目录 hello_cargo
>  - Cargo .toml
>  - src 目录
>    - main.rs
>  - 初始化了一个新的 git 仓库，.gitignore
>    - 可以使用其他的 vcs 或者不使用 vcs：cargo new 的时候使用 --vcs 这个 flag
>
>*cargo 生成的 main.rs 在 src 目录下，而 Cargo.toml 在项目顶层下；源代码都应该在 src 目录下，顶层目录可以放置 README、许可信息、配置文件和其他与程序源码无关的文件*
>
>==创建项目时没有使用 cargo，也可以把项目转化位使用 cargo==
>
>- 把源代码文件移动到 src 下
>- 创建 Cargo .toml 并填写相应的配置
>
>**编译构建**
>
>```bash
>$ cargo build
>```
>
>- 创建可执行文件：target/debug/hello_cargo
>- 运行可执行文件：./target/debug/hello_cargo
>
>*第一次运行 cargo build 会在顶层目录生成 cargo.lock 文件。该文件负责追踪项目依赖的精确版本，不需要手动修改该文件*
>
>```bash
>## 编译代码 + 执行结果
>$ cargo run
>```
>
>如果之前编译成功过，并且源码没有改变，那么就会直接运行二进制文件
>
>```bash
>## 检查代码
>$ cargo check
>```
>
>检查代码，确保能通过编译，但是不产生任何可执行文件
>
>cargo check 要比 cargo build 快得多，编写代码的时候可以连续反复的使用 cargo check 检查代码，提高效率
>
>**为发布构建**
>
>```bash
>$ cargo build --release
>```
>
>编译时会进行优化。代码会运行的更快，但是编译时间更长
>
>会在 target/release 而不是 target/debug 生成可执行文件

#### Cargo .toml

> TOML（Tom's Obvious, Minimal Language）格式，是 Cargo 的配置格式
>
> ```toml
> [package]
> name = "hello_cargo"
> version = "0.1.0"
> authors = [""]
> edition = "2025"
> 
> [dependencies]
> ```
>
> - [package]，是一个区域标题，表示下方内容是用来配置包的
>   - name，项目名
>   - version，项目版本
>   - authors，项目作者
>   - edition，使用的 Rust 版本
> - [dependencies]，另一个区域的开始，它会列出项目的依赖项
> - 在 Rust 里面，代码的包/库称作 crate

## 变量绑定与解构

### 变量命名

> 在命名方面，和其它语言没有区别，不过当给变量命名时，需要遵循 [Rust 命名规范](https://course.rs/practice/naming.html) 
>
> Rust 语言有一些**关键字**（*keywords*），和其他语言一样，这些关键字都是被保留给 Rust 语言使用的，因此，它们不能被用作变量或函数的名称

### 变量绑定

> 在其它语言中，我们用 `var a = "hello world"` 的方式给 `a` 赋值，也就是把等式右边的 `"hello world"` 字符串赋值给变量 `a` ，而在 Rust 中，我们这样写： `let a = "hello world"` ，同时给这个过程起了另一个名字：**变量绑定** 

### 变量可变性

> Rust 的变量在默认情况下是**不可变的**，可以通过 `mut` 关键字让变量变为**可变的** 
>
> **举例**
>
> 如果变量 `a` 不可变，那么一旦为它绑定值，就不能再修改 `a`
>
> ```rust
> fn main() {
>     let x = 5;
>     println!("The value of x is: {}", x);
>     x = 6;
>     println!("The value of x is: {}", x);
> }
> ```
>
> *运行结果*
>
> ```bash
> $ cargo run
>    Compiling variables v0.1.0 (file:///projects/variables)
> error[E0384]: cannot assign twice to immutable variable `x`
>  --> src/main.rs:4:5
>   |
> 2 |     let x = 5;
>   |         -
>   |         |
>   |         first assignment to `x`
>   |         help: consider making this binding mutable: `mut x`
> 3 |     println!("The value of x is: {}", x);
> 4 |     x = 6;
>   |     ^^^^^ cannot assign twice to immutable variable
> 
> error: aborting due to previous error
> ```
>
> 具体的错误原因是 `cannot assign twice to immutable variable x`（无法对不可变的变量进行重复赋值），因为我们想为不可变的 `x` 变量再次赋值
>
> **这种错误是为了避免无法预期的错误发生在我们的变量上：一个变量往往被多处代码所使用，其中一部分代码假定该变量的值永远不会改变，而另外一部分代码却无情的改变了这个值，在实际开发过程中，这个错误是很难被发现的，特别是在多线程编程中**
>
> 这种规则让我们的代码变得非常清晰，只有你想让你的变量改变时，它才能改变，这样就不会造成心智上的负担，也给别人阅读代码带来便利
>
> 但是可变性也非常重要，否则每次要改变，就要重新生成一个对象，在拥有大量对象的场景，性能会变得非常低下，内存拷贝的成本异常的高

#### mut关键字

> 在 Rust 中，可变性很简单，只要在变量名前加一个 `mut` 即可
>
> **举例**
>
> ```rust
> fn main() {
>     let mut x = 5;
>     println!("The value of x is: {}", x);
>     x = 6;
>     println!("The value of x is: {}", x);
> }
> ```
>
> *运行程序将得到下面结果*
>
> ```ignore
> $ cargo run
>    Compiling variables v0.1.0 (file:///projects/variables)
>     Finished dev [unoptimized + debuginfo] target(s) in 0.30s
>      Running `target/debug/variables`
> The value of x is: 5
> The value of x is: 6
> ```
>
> 选择可变还是不可变，更多的还是取决于你的使用场景，例如不可变可以带来安全性，但是丧失了灵活性和性能（如果你要改变，就要重新创建一个新的变量，这里涉及到内存对象的再分配）。而可变变量最大的好处就是使用上的灵活性和性能上的提升。
>
> 例如，在使用大型数据结构或者热点代码路径（被大量频繁调用）的情形下，在同一内存位置更新实例可能比复制并返回新分配的实例要更快。使用较小的数据结构时，通常创建新的实例并以更具函数式的风格来编写程序，可能会更容易理解，所以值得以较低的性能开销来确保代码清晰。

### 为何要手动设置变量的可变性

> 在其它大多数语言中，要么只支持声明可变的变量，要么只支持声明不可变的变量（例如函数式语言），前者为编程提供了灵活性，后者为编程提供了安全性，而 Rust 比较野，选择了两者我都要，既要灵活性又要安全性。
>
> 除了以上两个优点，还有一个很大的优点，那就是运行性能上的提升，因为将本身无需改变的变量声明为不可变在运行期会避免一些多余的 `runtime` 检查。

### 使用下划线开头忽略未使用的变量

> 如果你创建了一个变量却不在任何地方使用它，Rust 通常会给你一个警告，因为这可能会是个 BUG。但是有时创建一个不会被使用的变量是有用的，比如你正在设计原型或刚刚开始一个项目。这时**你希望告诉 Rust 不要警告未使用的变量，为此可以用下划线作为变量名的开头**
>
> ```rust
> fn main() {
>     let _x = 5;
>     let y = 10;
> }
> ```
>
> *运行结果*
>
> ```ignore
> warning: unused variable: `y`
>  --> src/main.rs:3:9
>   |
> 3 |     let y = 10;
>   |         ^ help: 如果 y 故意不被使用，请添加一个下划线前缀: `_y`
>   |
>   = note: `#[warn(unused_variables)]` on by default
> ```
>
> **可以看到，两个变量都是只有声明，没有使用，但是编译器却独独给出了 `y` 未被使用的警告，充分说明了 `_` 变量名前缀在这里发挥的作用**

### 变量解构

> `let` 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容
>
> ```rust
> fn main() {
>     let (a, mut b): (bool,bool) = (true, false);
>     // a = true,不可变; b = false，可变
>     println!("a = {:?}, b = {:?}", a, b);
> 
>     b = true;
>     assert_eq!(a, b);
> }
> ```

#### 解构式赋值

> 在 Rust 1.59 版本后，我们可以在赋值语句的左式中使用元组、切片和结构体模式了
>
> ```rust
> struct Struct {
>     e: i32
> }
> 
> fn main() {
>     let (a, b, c, d, e);
> 
>     (a, b) = (1, 2);
>     // _ 代表匹配一个值，但是我们不关心具体的值是什么，因此没有使用一个变量名而是使用了 _
>     [c, .., d, _] = [1, 2, 3, 4, 5];
>     Struct { e, .. } = Struct { e: 5 };
> 
>     assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
> }
> ```
>
> 这种使用方式跟之前的 `let` 保持了一致性，但是 `let` 会重新绑定，而这里仅仅是对之前绑定的变量进行再赋值。
>
> 需要注意的是，使用 `+=` 的赋值语句还不支持解构式赋值

### 变量和常量之间的差异

> 变量的值不能更改可能让你想起其他另一个很多语言都有的编程概念：**常量**(*constant*)。与不可变变量一样，常量也是绑定到一个常量名且不允许更改的值，但是常量和变量之间存在一些差异：
>
> - 常量不允许使用 `mut`。**常量不仅仅默认不可变，而且自始至终不可变**，因为常量在编译完成后，已经确定它的值。
> - 常量使用 `const` 关键字而不是 `let` 关键字来声明，并且值的类型**必须**标注。
>
> 我们将在下一节[数据类型](https://course.rs/basic/base-type/index.html)中介绍，因此现在暂时无需关心细节。
>
> 下面是一个常量声明的例子，其常量名为 `MAX_POINTS`，值设置为 `100,000`。（Rust 常量的命名约定是全部字母都使用大写，并使用下划线分隔单词，另外对数字字面量可插入下划线以提高可读性）
>
> ```rust
> const MAX_POINTS: u32 = 100_000;
> ```
>
> 常量可以在任意作用域内声明，包括全局作用域，在声明的作用域内，常量在程序运行的整个过程中都有效。对于需要在多处代码共享一个不可变的值时非常有用，例如游戏中允许玩家赚取的最大点数或光速
>
> *在实际使用中，最好将程序中用到的硬编码值都声明为常量，对于代码后续的维护有莫大的帮助。如果将来需要更改硬编码的值，你也只需要在代码中更改一处即可*

### 变量遮蔽(shadowing)

> Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的，如下所示
>
> ```rust
> fn main() {
>     let x = 5;
>     // 在main函数的作用域内对之前的x进行遮蔽
>     let x = x + 1;
> 
>     {
>         // 在当前的花括号作用域内，对之前的x进行遮蔽
>         let x = x * 2;
>         println!("The value of x in the inner scope is: {}", x);
>     }
> 
>     println!("The value of x is: {}", x);
> }
> ```
>
> 这个程序首先将数值 `5` 绑定到 `x`，然后通过重复使用 `let x =` 来遮蔽之前的 `x`，并取原来的值加上 `1`，所以 `x` 的值变成了 `6`。第三个 `let` 语句同样遮蔽前面的 `x`，取之前的值并乘上 `2`，得到的 `x` 最终值为 `12`。当运行此程序，将输出以下内容
>
> ```ignore
> $ cargo run
>    Compiling variables v0.1.0 (file:///projects/variables)
>    ...
> The value of x in the inner scope is: 12
> The value of x is: 6
> ```
>
> 这和 `mut` 变量的使用是不同的，第二个 `let` 生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配 ，而 `mut` 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好。
>
> 变量遮蔽的用处在于，如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。
>
> 例如，假设有一个程序要统计一个空格字符串的空格数量
>
> ```rust
> // 字符串类型
> let spaces = "   ";
> // usize数值类型
> let spaces = spaces.len();
> ```
>
> 这种结构是允许的，因为第一个 `spaces` 变量是一个字符串类型，第二个 `spaces` 变量是一个全新的变量且和第一个具有相同的变量名，且是一个数值类型。所以变量遮蔽可以帮我们节省些脑细胞，不用去想如 `spaces_str` 和 `spaces_num` 此类的变量名；相反我们可以重复使用更简单的 `spaces` 变量名。如果你不用 `let` 
>
> ```rust
> let mut spaces = "   ";
> spaces = spaces.len();
> ```
>
> 运行一下，你就会发现编译器报错
>
> ```ignore
> $ cargo run
>    Compiling variables v0.1.0 (file:///projects/variables)
> error[E0308]: mismatched types
>  --> src/main.rs:3:14
>   |
> 3 |     spaces = spaces.len();
>   |              ^^^^^^^^^^^^ expected `&str`, found `usize`
> 
> error: aborting due to previous error
> ```
>
> 显然，Rust 对类型的要求很严格，不允许将整数类型 `usize` 赋值给字符串类型。`usize` 是一种 CPU 相关的整数类型，在[数值类型]()中有详细介绍

## 基本类型

> Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。 基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型（一般意义上来说），由以下组成：
>
> - 数值类型：有符号整数 (`i8`, `i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, `f64`)、以及有理数、复数
> - 字符串：字符串字面量和字符串切片 `&str`
> - 布尔类型：`true` 和 `false`
> - 字符类型：表示单个 Unicode 字符，存储为 4 个字节
> - 单元类型：即 `()` ，其唯一的值也是 `()`

### 类型推导与标注

> 

### 数值类型

> 在 Rust 中，数值类型分为两大类：**整数类型**和**浮点数类型**。此外，Rust 还支持复合类型如元组和数组，以及其他数值相关类型如 `char` 和 `bool`
>
> **字面量后缀**
>
> Rust 支持通过后缀显式指定数值类型
>
> - 整数：`42u8` 表示无符号 8 位整数
> - 浮点数：`3.14f32` 表示 32 位浮点数
>
> ```rust
> let num = 42u8; // 无符号 8 位整数
> let pi = 3.14f32; // 32 位浮点数
> ```
>
> **类型转换**
>
> Rust 不支持隐式类型转换，所有类型转换必须显式进行
>
> ```rust
> let x: u8 = 5;
> let y: u16 = x as u16; // 显式转换
> ```
>
> *字符串转换为数字*
>
> ```rust
> let x = String::from("123");
> let y: u8 = x.trim().parse().expect("转换失败");
> ```

#### 标量类型

> **整数类型**
>
> 整数类型分为带符号 (`signed`) 和无符号 (`unsigned`) 两种，分别表示正负数和仅正数
>
> | 类型    | 大小（位） | 范围（带符号）                   | 范围（无符号）    |
> | ------- | ---------- | -------------------------------- | ----------------- |
> | `i8`    | 8          | -128 ~ 127                       | 0 ~ 255           |
> | `i16`   | 16         | -32,768 ~ 32,767                 | 0 ~ 65,535        |
> | `i32`   | 32         | -2,147,483,648 ~ 2,147,483,647   | 0 ~ 4,294,967,295 |
> | `i64`   | 64         | -2^63 ~ 2^63-1                   | 0 ~ 2^64-1        |
> | `i128`  | 128        | -2^127 ~ 2^127-1                 | 0 ~ 2^128-1       |
> | `isize` | 平台相关   | 取决于 CPU 架构（32 位或 64 位） | 取决于 CPU 架构   |
>
> - *有符号整数* (`i*`)：可以表示正数、负数和零。
> - *无符号整数* (`u*`)：仅能表示正数和零，范围更大。
>
> `i32` 是默认类型
>
> **浮点数类型**
>
> Rust 支持两种浮点数类型，均符合 IEEE 754 标准
>
> | 类型  | 大小（位） | 有效数字精度 | 范围        |
> | ----- | ---------- | ------------ | ----------- |
> | `f32` | 32         | ~7 位        | ±3.4×10^38  |
> | `f64` | 64         | ~15 位       | ±1.8×10^308 |
>
> `f64` 是默认类型
>
> **字符类型 `char`**
>
> 单个 Unicode 字符，如 `'a'`，`'α'` 和 `'∞'`（每个都是 4 字节）
>
> **布尔类型 `bool`**
>
> 只能是 `true` 或 `false`
>
> **单元类型**
>
> `()`。其唯一可能的值就是 `()` 这个空元组

#### 复合类型

> **数组**
>
> 如 `[1, 2, 3]`
>
> **元组**
>
> 如 `(1, true)`

#### 数值操作

> Rust 提供了丰富的数值操作，包括基本的加减乘除、取模，以及位操作（`<<`, `>>`, `|`, `&` 等）
>
> ```rust
> let sum = 5 + 10;      // 加法
> let diff = 95.5 - 4.3; // 浮点数减法
> let prod = 4 * 30;     // 乘法
> let quot = 56.7 / 32.2; // 浮点数除法
> let remainder = 43 % 5; // 取模
> ```

### 字符、布尔、单元类型

> 

### 语句和表达式

> 

### 函数

> 

## 所有权和借用

### 所有权

> 

### 引用与借用

> 

#### 引用与解引用

> 

## 宏

> 宏的参数可以使用 `()`、`[]` 以及 `{}`
>
> **宏展开**
>
> 由于宏会被展开成其它代码，且这个展开过程是发生在编译器对代码进行解释之前。因此，宏可以为指定的类型实现某个特征：先将宏展开成实现特征的代码后，再被编译。
>
> 而函数就做不到这一点，因为它直到运行时才能被调用，而特征需要在编译期被实现。
>
> **宏的缺点**
>
> 相对函数来说，由于宏是基于代码再展开成代码，因此实现相比函数来说会更加复杂，再加上宏的语法更为复杂，最终导致定义宏的代码相当地难读，也难以理解和维护。

### 函数与宏的区别

#### 定义方式

> - 函数：使用 `fn` 关键字定义
>
>   ```rust
>   fn add(a: i32, b: i32) -> i32 {
>       a + b
>   }
>   ```
>
> - 宏：使用 `macro_rules!`（或更现代的 `macro` 特性）定义
>
>   ```rust
>   macro_rules! add {
>       ($a:expr, $b:expr) => {
>           $a + $b
>       };
>   }
>   ```

#### 调用方式

> - 函数：通过普通调用，传递参数并返回值
>
>   ```rust
>   let result = add(1, 2);
>   ```
>
> - 宏：通过特殊的语法调用（通常以 `!` 结尾）
>
>   ```rust
>   let result = add!(1, 2);
>   ```

#### 工作原理

> - 函数：在编译阶段将函数体编译为机器代码，执行时才调用。
> - 宏：在编译阶段执行代码扩展，将宏调用替换为生成的代码（即**代码生成**）。

#### 灵活性

> - 函数：
>   - 参数和返回值的类型固定，需明确指定。
>   - 无法操作代码本身，受类型系统的严格约束。
> - 宏：
>   - 可以接受任意类型或结构的代码块作为输入，并生成代码。
>   - 具有更高的灵活性，甚至可以改变代码的结构。

##### 可变参数

> Rust 的函数签名是固定的：定义了两个参数，就必须传入两个参数，多一个少一个都不行，对于从 JS/TS 过来的同学，这一点其实是有些恼人的。
>
> 而宏就可以拥有可变数量的参数，例如可以调用一个参数的 `println!("hello")`，也可以调用两个参数的 `println!("hello {}", name)`。

#### 性能

> - 函数：
>   - 函数调用可能带来少量运行时开销（如果未内联）。
>   - 编译器可以进行优化（如内联函数）来消除这部分开销。
> - 宏：
>   - 宏直接展开为目标代码，无运行时开销，但展开后的代码可能较大，影响编译时间和二进制大小。

#### 使用场景

> - 函数：
>   - 适用于大多数情况，尤其是明确参数和返回值时。
>   - 提供可读性和类型安全。
> - 宏：
>   - 适用于需要生成代码、实现复杂模式匹配、或编写 DSL（领域特定语言）时
>   - 例如条件编译（`cfg!`）、日志宏（`println!`）、断言宏（`assert!`）

#### 错误处理

> - 函数：
>   - 编译器会在编译阶段检测类型和语法错误，错误信息清晰
> - 宏：
>   - 由于宏是代码生成工具，错误通常出现在展开后的代码中，调试可能更困难

#### 示例对比

> - 函数实现
>
>   ```rust
>   fn square(x: i32) -> i32 {
>       x * x
>   }
>   let result = square(4); // 调用函数
>   ```
>
> - 宏实现
>
>   ```rust
>   macro_rules! square {
>       ($x:expr) => {
>           $x * $x
>       };
>   }
>   let result = square!(4); // 调用宏
>   ```

### 声明式宏

> 在 Rust 中使用最广的就是声明式宏，它们也有一些其它的称呼，例如示例宏( macros by example )、`macro_rules!` 或干脆直接称呼为**宏**。

### 过程宏

> 第二种常用的宏就是[*过程宏*](https://doc.rust-lang.org/reference/procedural-macros.html) ( *procedural macros* )，从形式上来看，过程宏跟函数较为相像，但过程宏是使用源代码作为输入参数，基于代码进行一系列操作后，再输出一段全新的代码。**注意，过程宏中的 derive 宏输出的代码并不会替换之前的代码，这一点与声明宏有很大的不同！**

#### 自定义 derive

> 在之前多次见到的派生宏，可以为目标结构体或枚举派生指定的代码，例如 `Debug` 特征

#### 类属性宏

> 用于为目标添加自定义的属性

#### 类函数宏

> 看上去就像是函数调用

