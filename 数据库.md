## 数据库概述

> 在Java变量集合中存储的数据，在运行时存在，程序结束后会消失，当数据需要持久存储时，Java无法办到需要使用工具将数据持久存储到硬盘。数据库是最优势的选择
>
> **概念**：
>
> 数据库是一套数据库存储管理系统，包含数据库和数据库管理系统

## MySQL

> MySQL数据是一种关系型数据库
>
> SQL：结构化查询语言
>
> 其实就是定义操作所有关心型数据库的规则，每一种数据库操作的方式存在不一样的地方，称为"方言"
>
> MySQL数据是一种关系型数据,由瑞典MySQL AB公司打造,被Oracle收购,其体积小、速度快、总体拥有成本低,被广大中小型企业应用

## 通用语法

> 1. sql语句可以单行或多行书写，以分号结束
> 2. 可以使用空格和缩进来增强语句的可读性
> 3. mysql数据库的SQL语句不区分大小写，关键字建议大写
> 4. 注释：
>    1. '-- '  单行注释
>    2. '#'    注释内容
>    3. '/**/' 多行注释
>

## SQL分类

> - DDL数据定义语言：用来定义数据库内容 数据库，表，列等相关结构操作语句
>   - create，drop，alter
> - DML数据操作语言：用来对数据库表中数据的操作
>   - insert，updata，delect
> - DQL数据库查询语言
>   - select，where
> - DCL数据控制语言：用来定义数据库访问权限,安全级别,创建用户的操作
>  - grand，if，revoke

## SQL语句的使用

> - *创建数据库*
>
>   - 语法：create database 数据库名称 character set 字符集 collate 字符集校对规则;
>
>     ```mysql
>     -- 创建一个默认字符集和校对的数据库db1
>     CREATE DATABASE db1;
>     -- 创建一个GBK字符集和GBK默认校对的数据库db2
>     CREATE DATABASE db2 CHARACTER SET GBK;
>     -- 创建一个utf8字符集和utf8_bin校对的数据库db3
>     CREATE DATABASE db3 CHARACTER SET utf8 COLLATE utf8_bin;
>     -- 如果不存在数据库db4，则创建该数据库
>     CREATE DATABASE IF NOT EXISTS db3;
>     ```
>
> - *查看数据库*
>
>   - 查看数据库服务器中所有的数据库：show database;
>
>     ```mysql
>     SHOW DATABASE;
>     ```
>
>   - 查看某个数据库的定义信息：show create database 数据库名称;
>
>     ```mysql
>     SHOW CREATE DATABASE db3;
>     ```
>
> - *修改数据库*
>
>   - 语法：alter database 数据库名称 character set 字符集 collate 校对规则;
>
>     ```mysql
>     ALTER DATABASE db2 CHARACTER SET utf8;
>     ```
>
> - *删除数据库*
>
>   - 语法：Drop database 数据库名称
>
>     ```mysql
>     DROP DATABASE db1;
>     ```
>     
>   - 判断数据库存在, 则删除
>
>     - 格式：drop database if exists 数据库名;
>
>     ```mysql
>     DROP DATABASE IF EXISTS db1;
>     ```
>
> - *其他数据库操作*
>
>   - 切换数据库：user 数据库名称
>
>     ```mysql
>     USER db3;
>     ```
>
>   - 查看当前正在使用的数据库：select database();
>
>     ```mysql
>     SELECT DATABASE();
>     ```

## SQL对数据库表的操作

### 创建表

> 语法：<span style="color: red;">create table 表名称</span>(<span style="color: #329BDC;">字段名称 字段类型(长度) 约束, 字段名称 字段类型(长度) 约束</span>);
>
> 字段类型：一个实体对应一个表，一个实体属性对应表的一个字段
>
> | Java中的类型 |                    MySQL的类型                     |
> | :----------: | :------------------------------------------------: |
> |     byte     |                      tinyint                       |
> |    short     |                      smallint                      |
> |     int      |                        int                         |
> |     long     |                       bigint                       |
> |    float     |                       float                        |
> |    double    |                       double                       |
> |   boolean    |                        bit                         |
> | char/String  |                   char和varchar                    |
> |     Date     |            date/time/datetime/timestamp            |
> |     File     | BLOB(二进制文件，例如图片)/TEXT(文本文件，例如txt) |
>
> **char和varchar的区别**：
>
> - char：代表的是固定长度的字符或字符串
>   - 定义类型char(8)，向这个字段存入字符串hello，那么数据库使用三个空格将其补全
> - varchar：代表的是可变长度的字符串
>   - 定义类型varchar(8)，向这个字段存入字符串hello，那么存入到数据库的就是hello
>
> **datetime和timestamp的区别**：
>
> - datetime：就是既有日期又有时间的日期类型，如果没有向这个字段中存值，数据库使用null存入到数据库中
> - timestamp(时间戳)：也是既有日期又有时间的日期类型，如果没有向这个字段中存值，数据库会使用当前的系统时间存入到数据库中
>
> **约束**：
>
> 作用：暴走数据的完整性
>
> 单表约束分类：
>
> - 主键约束：
>   - 主键约束在表中定义一个主键来唯一确定表中每一行数据的标识符
>   - 关键字：primary key 
>   - 主键约束默认就是唯一，非空的
> - 唯一约束：
>   - 所有记录中字段的值不能重复出现
>   - 关键字：unique
> - 非空约束：
>   - 表中的某一个字段的内容不允许为空
>   - 关键字：not null
>
> **建表语句**：
>
> ```mysql
> CREATE DATABASE web_test1;
> -- 通过使用该数据库来跳转到该数据库
> USE web_test1;
> CREATE TABLE user(
> 	id int primary key auto_increment,
> 	username VARCHAR(20) unique,
> 	password VARCHAR(20) not null,
>     age int,
>     birthday date
> );
> ```
>

### SQL语句部分关键字

> **DEFAULT**：
>
> 用于在建表时给予字段默认值
>
> 语法：**字段名称 字段类型(长度) 约束 DEFAULT 默认值;**
>
> ```mysql
> CREATE TABLE user(
> 	id int primary key auto_increment,
> 	username VARCHAR(20) unique,
> 	password VARCHAR(20) not null,
> 	age int DEFAULT 0, -- 若age项在插入数据时没有给予数据，则使用默认值0
> 	birthday date
> );
> ```
>
> **COMMENT**：
>
> 用来给字段或列添加注释
>
> 语法：**字段名称 字段类型(长度) 约束 DEFAULT 默认值 COMMENT 注释;**
>
> ```mysql
> CREATE TABLE test(
> 	id int NOT NULL DEFAULT 0 COMMENT '用户id',
> );
> ```
>
> **CONSTRAINT**：
>
> 主要就是增加数据约束的
>
> 语法：CONSTRAINT 字段名称 约束(要添加约束的字段名称)
>
> ```mysql
> create table goods(
> 	id int(10) auto_increment,
> 	-- 主键约束
> 	CONSTRAINT goods_id_pk PRIMARY key(id)
> );
> ```
>
> **EXISTS**：
>
> EXISTS 运算符用于判断查询子句是否有记录，如果有一条或多条记录存在返回 True，否则返回 False
>
> **DISTINCT**：
>
> 用于给查询结果去重
>
> DISTINCT只能出现在所有字段的最前方
>
> ```mysql
> SELECT DISTINCT job, deptno FROM emp;
> ```
>
> *DISTINCT出现在job, deptno两个字段之前，表示两个字段联合起来去重*

### 查看表

> - 查看某个数据库下的所有的表
>
>   - 语法：show tables;
>
>     ```mysql
>     show tables;
>     ```
>
> - 查看某个表的结构信息
>
>   - 语法：desc 表名;
>
>     ```mysql
>     desc user;
>     ```
>

### 删除表

> 语法：drop table 表名;
>
> ```mysql
> drop table user;
> ```
>

### 修改表

> - 修改表：添加列
>
>   - alter table 表名 add 列名 类型(长度) 约束;
>
>     ```mysql
>     ALTER TABLE user ADD inage VARCHAR(100);
>     ```
>
> - 修改表：修改列类型，长度和约束
>
>   - alter table 表名 modify 列名 类型(长度) 约束;
>
>     ```mysql
>     ALTER TABLE user MODIFY VARCHAR(150);
>     ```
>
> - 修改表：删除列
>
>   - alter table 表名 drop 列名;
>
>     ```mysql
>     ALTER TABLE user DROP age;
>     ```
>
> - 修改表：修改列名称
>
>   - alter table 表名 change 旧列名 新列名 类型(长度) 约束;
>
>     ```mysql
>     ALTER TABLE user CHANGE inage pic VARCHAR(150);
>     ```
>
> - 修改表：修改表名
>
>   - rename table 表名 to 新的表名;
>
>     ```mysql
>     RENAME TABLE user TO employee;
>     ```
>
> - 修改表：修改表的字符集
>
>   - alter table 表名 character set 字符集
>
>     ```mysql
>     ALTER TABLE user CHARACTER SET gbk;
>     ```
>

## 对数据库表的记录进行操作

### 添加表的记录

> **语法**：
>
> - 向表中插入某些列：insert into 表名(列名1, 列名2, 列名3...) values(值1, 值2, 值3...);
>
>   ```mysql
>   INSERT INTO user (id, username, password) VALUES (null, 'aaa', '123');
>   ```
>
> - 向表中插入所有列：insert into 表名 values(值1, 值2, 值3...);
>
>   ```mysql
>   INSERT INTO user VALUES (null, 'bbb', '123', 23, '1993-09-01');
>   ```
>
> - 注意事项
>
>   - 值的类型与数据库中表列的类型一致
>   - 值的顺序与数据库中表列的顺序一致
>   - 值的最大长度不能超过列设置的最大长度
>   - 值的类型是字符串或者是日期类型，使用单引号引起来
>
> **添加中文记录**：
>
> <span style="color: red;">直接向数据库中插入中文记录会出现错误！</span>
>
> ```mysql
> -- 查询与字符集相关的参数
> show variables like '%character%';
> ```
>
> 解决办法：将MySQL数据库服务器中的客户端部分的字符集改成gbk
>
> **一次插入多条记录**:
>
> 多条记录之间用逗号隔开
>
> ```mysql
> INSERT INTO user (id, username, password) VALUES 
> (null, 'aaa', '123'),
> (null, 'bbb', '1234'),
> (null, 'ccc', '12345');
> ```
>
> 语法：insert into t_user(字段名1, 字段名2) values (), (), (), ();

### 修改表的记录

> 语法：update 表名 set 列名=值, 列名=值 [where 条件];
>
> *注：[]内为可选项*
>
> ```mysql
> -- 修改某一列的所有值
> UPDATE user SET password='abc';
> -- 按条件修改数据
> UPDATE user SET password='xyz' WHERE username='bbb';
> -- 修改多个列
> UPDATE user SET password='123',age=34 WHERE username = 'aaa';
> ```
>
> 注意事项：
>
> - 值的类型与列的类型一致
> - 值的最大长度不能超过列设置的最大长度
> - 字符串类型和日期类型添加单引号
>

### 删除表的记录

> 语法：delete 表名 [where 条件];
>
> - 删除某一条记录：
>
>   ```mysql
>   DELETE FROM user WHILE id = 2;
>   ```
>
> - 删除表中的所有记录：
>
>   ```mysql
>   DELETE FROM user;
>   ```
>
> 注意事项：
>
> - 删除表的记录，指的是删除表中的一行记录
> - 删除如果没有条件，默认是删除表中的所有记录
>
> 删除表中记录的两种做法：
>
> - delete from user;
>   - 属于DML语句
>   - 删除所有记录，一条一条的删除记录
>   - 事物可以作用在DML语句上的
>   - 删除后可以回滚恢复
> - truncate table user;
>   - 属于DDL语句
>   - 删除所有记录，将表删除，然后重新创建一个结构一样的表
>   - 事物不能控制DDL的
>   - 删除后不能恢复
> - start transaction 开启事物；roolback 回滚
>

### 查看表的记录

> 环境准备：
>
> ```mysql
> CREATE TABLE exam(
> 	id INT PRIMARY KEY AUTO_INCREMENT, -- AUTO_INCREMENT自动增量
>     name VARCHAR(20),
>     english INT,
>     chinese INT,
>     math INT
> );
> 
> INSERT INTO exam VALUES (null, '张三', 85, 74, 91);
> INSERT INTO exam VALUES (null, '李四', 95, 90, 83);
> INSERT INTO exam VALUES (null, '王五', 85, 84, 59);
> INSERT INTO exam VALUES (null, '赵六', 75, 79, 76);
> INSERT INTO exam VALUES (null, '田七', 69, 63, 98);
> INSERT INTO exam VALUES (null, '李老八', 89, 90, 83);
> ```
>

#### 基本查询

> - 语法：
>
>   - select[distinct] *|列名 from 表 [条件];
>
> - 查询所有学生考试成绩信息
>
>   ```mysql
>   SELECT * FROM exam;
>   ```
>
> - 查询所有学生的姓名和英语成绩
>
>   ```mysql
>   SELECT name, english FROM exam;
>   ```
>
> - 查询英语成绩信息(不显示重复值)
>
>   ```mysql
>   SELECT DISTINCT english FROM exam;
>   ```
>
> - 查看学生姓名和学生的总成绩
>
>   ```mysql
>   SELECT name, english+chinese+math FROM exam;
>   ```
>
> - 别名查询
>
>   - 如果别名有空格，使用双引号引起来
>
>   ```mysql
>   SELECT name, english+chinese+math AS sum FROM exam;	-- as可省略
>   SELECT name, english+chinese+math sum FROM exam;
>   ```
>

#### 条件查询

> - 使用where子句
>
>   - <，>，>=，<=，=，!=或<>
>
>     - *ANSI标准中是用<>(所以建议用<>)，但为了跟大部分数据库保持一致，数据库中一般都提供了 !=(高级语言一般用来表示不等于) 与 <> 来表示不等于*
>
>   - like：模糊查询
>
>   - in：范围查询
>
>     ```mysql
>     -- 查询deptno值是10或是20的数据
>     SELECT * FROM emp WHERE deptno in (10,20);
>     ```
>
>   - is null 为null (is not null) 不为空
>
>   - 条件关联：
>
>     - and：并且
>     - or：或者
>     - not：可以取非，主要用在is和in中
>
>   - between...and...：两个值之间，等同于 >= AND <=
>
> - 查询李四学生的成绩：
>
>   ```mysql
>   SELECT * FROM exam WHERE name='李四';
>   ```
>
> - 查询名称叫李四的学生，并且英文大于90分：
>
>   ```mysql
>   SELECT * FROM exam WHERE name='李四' AND english>90;
>   ```
>
> - 查询姓李的学生的信息
>
>   - like可以进行模糊查询，在like子句中可以使用_下划线_或者%作为占位符。_下划线_只能代表一个字符，而%可以代表任意个字符。
>   - like '李_'：名字中必须是两个字，而且是姓李的
>   - like '李%'：名字中是姓李的学生，李字后可以是1个或任意个字符
>   - like '%四'：以四结尾的
>   - like '%王%'：只要名称中包含这个字就可以
>
>   ```mysql
>   SELECT * FROM exam WHERE name LIKE '李%'; -- 查询所有姓李的学生
>   SELECT * FROM exam WHERE name LIKE '李_'; -- 查询所有名字是两个字，而且是姓李的学生
>   SELECT * FROM exam WHERE name LIKE '李%' AND english>90; -- 查询所有姓李且英语成绩大于90分的学生
>   ```
>
> - 查询英语成绩是69，75，89的学生的信息
>
>   ```mysql
>   SELECT * FROM exam WHERE english in (69, 75, 89);
>   ```
>

#### 排序查询

> 使用**order by**字段
>
> - asc：升序排序(默认，从小到大)
> - desc：降序排序(从大到小)
>
> 查询学生信息，并且按照语文成绩进行排序
>
> ```mysql
> SELECT * FROM exam ORDER BY chinese;
> SELECT * FROM exam ORDER BY chinese ASC;
> ```
>
> 查询学生信息，并且按照语文成绩进行倒序排序
>
> ```mysql
> SELECT * FROM exam ORDER BY chinese DESC;
> ```
>
> 查询学生信息，先按照语文成绩进行倒序排序，如果成绩相同，再按照英语成绩升序排序
>
> ```mysql
> SELECT * FROM exam ORDER BY chinese DESC, english ASC;
> ```
>
> 查询姓李的学生的信息，按照英语成绩降序排序
>
> - <span style="color: red;">若有查询条件，则要先添加查询条件，后使用排序查询</span>
>
> ```mysql
> SELECT * FROM exam WHERE name LIKE '李%' ORDER BY english DESC;
> ```
>

#### 分组统计查询

> **函数分类**
>
> - 单行函数：对一行数据进行影响，返回一个数据
>
> - 组函数：也称聚合函数，多行函数；对一组数据进行影响，得到一个数据
>
> **常用单行函数**
>
>   - UPPER(column_name)：转换大写
>
>     | 参数        | 描述                 |
>     | ----------- | -------------------- |
>     | column_name | 必需。要格式化的字段 |
>
>     ```mysql
>     SELECT UPPER(column_name) FROM table_name;
>     ```
>
>   - LOWER(column_name)：转换小写
>
>     | 参数        | 描述                 |
>     | ----------- | -------------------- |
>     | column_name | 必需。要格式化的字段 |
>
>     ```mysql
>     SELECT LOWER(column_name) FROM table_name;
>     ```
>
>   - LENGTH(column_name)：得到长度
>
>     | 参数        | 描述                   |
>     | ----------- | ---------------------- |
>     | column_name | 必需。要获取长度的字段 |
>
>     ```mysql
>     SELECT LENGTH(column_name) FROM table_name;
>     ```
>
>   - ROUND(column_name, decimals)：四舍五入
>
>     | 参数        | 描述                       |
>     | ----------- | -------------------------- |
>     | column_name | 必需。要舍入的字段         |
>     | decimals    | 可选。规定要返回的小数位数 |
>
>     ```mysql
>     SELECT ROUND(column_name,decimals) FROM TABLE_NAME;
>     ```
>
>   - CEIL(value)：向上取整
>
>     | 参数  | 描述             |
>     | ----- | ---------------- |
>     | value | 必须。要取整的值 |
>
>     ```mysql
>     SELECT CEIL() FROM table_name;
>     ```
>
>     - *函数返回大于等于指定值(value)的最小整数，取整，没有四舍五入这一说法*
>
>   - FLOOR(value)：向下取整
>
>     | 参数  | 描述             |
>     | ----- | ---------------- |
>     | value | 必须。要取整的值 |
>
>     ```mysql
>     SELECT FLOOR() FROM table_name;
>     ```
>
>       - *函数返回小于或等于指定值（value）的最小整数，取整，没有四舍五入这一说法*
>
>   - SYSDATE()：获取系统时间
>
>     ```mysql
>     SELECT SYSDATE() FROM table_name;
>     ```
>
>   - DATE_FORMAT(date, format)：日期转换为字符串
>
>     | 参数   | 描述                 |
>     | ------ | -------------------- |
>     | date   | 必需。要格式化的日期 |
>     | format | 必需。规定格式       |
>
>     ```mysql
>     SELECT DATE_FORMAT(SYSDATE(),'%m-%d-%Y') FROM table_name;
>     ```
>
>   - FORMAT(column_name, format)：转换数组为字符串/字符串转换为数字
>
>     | 参数        | 描述                 |
>     | ----------- | -------------------- |
>     | column_name | 必需。要格式化的字段 |
>     | format      | 必需。规定格式       |
>
>     ```mysql
>     SELECT FORMAT(column_name,format) FROM table_name;
>     ```
>     
> - CONCAT(str1, str2, ...)：将多个字符串连接成一个字符串
>
>   | 参数 | 描述                 |
>   | ---- | -------------------- |
>   | str  | 必需。要连接的字符串 |
>
>   ```mysql
>   SELECT CONCAT(str1, str2, ...) FROM table_name;
>   ```
>
> **聚合函数使用**
>
> - SUM();：求和
>
>   - 获取所有学生的英语成绩的总和
>
>     ```mysql
>     SELECT SUM(english) FROM exam;
>     ```
>
>   - 获取所有学生的英语成绩和数学成绩的总和
>
>     ```mysql
>     SELECT SUM(english), SUM(math) FROM exam;
>     ```
>
>   - 查询姓李的学生的英语成绩和数学成绩的总和
>
>     ```mysql
>     SELECT SUM(english), SUM(math) FROM exam WHERE name LIKE '李%';
>     ```
>
>   - 查询所有学生各科的总成绩
>
>     ```mysql
>     -- 按照列的方式统计，英语成绩总和+语文成绩总和+数学成绩总和
>     SELECT SUM(english)+SUM(math)+SUM(chinese) FROM exam;
>
>     -- 按照行的方式统计，先计算英语+语文+数学，然后再求和
>     SELECT SUM(english+math+chinese) FROM exam; -- 有null时数据会出现误差，可以使用
>     ```
>
>   - *SELECT SUM(english+math+chinese) FROM exam;*这种方式在数据中有null时会出现误差，可以使用**ifnull**的函数
>
>     ```mysql
>     SELECT SUM(IFNULL(english, 0) + IFNULL(math, 0) + IFNULL(chinese, 0)) FROM exam;
>     ```
>
> - COUNT();：计数
>
>   - 获得学生的总数
>
>     ```mysql
>     SELECT COUNT(*) FROM exam;
>     ```
>
>   - 获得姓李的学生的个数
>
>     ```mysql
>     SELECT COUNT(*) FROM exam WHERE name LIKE '李%';
>     SELECT COUNT(*) AS li FROM exam WHERE name LIKE '李%'; -- 使用as起别名
>     ```
>
> - MAX();：获取最大值
>
>   - 获得数学成绩的最高分
>
>     ```mysql
>     SELECT MAX(math) FROM exam;
>     ```
>
> - MIN();：获取最小值
>
>   - 获得语文成绩的最低分
>
>     ```mysql
>     SELECT MIN(chinese) FROM exam;
>     ```
>
> - AVG();：获取平均值
>
>   - 求语文成绩的平均分
>
>     ```mysql
>     SELECT SUM(chinese)/COUNT(*) FROM exam;
>     SELECT AVG(chinese) FROM exam;
>     ```
>
> **分组查询**
>
> 概念：*将数据库中的数据按照某一字段来进行分组查询*
>
> 语法：**GROUP BY 字段名称;**
>
> 规则：在 select 中出现的字段，在分组中一定出现；在分组中出现的字段，在 select 中不一定出现；
>
> 环境准备：
>
> ```mysql
> -- 购买的商品订单表
> CREATE TABLE orderitem(
> 	id INT PRIMARY KEY AUTO_INCREMENT,
>     product VARCHAR(20),
>     price DOUBLE
> );
> -- 添加数据
> INSERT INTO orderitem VALUES (null, '电视机', 2999);
> INSERT INTO orderitem VALUES (null, '电视机', 2999);
> INSERT INTO orderitem VALUES (null, '洗衣机', 1000);
> INSERT INTO orderitem VALUES (null, '洗衣机', 1000);
> INSERT INTO orderitem VALUES (null, '洗衣机', 1000);
> INSERT INTO orderitem VALUES (null, '冰箱', 3999);
> INSERT INTO orderitem VALUES (null, '冰箱', 3999);
> INSERT INTO orderitem VALUES (null, '空调', 1999);
> ```
>
> 按商品名称统计，每类商品所购买的个数
>
> ```mysql
> SELECT product, COUNT(*) FROM orderitem GROUP BY product;
> ```
>
> 按商品名称统计，每类商品所花费的总金额
>
> ```mysql
> SELECT product, SUM(price) FROM orderitem GROUP BY product;
> ```
>
> 按商品名称统计，统计每类商品花费的总金额在5000元以上的商品
>
> - <span style="color: red;">where的子句后面不能跟着聚合函数</span>
> - 如果要在带有聚合函数的语句中使用条件过滤(分组后条件过滤)，需要使用一个关键字**having**
>
> ```mysql
> SELECT product, SUM(price) FROM orderitem GROUP BY product HAVING SUM(price) > 5000;
> ```
>
> 按商品名称统计，统计每类商品花费的总金额在5000元以上的商品，并且按照总金额升序排序
>
> ```mysql
> SELECT product, SUM(price) FROM orderitem GROUP BY product HAVING SUM(price) > 5000 ORDER BY SUM(price) ASC;
> ```
>
> **SQL语句分组查询的顺序**：
>
> <span style="color: red;">S</span>(<span style="color: #329BDC;">SELECT</span>)...<span style="color: red;">F</span>(<span style="color: #329BDC;">FROM</span>)...<span style="color: red;">W</span>(<span style="color: #329BDC;">WHERE</span>)...<span style="color: red;">G</span>(<span style="color: #329BDC;">GROUP BY</span>)...<span style="color: red;">H</span>(<span style="color: #329BDC;">HAVING</span>)...<span style="color: red;">O</span>(<span style="color: #329BDC;">ORDER BY</span>);

### 快速复制表

> 原理：将一个查询结果当做一张表新建
>
> ```mysql
> CREATE TABLE emp2 AS SELECT * FROM emp;
> ```
>
> 这个可以完成表的快速复制，表创建出来，同时表中的数据也存在了

## 多表设计之外键约束

> **约束的作用**：
>
> 约束是用来保证数据的完整性
>
> **单表约束与多表约束**
>
> 单表约束：
>
> - 主键约束
> - 唯一约束
> - 非空约束
>
> 多表约束
>
> - 外键约束：用来保证数据的完整性(多表之间)
>
> 通常在实际工作中，数据库中表格都不是独立存在的，且表与表之间是有种联系的，比如两张表格，一张为<span style="color: red;">分类表category</span>，一张为<span style="color: red;">商品表product</span>。在分类表中有两个信息，cid、cname，商品表中有三个数据信息pid、name、price。两张表要想有着某种联系，需要设定主键和外键两个属性，其中<span style="color: red;">在分类表（主表）中将cid设置为主键，商品表（从表）中pid设置为外键</span>
>
> **外键特点**
>
> - 从表外键的值是对主表键的引用
> - 从表外键类型，必须与主表主键类型一致
>
> **声明外键约束**
>
> ```mysql
> ALTER TABLE 从表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (从表外键字段名) REFERENCES dept(主表主键字段名);
> ```
>
> *外键名称用于删除外键约束时使用，也可不设置，一般建议“_fk”为结尾*
>
> **删除外键约束**
>
> ```mysql
> ALTER TABLE 从表名称 DROP FOREIGN KEY 外键名称
> ```
>
> *在不解除外键约束时，主表不能直接删除与从表有约束关系的数据信息*
>
> **无外键约束的演示**
>
> 环境准备：
>
> ```mysql
> -- 创建部门表
> CREATE TABLE dept(
> 	did INT PRIMARY KEY AUTO_INCREMENT,
>     dname VARCHAR(20)
> );
> -- 添加部门数据
> INSERT INTO dept VALUES (null, '市场部');
> INSERT INTO dept VALUES (null, '人事部');
> INSERT INTO dept VALUES (null, '教研部');
> 
> -- 创建员工表
> CREATE TABLE employee(
> 	eid INT PRIMARY KEY AUTO_INCREMENT,
>     ename VARCHAR(20),
>     salary DOUBLE,
>     birthday DATE,
>     sex VARCHAR(20),
>     dno INT
> );
> -- 添加员工数据
> INSERT INTO employee VALUES (null, '张三', 8000, '1988-09-01', '男', 3);
> INSERT INTO employee VALUES (null, '李四', 9000, '1988-09-01', '男', 1);
> INSERT INTO employee VALUES (null, '王五', 6000, '1988-09-01', '男', 2);
> INSERT INTO employee VALUES (null, '赵六', 10000, '1988-09-01', '男', 3);
> INSERT INTO employee VALUES (null, '孙七', 10000, '1988-09-01', '男', 1);
> ```
>
> 向员工表中插入一条记录(没有部门)
>
> ```mysql
> INSERT INTO employee VALUES (null, '田八', 10000, '1988-09-01', '男', null);
> ```
>
> 删除其中的某个部门
>
> ```mysql
> DELETE FROM dept WHERE did=2;
> ```
>
> <span style="color: red;">像上述这两个操作(插入一个没有部门的员工，删除一个带有员工的部门)。这种情况都是不应该发生的。这个时候需要在多表之间添加外键约束。</span>
>
> **添加外键约束**
>
> 在员工表上添加外键
>
> - 语法：FOREIGN KEY (外键) REFERENCES 主键表(主键列);
>
> ```mysql
> -- 设置外键为非空
> ALTER TABLE employee MODIFY dno INT NOT NULL;
> -- 在员工表上添加外键
> ALTER TABLE employee ADD FOREIGN KEY (dno) REFERENCES dept(did);
> ```

## 连接查询

> 环境准备：
>
> ```mysql
> -- 创建部门表
> DROP TABLE IF EXISTS dept; 
> CREATE TABLE dept(
> -- 部门编号
> deptno int PRIMARY KEY, 
> -- 部门名称
> dname VARCHAR(14), 
> -- 部门所在地
> loc VARCHAR(13)
> );
> 
> -- 向部门表插入数据
> INSERT INTO dept VALUES (10,'ACCOUNTING','NEW YORK');
> INSERT INTO dept VALUES (20,'RESEARCH','DALLAS');
> INSERT INTO dept VALUES (30,'SALES','CHICAGO');
> INSERT INTO dept VALUES (40,'OPERATIONS','BOSTON');
> 
> -- 创建员工表
> DROP TABLE IF EXISTS emp;
> CREATE TABLE emp(
> 	-- 员工编号
> 	empno int PRIMARY KEY, 
> 	-- 员工姓名
> 	ename VARCHAR(10), 
> 	-- 工作岗位
> 	job VARCHAR(9), 
> 	-- 直属领导
> 	mgr int, 
> 	-- 入职时间
> 	hiredate DATE, 
> 	-- 工资
> 	sal double, 
> 	-- 奖金
> 	comm double, 
> 	-- 所属部门
> 	deptno int
> );
> 
> -- 为员工表表添加外键约束
> ALTER TABLE emp ADD CONSTRAINT FOREIGN KEY EMP(deptno) REFERENCES dept (deptno);
> 
> -- 向员工表插入数据
> INSERT INTO emp VALUES(7369,'SMITH','CLERK',7902,"1980-12-17",800,NULL,20);
> INSERT INTO emp VALUES(7499,'ALLEN','SALESMAN',7698,'1981-02-20',1600,300,30);
> INSERT INTO emp VALUES(7521,'WARD','SALESMAN',7698,'1981-02-22',1250,500,30);
> INSERT INTO emp VALUES(7566,'JONES','MANAGER',7839,'1981-04-02',2975,NULL,20);
> INSERT INTO emp VALUES(7654,'MARTIN','SALESMAN',7698,'1981-09-28',1250,1400,30);
> INSERT INTO emp VALUES(7698,'BLAKE','MANAGER',7839,'1981-05-01',2850,NULL,30);
> INSERT INTO emp VALUES(7782,'CLARK','MANAGER',7839,'1981-06-09',2450,NULL,10);
> INSERT INTO emp VALUES(7788,'SCOTT','ANALYST',7566,'1987-07-03',3000,NULL,20);
> INSERT INTO emp VALUES(7839,'KING','PRESIDENT',NULL,'1981-11-17',5000,NULL,10);
> INSERT INTO emp VALUES(7844,'TURNER','SALESMAN',7698,'1981-09-08',1500,0,30);
> INSERT INTO emp VALUES(7876,'ADAMS','CLERK',7788,'1987-07-13',1100,NULL,20);
> INSERT INTO emp VALUES(7900,'JAMES','CLERK',7698,'1981-12-03',950,NULL,30);
> INSERT INTO emp VALUES(7902,'FORD','ANALYST',7566,'1981-12-03',3000,NULL,20);
> INSERT INTO emp VALUES(7934,'MILLER','CLERK',7782,'1981-01-23',1300,NULL,10);
> 
> -- 创建工资等级表
> DROP TABLE IF EXISTS salgrade;
> CREATE TABLE salgrade(
> 	-- 等级
> 	grade int, 
> 	-- 最低工资
> 	losal double, 
> 	-- 最高工资
> 	hisal double
> );
> 
> -- 向工资等级表插入数据
> INSERT INTO salgrade VALUES (1,700,1200);
> INSERT INTO salgrade VALUES (2,1201,1400);
> INSERT INTO salgrade VALUES (3,1401,2000);
> INSERT INTO salgrade VALUES (4,2001,3000);
> INSERT INTO salgrade VALUES (5,3001,9999);
> ```
>
> 从一张表中单独查询，称为单表查询
>
> emp表和dept表联合起来查询，从emp表中取员工名字，从dept表中取部门名字。这种跨表查询，多张表联合起来查询数据，被称为连接查询
>
> 两表查询之间通过主外键进行关联查询。

### 连接查询的分类

> - **内连接**
>   - 等值连接
>   - 非等值连接
>   - 自连接
> - **外链接**
>   - 左外连接(左链接)
>   - 右外连接(右连接)
> - **全连接(了解)**
>

### 笛卡尔积现象

> 笛卡尔查询(多表查询)语法：
>
> ```mysql
> SELECT * FROM <表1>，<表2>;
> ```
>
> <span style="color: red;">当两张表进行连接查询是，没有任何条件的限制时，最终查询结果条数，是两张表条数的乘积</span>(*实际上也就是把两个表或者多个表的记录排列组合在一起。但是不同的表可能会有相同的字段名，如id字段*)
>
> 查询每个员工所在部门名称
>
> ```mysql
> SELECT ename,dname FROM emp,dept; -- 每个员工的记录都会查询出所有的部门信息
> ```
>
> 如何避免笛卡尔积现象
>
> - 连接时加条件，满足这个条件的记录被筛选出来
>
>   ```mysql
>   SELECT ename,dname FROM emp,dept WHERE emp.deptno=dept.deptno;
>   ```
>
> - 最终查询的结果条数是14条，但是匹配的过程中，匹配的次数没有减少，只不过将满足条件的筛选出来而已
>
> - 给表起别名来提升效率(SQL92语法)
>
>   ```mysql
>   SELECT e.ename, d.dname FROM emp e, dept d WHERE e.deptno=d.deptno;
>   ```
>
> - 注意：通过笛卡尔积现象得出，表的连接次数越多，效率越低，尽量避免表的连接次数
>

### 内连接

> *等值连接*
>
> 查询每个员工所在部门名称，显示员工名和部门名
>
> emp e和dept d表进行连接。条件是e.deptno=d.deptno
>
> SQL92语法
>
> ```mysql
> SELECT e.ename, d.dname FROM emp e, dept d WHERE e.deptno=d.deptno;
> ```
>
> SQL99语法
>
> ```mysql
> SELECT e.ename, d.dname FROM emp e INNER JOIN dept d ON e.deptno=d.deptno; -- 可读性更好
> SELECT e.ename, d.dname FROM emp e JOIN dept d ON e.deptno=d.deptno; -- INNER可省略
> ```
>
> *带着inner的属于内连接*
>
> SQL92语法的缺点：
>
> - 结构不清晰，表的连接条件，和后期进一步筛选的条件，都放到了where后面 
>
> SQL99语法的优点：
>
> - 表连接的条件是独立，连接之后，如果还需要进一步筛选，再王后继续添加where
>
>   ```mysql
>   SELECT ... FROM a JOIN b ON a和b的连接条件 WHERE 筛选条件;
>   ```
>
> DBA：数据库管理员，主要负责算法和数据结构，几乎什么样的数据库底层原理他们都要搞一搞
>
> <span style="color: #329BDC;">等值连接指的是两张表之间的连接条件是一个等量关系</span>。
>
> *非等值连接*
>
> 找出每个员工的薪资等级，要求显示员工名、薪资、薪资等级
>
> ```mysql
> SELECT e.ename, e.sal, s.grade FROM emp e JOIN salgrade s ON e.sal BETWEEN s.losal AND s.hisal;
> ```
>
> <span style="color: #329BDC;">非等值连接指的是两张表之间的连接条件不是一个等量关系</span>。
>
> *自连接*
>
> 查询员工的上级领导，要求显示员工名和对应的领导名
>
> *由于员工和领导的信息都在同一张表上，所以需要使用一点技巧*
>
> <span style="color: #329BDC;">技巧：一张表看成两张表</span>
>
> - emp a：员工表
> - emp b：领导表
>
> ```mysql
> SELECT a.ename, b.ename FROM emp a JOIN emp b ON a.mgr=b.empno;
> -- 给a.ename取别名为员工名，b.ename取别名为领导名
> SELECT a.ename AS '员工名', b.ename AS '领导名' FROM emp a JOIN emp b ON a.mgr=b.empno; 
> ```
>
> *内连接的特点：完成能够匹配上这个条件的数据查询出来*
>

### 外链接

> *右外连接(右连接)*
>
> 查询每个员工所在部门名称，显示员工名和所有的部门名
>
> ```mysql
> SELECT e.ename, d.dname FROM emp e RIGHT JOIN dept d ON e.deptno=d.deptno; -- 省略outer
> SELECT e.ename, d.dname FROM emp e RIGHT OUTER JOIN dept d ON e.deptno=d.deptno;
> ```
>
> right：表示将join关键字右边的这张表看成主表，主要是为了将这张表的数据全部查询出来，捎带着关键查询左边的表
>
> 在外链接中，两张表连接，出现了主次关系
>
> *左外连接(左链接)*
>
> 与右外链接相同，但是使用left关键字，将join关键字的左边的这张表看成主表
>
> ```mysql
> SELECT e.ename, d.dname FROM dept d LEFT JOIN emp e ON e.deptno=d.deptno;
> ```
>
> **任何一个右连接都有左连接的写法，任何一个左连接都有右连接的写法**
>
> <span style="color: red;">外链接的查询结果条数一定 >= 内连接的查询结果条数</span>
>
> 查询每个员工的上级领导，要求显示所有员工的名字和领导名
>
> ```mysql
> SELECT a.ename AS '员工名', b.ename AS '领导名' FROM emp a LEFT JOIN emp b ON a.mgr=b.empno;
> ```
>

### 子查询

> **什么是子查询**
>
> select语句中嵌套select语句，被嵌套的select语句称为子查询
>
> **子查询都可以出现在哪里**
>
> select ..(select). from ..(select). where ..(select).

#### where子句中的子查询

> 找出比最低工资高的员工姓名和工资
>
> ```mysql
> -- where子句中不能直接使用分组函数
> SELECT ename, sal FROM emp WHERE sal > min(sal); -- 1111 - Invalid use of group function
> ```
>
> 实现思路
>
> 1. 查询最低工资是多少
>
>    ```mysql
>    SELECT min(sal) FROM emp; -- 800
>    ```
>
> 2. 找出大于800的
>
>    ```mysql
>    SELECT ename, sal FROM emp WHERE sal > 800;
>    ```
>
> 3. 合并
>
>    ```mysql
>    -- 子查询，先执行括号内的，再查询括号外的
>    SELECT ename, sal FROM emp WHERE sal > (SELECT min(sal) FROM emp);
>    ```
>

#### from子句中的子查询

> **注意：from后面的子查询，可以将子查询的查询结果当做一张临时表。(技巧)**
>
> 找出每个岗位的平均工资的薪资等级
>
> 1. 找出每个岗位的平均工资(按照岗位分组求平均值)
>
>    ```mysql
>    SELECT job, AVG(sal) FROM emp GROUP BY job;
>    ```
>
> 2. 把第一步查询的结果当做一张真实存在的表t，根据表t来查询薪资等级
>
>    1. 将薪资*表t*和薪资等级*表s*进行表连接，条件：t表的avg(sal) between s.losal and s.hisal;
>
>    ```mysql
>    SELECT t.*, s.grade FROM t JOIN salgrade s ON t.AVG(sal) BETWEEN  s.losal AND s.hisal;
>    ```
>
> 3. 修改上面的语句并进行合并
>
>    1. 给 AVG(sal) 起别名 avgsal
>
>       ```mysql
>       SELECT job, AVG(sal) AS avgsal FROM emp GROUP BY job;
>       ```
>
>    2. 将第一步的语句放入第二步中，并为其起个别名t
>
>       ```mysql
>       SELECT t.*, s.grade FROM (SELECT job, AVG(sal) AS avgsal FROM emp GROUP BY job) AS t JOIN salgrade s ON t.AVG(sal) BETWEEN  s.losal AND s.hisal;
>       ```
>
>    3. 对 t 的查询条件 t.AVG(sal) 改为对 AVG(sal) 起的别名 t.avgsal
>
>    ```mysql
>    SELECT t.*, s.grade FROM (SELECT job, AVG(sal) AS avgsal FROM emp GROUP BY job) AS t JOIN salgrade s ON t.avgsal BETWEEN  s.losal AND s.hisal;
>    ```
>

#### select子句中的子查询(了解)

> 找出每个员工的部门名称，要求显示员工名，部门名
>
> ```mysql
> SELECT e.ename, (SELECT d.dname FROM dept d WHERE e.deptno=d.deptno) FROM emp e;
> ```
>
> 注意：对于select后面的子查询来说，这个子查询只能一次返回一条结果，多于一条就报错
>
> ```mysql
> -- ERROR 1242 (21000): Subquery returns more than 1 row
> SELECT e.ename, e.deptno, (SELECT dname FROM dept) AS dname FROM emp e;
> ```
>

#### union合并查询结果集

> 查询工作岗位是MANAGER和SALESMAN的员工
>
> ```mysql
> SELECT ename,job FROM emp WHERE job='MANAGER' OR job='SALESMAN';
> SELECT ename,job FROM emp WHERE job IN('MANAGER', 'SALESMAN');
> ```
>
> 使用union进行结果集合并
>
> ```mysql
> SELECT ename,job FROM emp WHERE job='MANAGER' UNION SELECT ename,job FROM emp WHERE job='SALESMAN';
> ```
>
> - union的效率要高些。
>   - 对于表连接来说，每连接一次新表，则匹配的次数满足笛卡尔积，成倍的翻。。。
>     - a，b，c各有10条记录
>       - a 连接 b 连接 c，匹配次数是1000次
>   - 但是union可以减少匹配的次数。在减少匹配次数的情况下，还可以完成两个结果集的拼接
>     - a，b，c各有10条记录
>       - a 连接 b，匹配次数是100次
>       - a 连接 c，匹配次数是100次
>       - 使用union的话是：100 + 100 = 200次
>
> union使用时的注意事项：
>
> - union在进行结果集合并的时候，要求两个结果集的列数相同。
> - mysql中允许不同数据类型的结果集合并，oracle语法严格，会报错

## 分页查询

> 使用**LIMIT**字段
>
> limit是讲查询结果集的一部分取出来，通常使用在分页查询当中
>
> 分页的作用是为了提高用户的体验，因为一次全部都查出来，用户体验差
>
> 可以一页一页翻页看
>

#### limit使用

> 按照英语成绩降序，取出排名在前3名的学生
>
> ```mysql
> SELECT name,english FROM exam ORDER BY english DESC LIMIT 3;
> ```
>
> 完整用法：limit startIndex, length
>
> - startIndex：起始下标，默认从0开始
> - length：长度
>
> 缺省用法：limit length
>
> <span style="color: red;">注意：mysql当中limit在order by之后执行！</span>
>
> 取出排名为[3-5]的学生
>
> ```mysql
> -- 2表示起始位置从下标2开始，就是第三条记录，3表示长度
> SELECT name,english FROM exam ORDER BY english DESC LIMIT 2, 3;
> ```
>
> 取出排名在[2-5]名的学生(包含第二名和第五名)
>
> ```mysql
> SELECT name,english FROM exam ORDER BY english DESC LIMIT 1, 4;
> ```

#### 分页

> 每页显示3条记录
>
> - 第一页：limit 0, 3
>
> - 第二页：limit 3, 3
>
> - 第三页：limit 6, 3
>
> - 第四页：limit 9, 3
>
> 每页显示pageSize条记录
>
> - 第pageNo页：limit pageSize * (pageNo - 1), pageSize
>
> ```java
> public static void main(String[] args) {
>     // 用户提交过来一个页码，以及每页显示的记录条数
>     int pageNo = 5; // 
>     int pageSize = 10;
>     
>     int startIndex = (pageNo - 1) * pageSize;
>     String sql = "select ... limit" + startIndex + ", " + pageSize;
> }
> ```
>
> **通用分页公式**
>
> ```mysql
> LIMIT pageSize * (pageNo - 1), pageSize;
> ```

#### 关于DQL语句的总结

> ```mysql
> SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... DESC LIMIT ...;
> ```
>
> 执行顺序：
>
> 1. from
> 2. where
> 3. group by
> 4. having
> 5. select
> 6. order by
> 7. limit

## JDBC

> **概念**：JDBC是java访问数据库的一套标准，真正怎么操作数据库还需要具体的实现类，也就是数据库驱动。每个数据库厂商根据自家数据库定义好自己数据库的驱动，所以我们只需要调用JDBC中的接口方法使用即可，数据库驱动由厂商提供。
>
> **JDBC运行步骤**：
>
> 1. Connection接口得到DriverManager连接后返回的连接字符串
>    - DriverManager类：管理驱动连接到具体数据库(用户名，密码)
>    - Connection接口：具体的实现类由数据库厂商实现,代表一个连接对象
> 2. PreparedStatement接口去操作增删改查
> 3. 执行操作，得到结果
> 4. 如果是增删改，返回受影响行数；如果是查询则返回一个ResutSet
> 5. 查询后将结果放入到ResutSet结果集接口中

### JDBC连接数据库

> **加载驱动，连接到数据库服务器**
>
> - 格式：
>
>   ```java
>    // 将数据库驱动加载到jdbc中
>   Class.forName("com.mysql.jdbc.Driver");
>   ```
>
> **通过 DriveManager 类，设置连接字符串，用户名，密码连接到具体数据库，并返回连接字符串Connection**
>
> - 格式：
>
>   ```java
>   Connection conn = DriverManager.getConnection(url, username, password);
>   ```
>
>   - *url*：jdbc:mysql://localhost:3306/test?characterEncoding=utf-8
>     - jdbc：主协议，连接的技术
>     - mysql：子协议，连接的数据库
>     - localhost:3306：数据库地址及端口号
>     - test：要连接的数据库名称
>     - characterEncoding：设置编码格式
>     - utf-8：编码格式为utf-8
>   - *username*：连接的数据库的用户名
>   - *password*：连接的数据库的密码
>   - *conn*：连接对象，一个conn代表一个连接
>
> ```java
> try {
>     Class.forName("com.mysql.jdbc.Driver");
>     String url = "jdbc:mysql://localhost:3306/test?characterEncoding=utf-8";
>     Connection conn = DriverManager.getConnection(url, "root", "root");
>     System.out.println(conn);
> } catch (Exception e) {
>     // TODO Auto-generated catch block
>     e.printStackTrace();
> }
> ```
>
> 

### DriverManager

> **驱动管理类**
>
> 作用1：注册驱动
>
> - 方法：registerDriver(Driver driver)
>   - **这个方法可以完成驱动的注册，但实际开发中一般不会使用这个方法完成驱动的注册**
>   - 原因：
>     - **如果需要注册驱动，就会使用 DriverManager.registerDriver(new Driver());，但是查看源代码发现，在代码中有一段静态代码块，静态代码块已经调用了注册驱动的方法**
>     - **如果再手动调用该方法注册驱动，就会导致驱动被注册两次。实际开发中一般会采用 Class.forName("com.mysql.jdbc.Driver");**
>
> 作用2：获得连接
>
> - 方法：getConnection(url, username, password)
>   - 这个方法就是用来获得与数据库连接的方法：这个方法中有三个参数
>   - url：与数据库连接的路径
>     - **jdbc:mysql://localhost:3306/test?characterEncoding=utf-8**
>       - *jdbc*：连接数据库的协议
>       - *mysql*：jdbc的子协议
>       - *localhost*：连接的MySQL数据库服务器的主机地址(连接是本机可以写成localhost，如果连接不是本机的，就需要协商连接主机的 IP 地址)
>       - *3306*：MySQL数据库服务器的端口号
>       - *test*：数据库名称
>       - *characterEncoding*：设置编码格式
>       - *utf-8*：编码格式为utf-8
>     - url如果连接的是本机的路径，可以简化为如下格式：
>       - **jdbc:mysql:///test?characterEncoding=utf-8**
>   - user：与数据库连接的用户名
>   - password：与数据库连接的密码

### Connection

> **数据库连接对象**
>
> **功能：**
>
> - 获取执行sql的对象
>
>   - ```java
>     Statement createStatement()
>     ```
>
>   - ```java
>     PreparedStatement PrepareStatement(String sql)
>     ```
>
> - 管理事务
>
>   - 开启事务：
>
>     ```java
>     // 调用该方法设置参数为 false，即开启事务
>     setAutoCommit(boolean autoCommit)
>     ```
>
>   - 提交事务：
>
>     ```java
>     commit()
>     ```
>
>   - 回滚事务：
>
>     ```java
>     rollback()
>     ```

### Statement

> **执行sql的对象**
>
> - 执行sql
>
>   - 可执行任意的SQL(了解)
>
>     ```java
>     boolean execute(String sql)
>     ```
>
>   - 执行DML(*insert、update、delete*)语句、DDL(*create、alter、drop*)语句
>
>     ```java
>     int excuteUpdate(String sql)
>     ```
>
>   - 执行DQL(*select*)语句
>
>     ```java
>     ResultSet executeQuery(String sql)
>     ```
>

### JDBC操作数据库

> **加载驱动**
>
> ```java
> Class.forName("com.mysql.jdbc.Driver");
> ```
>
> **通过DriverManager类，去连接数据库，并返回Connection连接字符串对象**
>
> ```java
> String url = "jdbc:mysql://localhost:3306/test?characterEncoding=utf-8";
> String user = "root";
> String pwd = "root";
> Connection conn = DriverManager.getConnection(url, user, pwd);
> ```
>
> **准备sql**
>
> ```java
> String name = "美的电饭煲", sup = "广东顺德美的集团";
> int tid = 1002, price = 168, num = 50;
> // 添加一行数据
> String sql = "insert into goods values(null,'" + name + "," + tid + "," + price + "," + sup + ",sysdate()," + num + ")";
> ```
>
> **通过Connection连接对象，获取到Statement操作对象**
>
> *Statement接口*：
>
> - 代表一条语句对象,用于发送SQL语句给服务器,用于执行静态SQL语句,并返回结果
>
> ```java
> Statement st = conn.createStatement(sql);
> ```
>
> **Statement调用executeUpdate方法来执行sql，得到结果**
>
> *executeUpdate(sql) 执行更新(用于执行数据库的增删改)*
>
> ```java
> int row = st.executeUpdate(sql);
> System.out.println("受影响的行数" + row);
> ```
>
> **完整步骤**
>
> ```java
> Connection conn = null;
> Statement st = null;
> try {
>  Class.forName("com.mysql.jdbc.Driver");
>  conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf-8", "root", "root");
>  //新增
>  /*String name = "美的电饭煲",sup="广东顺德美的集团";
> 			int tid = 1002,price=168,num=50;
> 			String sql ="insert into goods values(null,'"+name+"',"+tid+","+price+",'"+sup+"',sysdate(),"+num+")";*/
>  //删除
>  //String sql = "delete from goods where id=4";
>  //修改
>  String sql = "update goods set sup='山东济南海尔集团' where id=3";
>  st = conn.createStatement();
>  int row = st.executeUpdate(sql);
>  System.out.println("受影响行数为:"+row);
> } catch (Exception e) {
>  e.printStackTrace();
> }finally {
>  try {
>      if(st!=null)
>          st.close();
>      if(conn!=null)
>          conn.close();
>  } catch (SQLException e) {
>      e.printStackTrace();
>  }
> }
> ```
>

### ResultSet

> **结果集对象，封装查询结果**
>
> 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true
>
> ```java
> boolean next()
> ```
>
> 获取参数
>
> ```java
> getXxx(参数)
> ```
>
> - Xxx：代表数据类型。如：int getInt()，String getString()
> - 参数：
>   - int：代表列的编号，从1开始。如：getString(1)
>   - String：代表列名称。如：getDouble("balance")
>
> *注意*：
>
> 使用步骤
>
> 1. 游标向下移动一行
> 2. 判断是否有数据
> 3. 获取数据
>
> 循环判断游标是否是最后一行末尾
>
> ```java
> while(rs.next()){}
> ```

### JDBC查询数据库

> **加载驱动**
>
> ```java
> Class.forName("com.mysql.jdbc.Driver");
> ```
>
> **通过DriverManager类，去连接数据库，并返回Connection连接字符串对象**
>
> ```java
> String url = "jdbc:mysql://localhost:3306/test?characterEncoding=utf-8";
> String user = "root";
> String pwd = "root";
> Connection conn = DriverManager.getConnection(url, user, pwd);
> ```
>
> **准备sql**
>
> ```java
> String sql = "select * from users";
> ```
>
> **通过Connection连接对象，获取到Statement操作对象**
>
> ```java
> st = conn.createStatement();
> ```
>
> **Statement调用executeQuery方法来执行sql，并返回一个ResultSet结果集**
>
> ```java
> rs = st.executeQuery(sql);
> ```
>
> **从结果集中获取出查询表的内容**
>
> *statement查询操作*：
>
> - rs.next() 判断下一行是否有数据，获取一行后指针向下移动，没有数据则返回false
> - rs.getInt() 有两种方法，一种为括号內参数填写列号；另一种括号內参数填列名，如果sql语句中有起别名，那么列名就是别名
>
> ```java
> // 循环遍历结果集
> while(rs.next()){
>   //有一行数据,则取出每一个列的数据
>   System.out.println("登录成功!用户ID:"+rs.getInt(1)+", 用户名为:"+rs.getString("name")+", 密码为:"+rs.getString(3));
> }
> ```
>
> **完整步骤**
>
> ```java
> Connection conn = null;
> Statement st = null;
> ResultSet rs = null;
> try {
>      Class.forName("com.mysql.jdbc.Driver");
>      conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf-8", "root", "root");
>      String sql = "select * from users";
>      st = conn.createStatement();
>      rs = st.executeQuery(sql);
>      while(rs.next()){
>      	//有一行数据,则取出每一个列的数据
>      	System.out.println("登录成功!用户ID:"+rs.getInt(1)+", 用户名为:"+rs.getString("name")+", 密码为:"+rs.getString(3));
>      }
> } catch (Exception e) {
> 	e.printStackTrace();
> } finally {
> 	try {
>          if(rs!=null)
>              rs.close();
>          if(st!=null)
>              st.close();
>          if(conn!=null)
>              conn.close();
>  } catch (SQLException e) {
> 		e.printStackTrace();
> 	}
> }
> ```

### PreparedStatement

> **什么是SQL注入**
>
> 在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题
>
> - 输入用户名随便，输入密码：'123456' or '1' = '1'
> - sql：select * from users where name = 'asbdqia' and password = '123456' or '1' = '1'
>   - **sql注入 在sql中注入 or 1=1，在拼接时，不是将该语句认为是一个值，而是拼接成了语句。1=1 表示条件恒成立**
>   - **注入 or 1=1，会将表内所有的数据查询出来(select * from users where 1=1 相当于 select * from users)**
>
> ```java
> Class.forName("com.mysql.jdbc.Driver");
> String url = "jdbc:mysql://localhost:3306/test?characterEncoding=utf-8";
> Connection conn = DriverManager.getConnection(url, "root", "root");
> // 登录操作，注入密码sql
> String name="admin";
> String pwd = "123456 or 1=1";
> String sql = "select * from users where name='"+ name +"' and password=" + pwd;
> Statement st = conn.createStatement();
> ResultSet rs = st.executeQuery(sql);
> while(rs.next()){
>     System.out.println("登录成功!用户ID:"+rs.getInt(1)+", 用户名为:"+rs.getString("name")+", 密码为:"+rs.getString(3));
> }
> ```
>
> **如何避免**
>
> MySQL 中使用 PreparedStatement 接口
>
> - 是 Statement 接口的子接口，解决在 sql 拼接时造成的 sql 注入问题，这时候设置的值不会呈现结构的方式
> - PreparedStatement 接口以预编译 sql 的方式解决拼接的问题，每一个参数的地方使用 ？作为占位符
> - 再使用setXXX()方法设置对应类型对应位置的值，下标位置从1开始
>
> ```java
> // 加载驱动
> Class.forName("com.mysql.jdbc.Driver");
> // 获取连接字符串对象
> String url = "jdbc:mysql://localhost:3306/test?characterEncoding=utf-8";
> Connection conn = DriverManager.getConnection(url, "root", "root");
> // 准备SQL
> String name = "admin";
> String pwd = "123456 or 1=1";
> String sql = "select * from users where name=? and password=?";
> // 通过conn获取到执行对象，并预编译sql语句
> PreparedStatement pst = conn.prepareStatement(sql);
> // 为占位符赋值，有占位符就赋值，没有就不需要赋值
> pst.setString(1, name);
> pst.setString(2, pwd);
> // 执行sql，并得到结果
> rs = pst.executeQuery();
> // 循环遍历结果集，如果明确知道最多只有一个结果，可以使用判断
> if(rs.next()){
>      System.out.println("登录成功!用户ID:"+rs.getInt(1)+", 用户名为:"+rs.getString("name")+", 密码为:"+rs.getString(3));
> }else{
>     System.out.println("登录失败");
> }
> ```

### 通过对象进行增删改查

#### 设计类对象

> **类是根据数据库表设计出来的，表名对应类名，字段名对应属性名**

#### 添加记录

> 

#### 修改记录

> 

#### 删除记录

> 

#### 查询记录

> 

### DOA模式

> 规定一种只做数据库交互的模式
>
> DAO设计模式使数据访问和业务逻辑分离,增加高内聚低耦合,提高代码的复用率.
>
> DAO设计模式中,每个实体类对应一个接口设计

### JDBC工具类

> 抽取JDBC工具类：JDBCUtils
>
> **目的**：简化书写
>
> 分析：
>
> 1. 注册驱动也抽取
>
> 2. 抽取一个方法获取连接对象
>
>    1. 需求：不想传递参数(麻烦)，还得保证工具类的通用性
>
>    2. 解决方案：配置文件 jdbc.properties
>
>       ```properties
>       #Tue Sep 28 17:07:50 CST 2021
>       #mysql配置
>       driver=com.mysql.jdbc.Driver
>       password=root
>       username=root
>       url=jdbc:mysql://localhost:3306/test?characterEncoding=utf-8
>    
>       #Oracle配置
>       #driver=......
>       #url=......
>       #username=....
>       #password=......
>       ```
>
> 3. 抽取一个方法释放资源
>
> ```java
> import java.io.FileReader;
> import java.net.URL;
> import java.sql.Connection;
> import java.sql.DriverManager;
> import java.sql.PreparedStatement;
> import java.sql.ResultSet;
> import java.sql.SQLException;
> import java.util.Properties;
> 
> public class JDBCUtils {
> 	private static String url;
> 	private static String user;
> 	private static String password;
> 
> 	static {
> 		try {
> 			// 创建properties集合类
> 			Properties pro = new Properties();
> 			// 获取src路径下的文件的方式--->ClassLoader 类加载器
> 			ClassLoader classLoader = JDBCUtils.class.getClassLoader();
> 			URL res = classLoader.getResource("jdbc.properties");
> 			String path = res.getPath();
> 			System.out.println(path);
> 			// 加载文件
> 			pro.load(new FileReader(path));
> 			// 获取数据，赋值
> 			url = pro.getProperty("url");
> 			user = pro.getProperty("user");
> 			password = pro.getProperty("password");
> 			Class.forName(pro.getProperty("driver"));
> 		} catch (Exception e) {
> 			// TODO Auto-generated catch block
> 			e.printStackTrace();
> 		}
> 	}
> 
> 	/**
> 	 * 获取连接对象
> 	 * 
> 	 * @return 连接对象
> 	 * @throws SQLException
> 	 */
> 	public static Connection getConnection() throws SQLException {
> 		return DriverManager.getConnection(url, user, password);
> 	}
> 
> 	/**
> 	 * 释放资源
> 	 * 
> 	 * @param pst
> 	 * @param conn
> 	 */
> 	public static void close(PreparedStatement pst, Connection conn) {
> 		try {
> 			if (pst != null)
> 				pst.close();
> 			if (conn != null)
> 				conn.close();
> 		} catch (SQLException e) {
> 			e.printStackTrace();
> 		}
> 	}
> 
> 	/**
> 	 * 释放资源(重载)
> 	 * 
> 	 * @param rs
> 	 * @param pst
> 	 * @param conn
> 	 */
> 	public static void close(ResultSet rs, PreparedStatement pst, Connection conn) {
> 		try {
> 			if (rs != null)
> 				rs.close();
> 			if (pst != null)
> 				pst.close();
> 			if (conn != null)
> 				conn.close();
> 		} catch (SQLException e) {
> 			e.printStackTrace();
> 		}
> 	}
> }
> ```
>

#### 添加增删改查模块

> ```java
> import java.io.InputStream;
> import java.sql.Connection;
> import java.sql.DriverManager;
> import java.sql.PreparedStatement;
> import java.sql.ResultSet;
> import java.sql.SQLException;
> import java.util.ArrayList;
> import java.util.List;
> import java.util.Properties;
> 
> // 如果使用泛型属性或方法,类设置为泛型类
> public abstract class JDBCUtils<T> {
> 	private static String url;
> 	private static String user;
> 	private static String password;
> 
> 	private PreparedStatement pst = null;
> 	private Connection conn = null;
> 	private ResultSet rs = null;
> 
> 	static {
> 		try {
> 			// 创建properties集合类
> 			Properties pro = new Properties();
> 			// 读取文件,加载到输入流
> 			// 通过当前类找到对应的资源文件夹中对应的文件,并转换为流
> 			InputStream in = JDBCUtils.class.getClassLoader().getResourceAsStream("jdbc.properties");
> 			// 加载文件
> 			pro.load(in);
> 			// 获取数据，赋值
> 			url = pro.getProperty("url");
> 			user = pro.getProperty("user");
> 			password = pro.getProperty("password");
> 			Class.forName(pro.getProperty("driver"));
> 		} catch (Exception e) {
> 			// TODO Auto-generated catch block
> 			e.printStackTrace();
> 		}
> 	}
> 
> 	/**
> 	 * 获取连接对象
> 	 * 
> 	 * @return 连接对象
> 	 * @throws SQLException
> 	 */
> 	public Connection getConnection() throws SQLException {
> 		return DriverManager.getConnection(url, user, password);
> 	}
> 
> 	/**
> 	 * 更新数据库数据 Object...obj是一个可变长度数组,如果没有参数传入则长度为0,传入多少个参数,长度就是参数的个数
> 	 * 
> 	 * @param sql:
> 	 *            sql语句
> 	 * @param obj:
> 	 *            这个数组会自动匹配除sql以外的所有参数,且obj这个数组必须方法形参的末尾,前面的形参固定匹配
> 	 * @return 成功 true，失败 false
> 	 */
> 	public boolean update(String sql, Object... obj) {
> 		PreparedStatement pst = null;
> 		Connection conn = null;
> 		try {
> 			conn = getConnection();
> 			pst = conn.prepareStatement(sql);
> 			// 赋值,利用循环的方式,将数组中的数据赋值,没有数据则不进入循环
> 			for (int i = 0; i < obj.length; i++) {
> 				pst.setObject(i + 1, obj[i]);
> 			}
> 			int row = pst.executeUpdate();
> 			if (row > 0)
> 				return true;
> 		} catch (Exception e) {
> 			// TODO Auto-generated catch block
> 			e.printStackTrace();
> 		} finally {
> 			close(pst, conn);
> 		}
> 
> 		return false;
> 	}
> 
> 	/**
> 	 * 查询数据库
> 	 * 
> 	 * @param sql:
> 	 *            sql语句
> 	 * @param obj:
> 	 *            这个数组会自动匹配除sql以外的所有参数,且obj这个数组必须方法形参的末尾,前面的形参固定匹配
> 	 * @return 返回ArrayList<T>()
> 	 */
> 	public List<T> query(String sql, Object... obj) {
>         // 统一的返回集合,查询对象也可以放入集合中
> 		List<T> list = new ArrayList<>();
> 		try {
> 			conn = getConnection();
> 			pst = conn.prepareStatement(sql);
>             // 赋值,利用循环的方式,将数组中的数据赋值,没有数据则不进入循环
> 			for (int i = 0; i < obj.length; i++) {
> 				pst.setObject(i + 1, obj[i]);
> 			}
> 			rs = pst.executeQuery();
> 			while (rs.next()) {
> 				// 通过抽象方法,被子类重写的方式,获得具体对象
> 				T t = getEntity(rs);
> 				// 将每次返回的对象,放入到集合中
> 				list.add(t);
> 			}
> 		} catch (Exception e) {
> 			e.printStackTrace();
> 		} finally {
> 			close(rs, pst, conn);
> 		}
> 
> 		return list;
> 
> 	}
> 	// 通过子类重写方法的方式,获取到具体对象
> 	public abstract T getEntity(ResultSet rs) throws SQLException;
> 
> 	/**
> 	 * 释放资源
> 	 * 
> 	 * @param pst
> 	 * @param conn
> 	 */
> 	public void close(PreparedStatement pst, Connection conn) {
> 		try {
> 			if (pst != null)
> 				pst.close();
> 			if (conn != null)
> 				conn.close();
> 		} catch (SQLException e) {
> 			e.printStackTrace();
> 		}
> 	}
> 
> 	/**
> 	 * 释放资源(重载)
> 	 * 
> 	 * @param rs
> 	 * @param pst
> 	 * @param conn
> 	 */
> 	public void close(ResultSet rs, PreparedStatement pst, Connection conn) {
> 		try {
> 			if (rs != null)
> 				rs.close();
> 			if (pst != null)
> 				pst.close();
> 			if (conn != null)
> 				conn.close();
> 		} catch (SQLException e) {
> 			e.printStackTrace();
> 		}
> 	}
> }
> ```
>

#### 调用工具类

> **继承抽象类 JDBCUtils，重写抽象方法**
>
> ```java
> public class GoodsDaoImpl extends JDBCUtils<Goods> {
>     @Override
>     public Goods getEntity(ResultSet rs) throws SQLException {
>         Goods g = new Goods();
>         g.setId(rs.getInt(1));
>         g.setName(rs.getString(2));
>         g.setTid(rs.getInt(3));
>         g.setPrice(rs.getDouble(4));
>         g.setSup(rs.getString(5));
>         g.setOutDate(rs.getDate(6));
>         g.setNum(rs.getInt(7));
>         return g;
>     }
> }
> ```
>
> **查询**
>
> ```java
> // 查询全部
> public List<Goods> findAll() {
>     return query("select * from goods");
> }
> // 条件查询
> public Goods findById(int id) {
>     List<Goods> list = query("select * from goods where id=?", id);
>     // 集合已经创建,要判断的是集合中是否有数据
>     if (list.size() > 0) {
>         return list.get(0); // 因为集合中只有一个对象,所以获取第一个元素即可
> 	}
>     return null;
> }
> ```
>
> **更新**
>
> ```java
> // 修改
> public boolean update(Goods goods) {
>     return update("update goods set name=?,tid=?,price=?,sup=?,num=? where id=?", goods.getName(), goods.getTid(),
>                   goods.getPrice(), goods.getSup(), goods.getNum(), goods.getId());
> }
> // 删除
> public boolean delete(int id) {
>     return update("delete from goods where id=?", id);
> }
> // 添加
> public boolean save(Goods goods) {
>     return update("insert into goods values(null,?,?,?,?,sysdate(),?)", goods.getName(), goods.getTid(),
>                   goods.getPrice(), goods.getSup(), goods.getNum());
> }
> ```

##### 整体

> ```java
> // DAO设计模式
> public interface GoodsDao {
> 	public List<Goods> findAll();
> 
> 	public Goods findById(int id);
> 
> 	public boolean save(Goods goods);
> 
> 	public boolean update(Goods goods);
> 
> 	public boolean delete(int id);
> }
> // 功能实现
> public class GoodsDaoImpl extends JDBCUtils<Goods> implements GoodsDao {
> 	Connection conn = null;
> 	PreparedStatement pst = null;
> 	ResultSet rs = null;
> 
> 	@Override
> 	public List<Goods> findAll() {
> 		return query("select * from goods");
> 	}
> 
> 	@Override
> 	public Goods findById(int id) {
> 		List<Goods> list = query("select * from goods where id=?", id);
> 		// 集合已经创建,要判断的是集合中是否有数据
> 		if (list.size() > 0)
> 			return list.get(0); // 因为集合中只有一个对象,所以获取第一个元素即可
> 		
> 		return null;
> 	}
> 
> 	@Override
> 	public boolean save(Goods goods) {
> 		return update("insert into goods values(null,?,?,?,?,sysdate(),?)", goods.getName(), goods.getTid(),
> 				goods.getPrice(), goods.getSup(), goods.getNum());
> 	}
> 
> 	@Override
> 	public boolean update(Goods goods) {
> 		return update("update goods set name=?,tid=?,price=?,sup=?,num=? where id=?", goods.getName(), goods.getTid(),
> 				goods.getPrice(), goods.getSup(), goods.getNum(), goods.getId());
> 	}
> 
> 	@Override
> 	public boolean delete(int id) {
> 		return update("delete from goods where id=?", id);
> 	}
> 
> 	@Override
> 	public Goods getEntity(ResultSet rs) throws SQLException {
> 		Goods g = new Goods();
> 		g.setId(rs.getInt(1));
> 		g.setName(rs.getString(2));
> 		g.setTid(rs.getInt(3));
> 		g.setPrice(rs.getDouble(4));
> 		g.setSup(rs.getString(5));
> 		g.setOutDate(rs.getDate(6));
> 		g.setNum(rs.getInt(7));
> 		return g;
> 	}
> }
> ```

#### 外键查询对象

> 







