## 数据库概述

> 在Java变量集合中存储的数据，在运行时存在，程序结束后会消失，当数据需要持久存储时，Java无法办到需要使用工具将数据持久存储到硬盘。数据库是最优势的选择
>
> **概念**：
>
> 数据库是一套数据库存储管理系统，包含数据库和数据库管理系统

## MySQL

> MySQL数据是一种关系型数据库
>
> SQL：结构化查询语言
>
> 其实就是定义操作所有关心型数据库的规则，每一种数据库操作的方式存在不一样的地方，称为"方言"
>
> MySQL数据是一种关系型数据,由瑞典MySQL AB公司打造,被Oracle收购,其体积小、速度快、总体拥有成本低,被广大中小型企业应用

## 通用语法

> 1. sql语句可以单行或多行书写，以分号结束
> 2. 可以使用空格和缩进来增强语句的可读性
> 3. mysql数据库的SQL语句不区分大小写，关键字建议大写
> 4. 注释：
>    1. '-- '  单行注释
>    2. '#'    注释内容
>    3. '/**/' 多行注释
>

## SQL分类

> - DDL数据定义语言：用来定义数据库内容 数据库，表，列等相关结构操作语句
>   - create，drop，alter
> - DML数据操作语言：用来对数据库表中数据的操作
>   - insert，updata，delect
> - DQL数据库查询语言
>   - select，where
> - DCL数据控制语言：用来定义数据库访问权限,安全级别,创建用户的操作
>  - grand，if，revoke

## SQL语句的使用

> - *创建数据库*
>
>   - 语法：create database 数据库名称 character set 字符集 collate 字符集校对规则;
>
>     ```mysql
>     -- 创建一个默认字符集和校对的数据库db1
>     CREATE DATABASE db1;
>     -- 创建一个GBK字符集和GBK默认校对的数据库db2
>     CREATE DATABASE db2 CHARACTER SET GBK;
>     -- 创建一个utf8字符集和utf8_bin校对的数据库db3
>     CREATE DATABASE db3 CHARACTER SET utf8 COLLATE utf8_bin;
>     -- 如果不存在数据库db4，则创建该数据库
>     CREATE DATABASE IF NOT EXISTS db3;
>     ```
>
> - *查看数据库*
>
>   - 查看数据库服务器中所有的数据库：show database;
>
>     ```mysql
>     SHOW DATABASE;
>     ```
>
>   - 查看某个数据库的定义信息：show create database 数据库名称;
>
>     ```mysql
>     SHOW CREATE DATABASE db3;
>     ```
>
> - *修改数据库*
>
>   - 语法：alter database 数据库名称 character set 字符集 collate 校对规则;
>
>     ```mysql
>     ALTER DATABASE db2 CHARACTER SET utf8;
>     ```
>
> - *删除数据库*
>
>   - 语法：Drop database 数据库名称
>
>     ```mysql
>     DROP DATABASE db1;
>     ```
>     
>   - 判断数据库存在, 则删除
>
>     - 格式：drop database if exists 数据库名;
>
>     ```mysql
>     DROP DATABASE IF EXISTS db1;
>     ```
>
> - *其他数据库操作*
>
>   - 切换数据库：user 数据库名称
>
>     ```mysql
>     USER db3;
>     ```
>
>   - 查看当前正在使用的数据库：select database();
>
>     ```mysql
>     SELECT DATABASE();
>     ```

## SQL对数据库表的操作

#### 创建表

> 语法：<span style="color: red;">create table 表名称</span>(<span style="color: #329BDC;">字段名称 字段类型(长度) 约束, 字段名称 字段类型(长度) 约束</span>);
>
> 字段类型：一个实体对应一个表，一个实体属性对应表的一个字段
>
> | Java中的类型 |                    MySQL的类型                     |
> | :----------: | :------------------------------------------------: |
> |     byte     |                      tinyint                       |
> |    short     |                      smallint                      |
> |     int      |                        int                         |
> |     long     |                       bigint                       |
> |    float     |                       float                        |
> |    double    |                       double                       |
> |   boolean    |                        bit                         |
> | char/String  |                   char和varchar                    |
> |     Date     |            date/time/datetime/timestamp            |
> |     File     | BLOB(二进制文件，例如图片)/TEXT(文本文件，例如txt) |
>
> **char和varchar的区别**：
>
> - char：代表的是固定长度的字符或字符串
>   - 定义类型char(8)，向这个字段存入字符串hello，那么数据库使用三个空格将其补全
> - varchar：代表的是可变长度的字符串
>   - 定义类型varchar(8)，向这个字段存入字符串hello，那么存入到数据库的就是hello
>
> **datetime和timestamp的区别**：
>
> - datetime：就是既有日期又有时间的日期类型，如果没有向这个字段中存值，数据库使用null存入到数据库中
> - timestamp(时间戳)：也是既有日期又有时间的日期类型，如果没有向这个字段中存值，数据库会使用当前的系统时间存入到数据库中
>
> **约束**：
>
> 作用：暴走数据的完整性
>
> 单表约束分类：
>
> - 主键约束：
>   - 主键约束在表中定义一个主键来唯一确定表中每一行数据的标识符
>   - 关键字：primary key 
>   - 主键约束默认就是唯一，非空的
> - 唯一约束：
>   - 所有记录中字段的值不能重复出现
>   - 关键字：unique
> - 非空约束：
>   - 表中的某一个字段的内容不允许为空
>   - 关键字：not null
>
> **建表语句**：
>
> ```mysql
> CREATE DATABASE web_test1;
> -- 通过使用该数据库来跳转到该数据库
> USE web_test1;
> CREATE TABLE user(
> 	id int primary key auto_increment,
> 	username VARCHAR(20) unique,
> 	password VARCHAR(20) not null,
>     age int,
>     birthday date
> );
> ```
>

#### SQL语句部分关键字

> **DEFAULT**：
>
> 用于在建表时给予字段默认值
>
> 语法：**字段名称 字段类型(长度) 约束 DEFAULT 默认值;**
>
> ```mysql
> CREATE TABLE user(
> 	id int primary key auto_increment,
> 	username VARCHAR(20) unique,
> 	password VARCHAR(20) not null,
>     age int DEFAULT 0, -- 若age项在插入数据时没有给予数据，则使用默认值0
>     birthday date
> );
> ```
>
> **COMMENT**：
>
> 用来给字段或列添加注释
>
> 语法：**字段名称 字段类型(长度) 约束 DEFAULT 默认值 COMMENT 注释;**
>
> ```mysql
> CREATE TABLE test(
> 	id int NOT NULL DEFAULT 0 COMMENT '用户id',
> );
> ```
>
> **CONSTRAINT**：
>
> 主要就是增加数据约束的
>
> 语法：CONSTRAINT 字段名称 约束(要添加约束的字段名称)
>
> ```mysql
> create table goods(
> 	id int(10) auto_increment,
> 	-- 主键约束
> 	CONSTRAINT goods_id_pk PRIMARY key(id)
> );
> ```
>
> **EXISTS**：

#### 查看表

> - 查看某个数据库下的所有的表
>
>   - 语法：show tables;
>
>     ```mysql
>     show tables;
>     ```
>
> - 查看某个表的结构信息
>
>   - 语法：desc 表名;
>
>     ```mysql
>     desc user;
>     ```
>

#### 删除表

> 语法：drop table 表名;
>
> ```mysql
> drop table user;
> ```
>

#### 修改表

> - 修改表：添加列
>
>   - alter table 表名 add 列名 类型(长度) 约束;
>
>     ```mysql
>     ALTER TABLE user ADD inage VARCHAR(100);
>     ```
>
> - 修改表：修改列类型，长度和约束
>
>   - alter table 表名 modify 列名 类型(长度) 约束;
>
>     ```mysql
>     ALTER TABLE user MODIFY VARCHAR(150);
>     ```
>
> - 修改表：删除列
>
>   - alter table 表名 drop 列名;
>
>     ```mysql
>     ALTER TABLE user DROP age;
>     ```
>
> - 修改表：修改列名称
>
>   - alter table 表名 change 旧列名 新列名 类型(长度) 约束;
>
>     ```mysql
>     ALTER TABLE user CHANGE inage pic VARCHAR(150);
>     ```
>
> - 修改表：修改表名
>
>   - rename table 表名 to 新的表名;
>
>     ```mysql
>     RENAME TABLE user TO employee;
>     ```
>
> - 修改表：修改表的字符集
>
>   - alter table 表名 character set 字符集
>
>     ```mysql
>     ALTER TABLE user CHARACTER SET gbk;
>     ```
>

#### 对数据库表的记录进行操作

##### 添加表的记录

> 语法：
>
> - 向表中插入某些列：insert into 表名(列名1, 列名2, 列名3...) values(值1, 值2, 值3...);
>
>   ```mysql
>   INSERT INTO user (id, username, password) VALUES (null, 'aaa', '123');
>   ```
>
> - 向表中插入所有列：insert into 表名 values(值1, 值2, 值3...);
>
>   ```mysql
>   INSERT INTO user VALUES (null, 'bbb', '123', 23, '1993-09-01');
>   ```
>
> - 注意事项
>
>   - 值的类型与数据库中表列的类型一致
>   - 值的顺序与数据库中表列的顺序一致
>   - 值的最大长度不能超过列设置的最大长度
>   - 值的类型是字符串或者是日期类型，使用单引号引起来
>
> 添加中文记录：
>
> <span style="color: red;">直接向数据库中插入中文记录会出现错误！</span>
>
> ```mysql
> -- 查询与字符集相关的参数
> show variables like '%character%';
> ```
>
> 解决办法：将MySQL数据库服务器中的客户端部分的字符集改成gbk
>

##### 修改表的记录

> 语法：update 表名 set 列名=值, 列名=值 [where 条件];
>
> *注：[]内为可选项*
>
> ```mysql
> -- 修改某一列的所有值
> UPDATE user SET password='abc';
> -- 按条件修改数据
> UPDATE user SET password='xyz' WHERE username='bbb';
> -- 修改多个列
> UPDATE user SET password='123',age=34 WHERE username = 'aaa';
> ```
>
> 注意事项：
>
> - 值的类型与列的类型一致
> - 值的最大长度不能超过列设置的最大长度
> - 字符串类型和日期类型添加单引号
>

##### 删除表的记录

> 语法：delete 表名 [where 条件];
>
> - 删除某一条记录：
>
>   ```mysql
>   DELETE FROM user WHILE id = 2;
>   ```
>
> - 删除表中的所有记录：
>
>   ```mysql
>   DELETE FROM user;
>   ```
>
> 注意事项：
>
> - 删除表的记录，指的是删除表中的一行记录
> - 删除如果没有条件，默认是删除表中的所有记录
>
> 删除表中记录的两种做法：
>
> - delete from user;
>   - 属于DML语句
>   - 删除所有记录，一条一条的删除记录
>   - 事物可以作用在DML语句上的
>   - 删除后可以回滚恢复
> - truncate table user;
>   - 属于DDL语句
>   - 删除所有记录，将表删除，然后重新创建一个结构一样的表
>   - 事物不能控制DDL的
>   - 删除后不能恢复
> - start transaction 开启事物；roolback 回滚
>

##### 查看表的记录

> 环境准备：
>
> ```mysql
> CREATE TABLE exam(
> 	id INT PRIMARY KEY AUTO_INCREMENT, -- AUTO_INCREMENT自动增量
>     name VARCHAR(20),
>     english INT,
>     chinese INT,
>     math INT
> );
> 
> INSERT INTO exam VALUES (null, '张三', 85, 74, 91);
> INSERT INTO exam VALUES (null, '李四', 95, 90, 83);
> INSERT INTO exam VALUES (null, '王五', 85, 84, 59);
> INSERT INTO exam VALUES (null, '赵六', 75, 79, 76);
> INSERT INTO exam VALUES (null, '田七', 69, 63, 98);
> INSERT INTO exam VALUES (null, '李老八', 89, 90, 83);
> ```
>

###### 基本查询

> - 语法：
>
>   - select[distinct] *|列名 from 表 [条件];
>
> - 查询所有学生考试成绩信息
>
>   ```mysql
>   SELECT * FROM exam;
>   ```
>
> - 查询所有学生的姓名和英语成绩
>
>   ```mysql
>   SELECT name, english FROM exam;
>   ```
>
> - 查询英语成绩信息(不显示重复值)
>
>   ```mysql
>   SELECT DISTINCT english FROM exam;
>   ```
>
> - 查看学生姓名和学生的总成绩
>
>   ```mysql
>   SELECT name, english+chinese+math FROM exam;
>   ```
>
> - 别名查询
>
>   - 如果别名有空格，使用双引号引起来
>
>   ```mysql
>   SELECT name, english+chinese+math AS sum FROM exam;	-- as可省略
>   SELECT name, english+chinese+math sum FROM exam;
>   ```
>

###### 条件查询

> - 使用where子句
>
>   - <，>，>=，<=，<>，=，!=
>
>   - like：模糊查询
>
>   - in：范围查询
>
>     ```mysql
>     -- 查询deptno值是10或是20的数据
>     SELECT * FROM emp WHERE deptno in (10,20);
>     ```
>
>   - is null 为null (is not null) 不为空
>
>   - 条件关联：
>
>     - and：并且
>     - or：或者
>     - not：可以取非，主要用在is和in中
>
>   - between...and...：两个值之间，等同于 >= AND <=
>
> - 查询李四学生的成绩：
>
>   ```mysql
>   SELECT * FROM exam WHERE name='李四';
>   ```
>
> - 查询名称叫李四的学生，并且英文大于90分：
>
>   ```mysql
>   SELECT * FROM exam WHERE name='李四' AND english>90;
>   ```
>
> - 查询姓李的学生的信息
>
>   - like可以进行模糊查询，在like子句中可以使用_下划线_或者%作为占位符。_下划线_只能代表一个字符，而%可以代表任意个字符。
>   - like '李_'：名字中必须是两个字，而且是姓李的
>   - like '李%'：名字中是姓李的学生，李字后可以是1个或任意个字符
>   - like '%四'：以四结尾的
>   - like '%王%'：只要名称中包含这个字就可以
>
>   ```mysql
>   SELECT * FROM exam WHERE name LIKE '李%'; -- 查询所有姓李的学生
>   SELECT * FROM exam WHERE name LIKE '李_'; -- 查询所有名字是两个字，而且是姓李的学生
>   SELECT * FROM exam WHERE name LIKE '李%' AND english>90; -- 查询所有姓李且英语成绩大于90分的学生
>   ```
>
> - 查询英语成绩是69，75，89的学生的信息
>
>   ```mysql
>   SELECT * FROM exam WHERE english in (69, 75, 89);
>   ```
>

###### 排序查询

> 使用**order by**字段
>
> - asc：升序排序(默认，从小到大)
> - desc：降序排序(从大到小)
>
> 查询学生信息，并且按照语文成绩进行排序
>
> ```mysql
> SELECT * FROM exam ORDER BY chinese;
> SELECT * FROM exam ORDER BY chinese ASC;
> ```
>
> 查询学生信息，并且按照语文成绩进行倒序排序
>
> ```mysql
> SELECT * FROM exam ORDER BY chinese DESC;
> ```
>
> 查询学生信息，先按照语文成绩进行倒序排序，如果成绩相同，再按照英语成绩升序排序
>
> ```mysql
> SELECT * FROM exam ORDER BY chinese DESC, english ASC;
> ```
>
> 查询姓李的学生的信息，按照英语成绩降序排序
>
> - <span style="color: red;">若有查询条件，则要先添加查询条件，后使用排序查询</span>
>
> ```mysql
> SELECT * FROM exam WHERE name LIKE '李%' ORDER BY english DESC;
> ```
>

###### 分组统计查询

> **聚合函数使用**
>
> - SUM();：求和
>
>   - 获取所有学生的英语成绩的总和
>
>     ```mysql
>     SELECT SUM(english) FROM exam;
>     ```
>
>   - 获取所有学生的英语成绩和数学成绩的总和
>
>     ```mysql
>     SELECT SUM(english), SUM(math) FROM exam;
>     ```
>
>   - 查询姓李的学生的英语成绩和数学成绩的总和
>
>     ```mysql
>     SELECT SUM(english), SUM(math) FROM exam WHERE name LIKE '李%';
>     ```
>
>   - 查询所有学生各科的总成绩
>
>     ```mysql
>     -- 按照列的方式统计，英语成绩总和+语文成绩总和+数学成绩总和
>     SELECT SUM(english)+SUM(math)+SUM(chinese) FROM exam;
>
>     -- 按照行的方式统计，先计算英语+语文+数学，然后再求和
>     SELECT SUM(english+math+chinese) FROM exam; -- 有null时数据会出现误差，可以使用
>     ```
>
>   - *SELECT SUM(english+math+chinese) FROM exam;*这种方式在数据中有null时会出现误差，可以使用**ifnull**的函数
>
>     ```mysql
>     SELECT SUM(IFNULL(english, 0) + IFNULL(math, 0) + IFNULL(chinese, 0)) FROM exam;
>     ```
>
> - COUNT();：计数
>
>   - 获得学生的总数
>
>     ```mysql
>     SELECT COUNT(*) FROM exam;
>     ```
>
>   - 获得姓李的学生的个数
>
>     ```mysql
>     SELECT COUNT(*) FROM exam WHERE name LIKE '李%';
>     SELECT COUNT(*) AS li FROM exam WHERE name LIKE '李%'; -- 使用as起别名
>     ```
>
> - MAX();：获取最大值
>
>   - 获得数学成绩的最高分
>
>     ```mysql
>     SELECT MAX(math) FROM exam;
>     ```
>
> - MIN();：获取最小值
>
>   - 获得语文成绩的最低分
>
>     ```mysql
>     SELECT MIN(chinese) FROM exam;
>     ```
>
> - AVG();：获取平均值
>
>   - 求语文成绩的平均分
>
>     ```mysql
>     SELECT SUM(chinese)/COUNT(*) FROM exam;
>     SELECT AVG(chinese) FROM exam;
>     ```
>
> **分组查询**
>
> 概念：*将数据库中的数据按照某一字段来进行分组查询*
>
> 语法：**GROUP BY 字段名称;**
>
> 环境准备：
>
> ```mysql
> -- 购买的商品订单表
> CREATE TABLE orderitem(
> 	id INT PRIMARY KEY AUTO_INCREMENT,
>     product VARCHAR(20),
>     price DOUBLE
> );
> -- 添加数据
> INSERT INTO orderitem VALUES (null, '电视机', 2999);
> INSERT INTO orderitem VALUES (null, '电视机', 2999);
> INSERT INTO orderitem VALUES (null, '洗衣机', 1000);
> INSERT INTO orderitem VALUES (null, '洗衣机', 1000);
> INSERT INTO orderitem VALUES (null, '洗衣机', 1000);
> INSERT INTO orderitem VALUES (null, '冰箱', 3999);
> INSERT INTO orderitem VALUES (null, '冰箱', 3999);
> INSERT INTO orderitem VALUES (null, '空调', 1999);
> ```
>
> 按商品名称统计，每类商品所购买的个数
>
> ```mysql
> SELECT product, COUNT(*) FROM orderitem GROUP BY product;
> ```
>
> 按商品名称统计，每类商品所花费的总金额
>
> ```mysql
> SELECT product, SUM(price) FROM orderitem GROUP BY product;
> ```
>
> 按商品名称统计，统计每类商品花费的总金额在5000元以上的商品
>
> - <span style="color: red;">where的子句后面不能跟着聚合函数</span>
> - 如果要在带有聚合函数的语句中使用条件过滤(分组后条件过滤)，需要使用一个关键字**having**
>
> ```mysql
> SELECT product, SUM(price) FROM orderitem GROUP BY product HAVING SUM(price) > 5000;
> ```
>
> 按商品名称统计，统计每类商品花费的总金额在5000元以上的商品，并且按照总金额升序排序
>
> ```mysql
> SELECT product, SUM(price) FROM orderitem GROUP BY product HAVING SUM(price) > 5000 ORDER BY SUM(price) ASC;
> ```
>
> **SQL语句分组查询的顺序**：
>
> <span style="color: red;">S</span>(<span style="color: #329BDC;">SELECT</span>)...<span style="color: red;">F</span>(<span style="color: #329BDC;">FROM</span>)...<span style="color: red;">W</span>(<span style="color: #329BDC;">WHERE</span>)...<span style="color: red;">G</span>(<span style="color: #329BDC;">GROUP BY</span>)...<span style="color: red;">H</span>(<span style="color: #329BDC;">HAVING</span>)...<span style="color: red;">O</span>(<span style="color: #329BDC;">ORDER BY</span>);

## 多表设计之外键约束

> **约束的作用**：
>
> 约束是用来保证数据的完整性
>
> **单表约束与多表约束**
>
> 单表约束：
>
> - 主键约束
> - 唯一约束
> - 非空约束
>
> 多表约束
>
> - 外键约束：用来保证数据的完整性(多表之间)
>
> **无外键约束的演示**
>
> 环境准备：
>
> ```mysql
> -- 创建部门表
> CREATE TABLE dept(
> 	did INT PRIMARY KEY AUTO_INCREMENT,
>     dname VARCHAR(20)
> );
> -- 添加部门数据
> INSERT INTO dept VALUES (null, '市场部');
> INSERT INTO dept VALUES (null, '人事部');
> INSERT INTO dept VALUES (null, '教研部');
> 
> -- 创建员工表
> CREATE TABLE employee(
> 	eid INT PRIMARY KEY AUTO_INCREMENT,
>     ename VARCHAR(20),
>     salary DOUBLE,
>     birthday DATE,
>     sex VARCHAR(20),
>     dno INT
> );
> -- 添加员工数据
> INSERT INTO employee VALUES (null, '张三', 8000, '1988-09-01', '男', 3);
> INSERT INTO employee VALUES (null, '李四', 9000, '1988-09-01', '男', 1);
> INSERT INTO employee VALUES (null, '王五', 6000, '1988-09-01', '男', 2);
> INSERT INTO employee VALUES (null, '赵六', 10000, '1988-09-01', '男', 3);
> INSERT INTO employee VALUES (null, '孙七', 10000, '1988-09-01', '男', 1);
> ```
>
> 向员工表中插入一条记录(没有部门)
>
> ```mysql
> INSERT INTO employee VALUES (null, '田八', 10000, '1988-09-01', '男', null);
> ```
>
> 删除其中的某个部门
>
> ```mysql
> DELETE FROM dept WHERE did=2;
> ```
>
> <span style="color: red;">像上述这两个操作(插入一个没有部门的员工，删除一个带有员工的部门)。这种情况都是不应该发生的。这个时候需要在多表之间添加外键约束。</span>
>
> **添加外键约束**
>
> 在员工表上添加外键
>
> - 语法：FOREIGN KEY (外键) REFERENCES 主键表(主键列);
>
> ```mysql
> -- 设置外键为非空
> ALTER TABLE employee MODIFY dno INT NOT NULL;
> -- 在员工表上添加外键
> ALTER TABLE employee ADD FOREIGN KEY (dno) REFERENCES dept(did);
> ```

## 连接查询

> 环境准备：
>
> ```mysql
> -- 创建部门表
> DROP TABLE IF EXISTS dept; 
> CREATE TABLE dept(
>  -- 部门编号
>  deptno int PRIMARY KEY, 
>  -- 部门名称
>  dname VARCHAR(14), 
>  -- 部门所在地
>  loc VARCHAR(13)
> );
> 
> -- 向部门表插入数据
> INSERT INTO dept VALUES (10,'ACCOUNTING','NEW YORK');
> INSERT INTO dept VALUES (20,'RESEARCH','DALLAS');
> INSERT INTO dept VALUES (30,'SALES','CHICAGO');
> INSERT INTO dept VALUES (40,'OPERATIONS','BOSTON');
> 
> -- 创建员工表
> DROP TABLE IF EXISTS emp;
> CREATE TABLE emp(
> 	-- 员工编号
> 	empno int PRIMARY KEY, 
> 	-- 员工姓名
> 	ename VARCHAR(10), 
> 	-- 工作岗位
> 	job VARCHAR(9), 
> 	-- 直属领导
> 	mgr int, 
> 	-- 入职时间
> 	hiredate DATE, 
> 	-- 工资
> 	sal double, 
> 	-- 奖金
> 	comm double, 
> 	-- 所属部门
> 	deptno int
> );
> 
> -- 为员工表表添加外键约束
> ALTER TABLE emp ADD CONSTRAINT FOREIGN KEY EMP(deptno) REFERENCES dept (deptno);
> 
> -- 向员工表插入数据
> INSERT INTO emp VALUES(7369,'SMITH','CLERK',7902,"1980-12-17",800,NULL,20);
> INSERT INTO emp VALUES(7499,'ALLEN','SALESMAN',7698,'1981-02-20',1600,300,30);
> INSERT INTO emp VALUES(7521,'WARD','SALESMAN',7698,'1981-02-22',1250,500,30);
> INSERT INTO emp VALUES(7566,'JONES','MANAGER',7839,'1981-04-02',2975,NULL,20);
> INSERT INTO emp VALUES(7654,'MARTIN','SALESMAN',7698,'1981-09-28',1250,1400,30);
> INSERT INTO emp VALUES(7698,'BLAKE','MANAGER',7839,'1981-05-01',2850,NULL,30);
> INSERT INTO emp VALUES(7782,'CLARK','MANAGER',7839,'1981-06-09',2450,NULL,10);
> INSERT INTO emp VALUES(7788,'SCOTT','ANALYST',7566,'1987-07-03',3000,NULL,20);
> INSERT INTO emp VALUES(7839,'KING','PRESIDENT',NULL,'1981-11-17',5000,NULL,10);
> INSERT INTO emp VALUES(7844,'TURNER','SALESMAN',7698,'1981-09-08',1500,0,30);
> INSERT INTO emp VALUES(7876,'ADAMS','CLERK',7788,'1987-07-13',1100,NULL,20);
> INSERT INTO emp VALUES(7900,'JAMES','CLERK',7698,'1981-12-03',950,NULL,30);
> INSERT INTO emp VALUES(7902,'FORD','ANALYST',7566,'1981-12-03',3000,NULL,20);
> INSERT INTO emp VALUES(7934,'MILLER','CLERK',7782,'1981-01-23',1300,NULL,10);
> 
> -- 创建工资等级表
> DROP TABLE IF EXISTS salgrade;
> CREATE TABLE salgrade(
> 	-- 等级
> 	grade int, 
> 	-- 最低工资
> 	losal double, 
> 	-- 最高工资
> 	hisal double
> );
> 
> -- 向工资等级表插入数据
> INSERT INTO salgrade VALUES (1,700,1200);
> INSERT INTO salgrade VALUES (2,1201,1400);
> INSERT INTO salgrade VALUES (3,1401,2000);
> INSERT INTO salgrade VALUES (4,2001,3000);
> INSERT INTO salgrade VALUES (5,3001,9999);
> ```
>
> 从一张表中单独查询，称为单表查询
>
> emp表和dept表联合起来查询，从emp表中取员工名字，从dept表中取部门名字。这种跨表查询，多张表联合起来查询数据，被称为连接查询
>
> 两表查询之间通过主外键进行关联查询

#### 连接查询的分类

> - **内连接**
>   - 等值连接
>   - 非等值连接
>   - 自连接
> - **外链接**
>   - 左外连接(左链接)
>   - 右外连接(右连接)
> - **全连接(了解)**
>

#### 笛卡尔积现象

> 笛卡尔查询(多表查询)语法：
>
> ```mysql
> SELECT * FROM <表1>，<表2>;
> ```
>
> <span style="color: red;">当两张表进行连接查询是，没有任何条件的限制时，最终查询结果条数，是两张表条数的乘积</span>(*实际上也就是把两个表或者多个表的记录排列组合在一起。但是不同的表可能会有相同的字段名，如id字段*)
>
> 查询每个员工所在部门名称
>
> ```mysql
> SELECT ename,dname FROM emp,dept; -- 每个员工的记录都会查询出所有的部门信息
> ```
>
> 如何避免笛卡尔积现象
>
> - 连接时加条件，满足这个条件的记录被筛选出来
>
>   ```mysql
>   SELECT ename,dname FROM emp,dept WHERE emp.deptno=dept.deptno;
>   ```
>
> - 最终查询的结果条数是14条，但是匹配的过程中，匹配的次数没有减少，只不过将满足条件的筛选出来而已
>
> - 给表起别名来提升效率(SQL92语法)
>
>   ```mysql
>   SELECT e.ename, d.dname FROM emp e, dept d WHERE e.deptno=d.deptno;
>   ```
>
> - 注意：通过笛卡尔积现象得出，表的连接次数越多，效率越低，尽量避免表的连接次数
>

#### 内连接

> *等值连接*
>
> 查询每个员工所在部门名称，显示员工名和部门名
>
> emp e和dept d表进行连接。条件是e.deptno=d.deptno
>
> SQL92语法
>
> ```mysql
> SELECT e.ename, d.dname FROM emp e, dept d WHERE e.deptno=d.deptno;
> ```
>
> SQL99语法
>
> ```mysql
> SELECT e.ename, d.dname FROM emp e INNER JOIN dept d ON e.deptno=d.deptno; -- 可读性更好
> SELECT e.ename, d.dname FROM emp e JOIN dept d ON e.deptno=d.deptno; -- INNER可省略
> ```
>
> *带着inner的属于内连接*
>
> SQL92语法的缺点：
>
> - 结构不清晰，表的连接条件，和后期进一步筛选的条件，都放到了where后面 
>
> SQL99语法的优点：
>
> - 表连接的条件是独立，连接之后，如果还需要进一步筛选，再王后继续添加where
>
>   ```mysql
>   SELECT ... FROM a JOIN b ON a和b的连接条件 WHERE 筛选条件;
>   ```
>
> DBA：数据库管理员，主要负责算法和数据结构，几乎什么样的数据库底层原理他们都要搞一搞
>
> <span style="color: #329BDC;">等值连接指的是两张表之间的连接条件是一个等量关系</span>。
>
> *非等值连接*
>
> 找出每个员工的薪资等级，要求显示员工名、薪资、薪资等级
>
> ```mysql
> SELECT e.ename, e.sal, s.grade FROM emp e JOIN salgrade s ON e.sal BETWEEN s.losal AND s.hisal;
> ```
>
> <span style="color: #329BDC;">非等值连接指的是两张表之间的连接条件不是一个等量关系</span>。
>
> *自连接*
>
> 查询员工的上级领导，要求显示员工名和对应的领导名
>
> *由于员工和领导的信息都在同一张表上，所以需要使用一点技巧*
>
> <span style="color: #329BDC;">技巧：一张表看成两张表</span>
>
> - emp a：员工表
> - emp b：领导表
>
> ```mysql
> SELECT a.ename, b.ename FROM emp a JOIN emp b ON a.mgr=b.empno;
> -- 给a.ename取别名为员工名，b.ename取别名为领导名
> SELECT a.ename AS '员工名', b.ename AS '领导名' FROM emp a JOIN emp b ON a.mgr=b.empno; 
> ```
>
> *内连接的特点：完成能够匹配上这个条件的数据查询出来*
>

#### 外链接

> *右外连接(右连接)*
>
> 查询每个员工所在部门名称，显示员工名和所有的部门名
>
> ```mysql
> SELECT e.ename, d.dname FROM emp e RIGHT JOIN dept d ON e.deptno=d.deptno; -- 省略outer
> SELECT e.ename, d.dname FROM emp e RIGHT OUTER JOIN dept d ON e.deptno=d.deptno;
> ```
>
> right：表示将join关键字右边的这张表看成主表，主要是为了将这张表的数据全部查询出来，捎带着关键查询左边的表
>
> 在外链接中，两张表连接，出现了主次关系
>
> *左外连接(左链接)*
>
> 与右外链接相同，但是使用left关键字，将join关键字的左边的这张表看成主表
>
> ```mysql
> SELECT e.ename, d.dname FROM dept d LEFT JOIN emp e ON e.deptno=d.deptno;
> ```
>
> **任何一个右连接都有左连接的写法，任何一个左连接都有右连接的写法**
>
> <span style="color: red;">外链接的查询结果条数一定 >= 内连接的查询结果条数</span>
>
> 查询每个员工的上级领导，要求显示所有员工的名字和领导名
>
> ```mysql
> SELECT a.ename AS '员工名', b.ename AS '领导名' FROM emp a LEFT JOIN emp b ON a.mgr=b.empno;
> ```
>

#### 子查询

> **什么是子查询**
>
> select语句中嵌套select语句，被嵌套的select语句称为子查询
>
> **子查询都可以出现在哪里**
>
> select ..(select). from ..(select). where ..(select).

##### where子句中的子查询

> 找出比最低工资高的员工姓名和工资
>
> ```mysql
> -- where子句中不能直接使用分组函数
> SELECT ename, sal FROM emp WHERE sal > min(sal); -- 1111 - Invalid use of group function
> ```
>
> 实现思路
>
> 1. 查询最低工资是多少
>
>    ```mysql
>    SELECT min(sal) FROM emp; -- 800
>    ```
>
> 2. 找出大于800的
>
>    ```mysql
>    SELECT ename, sal FROM emp WHERE sal > 800;
>    ```
>
> 3. 合并
>
>    ```mysql
>    -- 子查询，先执行括号内的，再查询括号外的
>    SELECT ename, sal FROM emp WHERE sal > (SELECT min(sal) FROM emp);
>    ```
>

##### from子句中的子查询

> **注意：from后面的子查询，可以将子查询的查询结果当做一张临时表。(技巧)**
>
> 找出每个岗位的平均工资的薪资等级
>
> 1. 找出每个岗位的平均工资(按照岗位分组求平均值)
>
>    ```mysql
>    SELECT job, AVG(sal) FROM emp GROUP BY job;
>    ```
>
> 2. 把第一步查询的结果当做一张真实存在的表t，根据表t来查询薪资等级
>
>    1. 将薪资*表t*和薪资等级*表s*进行表连接，条件：t表的avg(sal) between s.losal and s.hisal;
>
>    ```mysql
>    SELECT t.*, s.grade FROM t JOIN salgrade s ON t.AVG(sal) BETWEEN  s.losal AND s.hisal;
>    ```
>
> 3. 修改上面的语句并进行合并
>
>    1. 给 AVG(sal) 起别名 avgsal
>
>       ```mysql
>       SELECT job, AVG(sal) AS avgsal FROM emp GROUP BY job;
>       ```
>
>    2. 将第一步的语句放入第二步中，并为其起个别名t
>
>       ```mysql
>       SELECT t.*, s.grade FROM (SELECT job, AVG(sal) AS avgsal FROM emp GROUP BY job) AS t JOIN salgrade s ON t.AVG(sal) BETWEEN  s.losal AND s.hisal;
>       ```
>
>    3. 对 t 的查询条件 t.AVG(sal) 改为对 AVG(sal) 起的别名 t.avgsal
>
>    ```mysql
>    SELECT t.*, s.grade FROM (SELECT job, AVG(sal) AS avgsal FROM emp GROUP BY job) AS t JOIN salgrade s ON t.avgsal BETWEEN  s.losal AND s.hisal;
>    ```
>

##### select子句中的子查询(了解)

> 找出每个员工的部门名称，要求显示员工名，部门名
>
> ```mysql
> SELECT e.ename, (SELECT d.dname FROM dept d WHERE e.deptno=d.deptno) FROM emp e;
> ```
>
> 注意：对于select后面的子查询来说，这个子查询只能一次返回一条结果，多于一条就报错
>
> ```mysql
> -- ERROR 1242 (21000): Subquery returns more than 1 row
> SELECT e.ename, e.deptno, (SELECT dname FROM dept) AS dname FROM emp e;
> ```
>

##### union合并查询结果集

> 查询工作岗位是MANAGER和SALESMAN的员工
>
> ```mysql
> SELECT ename,job FROM emp WHERE job='MANAGER' OR job='SALESMAN';
> SELECT ename,job FROM emp WHERE job IN('MANAGER', 'SALESMAN');
> ```
>
> 使用union进行结果集合并
>
> ```mysql
> SELECT ename,job FROM emp WHERE job='MANAGER' UNION SELECT ename,job FROM emp WHERE job='SALESMAN';
> ```
>
> - union的效率要高些。
>   - 对于表连接来说，每连接一次新表，则匹配的次数满足笛卡尔积，成倍的翻。。。
>     - a，b，c各有10条记录
>       - a 连接 b 连接 c，匹配次数是1000次
>   - 但是union可以减少匹配的次数。在减少匹配次数的情况下，还可以完成两个结果集的拼接
>     - a，b，c各有10条记录
>       - a 连接 b，匹配次数是100次
>       - a 连接 c，匹配次数是100次
>       - 使用union的话是：100 + 100 = 200次
>
> union使用时的注意事项：
>
> - union在进行结果集合并的时候，要求两个结果集的列数相同。
> - mysql中允许不同数据类型的结果集合并，oracle语法严格，会报错

## 分页查询

> 使用**LIMIT**字段
>
> limit是讲查询结果集的一部分取出来，通常使用在分页查询当中
>
> 分页的作用是为了提高用户的体验，因为一次全部都查出来，用户体验差
>
> 可以一页一页翻页看
>

#### limit使用

> 按照英语成绩降序，取出排名在前3名的学生
>
> ```mysql
> SELECT name,english FROM exam ORDER BY english DESC LIMIT 3;
> ```
>
> 完整用法：limit startIndex, length
>
> - startIndex：起始下标，默认从0开始
> - length：长度
>
> 缺省用法：limit length
>
> <span style="color: red;">注意：mysql当中limit在order by之后执行！</span>
>
> 取出排名为[3-5]的学生
>
> ```mysql
> -- 2表示起始位置从下标2开始，就是第三条记录，3表示长度
> SELECT name,english FROM exam ORDER BY english DESC LIMIT 2, 3;
> ```
>
> 取出排名在[2-5]名的学生(包含第二名和第五名)
>
> ```mysql
> SELECT name,english FROM exam ORDER BY english DESC LIMIT 1, 4;
> ```

#### 分页

> 每页显示3条记录
>
> - 第一页：limit 0, 3
>
> - 第二页：limit 3, 3
>
> - 第三页：limit 6, 3
>
> - 第四页：limit 9, 3
>
> 每页显示pageSize条记录
>
> - 第pageNo页：limit pageSize * (pageNo - 1), pageSize
>
> ```java
> public static void main(String[] args) {
>     // 用户提交过来一个页码，以及每页显示的记录条数
>     int pageNo = 5; // 
>     int pageSize = 10;
>     
>     int startIndex = (pageNo - 1) * pageSize;
>     String sql = "select ... limit" + startIndex + ", " + pageSize;
> }
> ```
>
> **通用分页公式**
>
> ```mysql
> LIMIT pageSize * (pageNo - 1), pageSize;
> ```

#### 关于DQL语句的总结

> ```mysql
> SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... DESC LIMIT ...;
> ```
>
> 执行顺序：
>
> 1. from
> 2. where
> 3. group by
> 4. having
> 5. select
> 6. order by
> 7. limit

## 如何避免 SQL 注入

> 